// node_modules/@babylonjs/core/tslib.es6.js
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js
var AndOrNotEvaluator = class _AndOrNotEvaluator {
  /**
   * Evaluate a query
   * @param query defines the query to evaluate
   * @param evaluateCallback defines the callback used to filter result
   * @returns true if the query matches
   */
  static Eval(query, evaluateCallback) {
    if (!query.match(/\([^()]*\)/g)) {
      query = _AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);
    } else {
      query = query.replace(/\([^()]*\)/g, (r) => {
        r = r.slice(1, r.length - 1);
        return _AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);
      });
    }
    if (query === "true") {
      return true;
    }
    if (query === "false") {
      return false;
    }
    return _AndOrNotEvaluator.Eval(query, evaluateCallback);
  }
  static _HandleParenthesisContent(parenthesisContent, evaluateCallback) {
    evaluateCallback = evaluateCallback || ((r) => {
      return r === "true" ? true : false;
    });
    let result;
    const or = parenthesisContent.split("||");
    for (const i in or) {
      if (Object.prototype.hasOwnProperty.call(or, i)) {
        let ori = _AndOrNotEvaluator._SimplifyNegation(or[i].trim());
        const and = ori.split("&&");
        if (and.length > 1) {
          for (let j = 0; j < and.length; ++j) {
            const andj = _AndOrNotEvaluator._SimplifyNegation(and[j].trim());
            if (andj !== "true" && andj !== "false") {
              if (andj[0] === "!") {
                result = !evaluateCallback(andj.substring(1));
              } else {
                result = evaluateCallback(andj);
              }
            } else {
              result = andj === "true" ? true : false;
            }
            if (!result) {
              ori = "false";
              break;
            }
          }
        }
        if (result || ori === "true") {
          result = true;
          break;
        }
        if (ori !== "true" && ori !== "false") {
          if (ori[0] === "!") {
            result = !evaluateCallback(ori.substring(1));
          } else {
            result = evaluateCallback(ori);
          }
        } else {
          result = ori === "true" ? true : false;
        }
      }
    }
    return result ? "true" : "false";
  }
  static _SimplifyNegation(booleanString) {
    booleanString = booleanString.replace(/^[\s!]+/, (r) => {
      r = r.replace(/[\s]/g, () => "");
      return r.length % 2 ? "!" : "";
    });
    booleanString = booleanString.trim();
    if (booleanString === "!true") {
      booleanString = "false";
    } else if (booleanString === "!false") {
      booleanString = "true";
    }
    return booleanString;
  }
};

// node_modules/@babylonjs/core/Misc/tags.js
var Tags = class _Tags {
  /**
   * Adds support for tags on the given object
   * @param obj defines the object to use
   */
  static EnableFor(obj) {
    obj._tags = obj._tags || {};
    obj.hasTags = () => {
      return _Tags.HasTags(obj);
    };
    obj.addTags = (tagsString) => {
      return _Tags.AddTagsTo(obj, tagsString);
    };
    obj.removeTags = (tagsString) => {
      return _Tags.RemoveTagsFrom(obj, tagsString);
    };
    obj.matchesTagsQuery = (tagsQuery) => {
      return _Tags.MatchesQuery(obj, tagsQuery);
    };
  }
  /**
   * Removes tags support
   * @param obj defines the object to use
   */
  static DisableFor(obj) {
    delete obj._tags;
    delete obj.hasTags;
    delete obj.addTags;
    delete obj.removeTags;
    delete obj.matchesTagsQuery;
  }
  /**
   * Gets a boolean indicating if the given object has tags
   * @param obj defines the object to use
   * @returns a boolean
   */
  static HasTags(obj) {
    if (!obj._tags) {
      return false;
    }
    const tags = obj._tags;
    for (const i in tags) {
      if (Object.prototype.hasOwnProperty.call(tags, i)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Gets the tags available on a given object
   * @param obj defines the object to use
   * @param asString defines if the tags must be returned as a string instead of an array of strings
   * @returns the tags
   */
  static GetTags(obj, asString = true) {
    if (!obj._tags) {
      return null;
    }
    if (asString) {
      const tagsArray = [];
      for (const tag in obj._tags) {
        if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {
          tagsArray.push(tag);
        }
      }
      return tagsArray.join(" ");
    } else {
      return obj._tags;
    }
  }
  /**
   * Adds tags to an object
   * @param obj defines the object to use
   * @param tagsString defines the tag string. The tags 'true' and 'false' are reserved and cannot be used as tags.
   * A tag cannot start with '||', '&&', and '!'. It cannot contain whitespaces
   */
  static AddTagsTo(obj, tagsString) {
    if (!tagsString) {
      return;
    }
    if (typeof tagsString !== "string") {
      return;
    }
    const tags = tagsString.split(" ");
    tags.forEach(function(tag) {
      _Tags._AddTagTo(obj, tag);
    });
  }
  /**
   * @internal
   */
  static _AddTagTo(obj, tag) {
    tag = tag.trim();
    if (tag === "" || tag === "true" || tag === "false") {
      return;
    }
    if (tag.match(/[\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {
      return;
    }
    _Tags.EnableFor(obj);
    obj._tags[tag] = true;
  }
  /**
   * Removes specific tags from a specific object
   * @param obj defines the object to use
   * @param tagsString defines the tags to remove
   */
  static RemoveTagsFrom(obj, tagsString) {
    if (!_Tags.HasTags(obj)) {
      return;
    }
    const tags = tagsString.split(" ");
    for (const t in tags) {
      _Tags._RemoveTagFrom(obj, tags[t]);
    }
  }
  /**
   * @internal
   */
  static _RemoveTagFrom(obj, tag) {
    delete obj._tags[tag];
  }
  /**
   * Defines if tags hosted on an object match a given query
   * @param obj defines the object to use
   * @param tagsQuery defines the tag query
   * @returns a boolean
   */
  static MatchesQuery(obj, tagsQuery) {
    if (tagsQuery === void 0) {
      return true;
    }
    if (tagsQuery === "") {
      return _Tags.HasTags(obj);
    }
    return AndOrNotEvaluator.Eval(tagsQuery, (r) => _Tags.HasTags(obj) && obj._tags[r]);
  }
};

// node_modules/@babylonjs/core/Maths/math.scalar.js
var Scalar = class _Scalar {
  /**
   * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)
   * @param a number
   * @param b number
   * @param epsilon (default = 1.401298E-45)
   * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)
   */
  static WithinEpsilon(a, b, epsilon = 1401298e-51) {
    return Math.abs(a - b) <= epsilon;
  }
  /**
   * Returns a string : the upper case translation of the number i to hexadecimal.
   * @param i number
   * @returns the upper case translation of the number i to hexadecimal.
   */
  static ToHex(i) {
    const str = i.toString(16);
    if (i <= 15) {
      return ("0" + str).toUpperCase();
    }
    return str.toUpperCase();
  }
  /**
   * Returns -1 if value is negative and +1 is value is positive.
   * @param value the value
   * @returns the value itself if it's equal to zero.
   */
  static Sign(value) {
    value = +value;
    if (value === 0 || isNaN(value)) {
      return value;
    }
    return value > 0 ? 1 : -1;
  }
  /**
   * Returns the value itself if it's between min and max.
   * Returns min if the value is lower than min.
   * Returns max if the value is greater than max.
   * @param value the value to clmap
   * @param min the min value to clamp to (default: 0)
   * @param max the max value to clamp to (default: 1)
   * @returns the clamped value
   */
  static Clamp(value, min = 0, max = 1) {
    return Math.min(max, Math.max(min, value));
  }
  /**
   * the log2 of value.
   * @param value the value to compute log2 of
   * @returns the log2 of value.
   */
  static Log2(value) {
    return Math.log(value) * Math.LOG2E;
  }
  /**
   * the floor part of a log2 value.
   * @param value the value to compute log2 of
   * @returns the log2 of value.
   */
  static ILog2(value) {
    if (Math.log2) {
      return Math.floor(Math.log2(value));
    }
    if (value < 0) {
      return NaN;
    } else if (value === 0) {
      return -Infinity;
    }
    let n = 0;
    if (value < 1) {
      while (value < 1) {
        n++;
        value = value * 2;
      }
      n = -n;
    } else if (value > 1) {
      while (value > 1) {
        n++;
        value = Math.floor(value / 2);
      }
    }
    return n;
  }
  /**
   * Loops the value, so that it is never larger than length and never smaller than 0.
   *
   * This is similar to the modulo operator but it works with floating point numbers.
   * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.
   * With t = 5 and length = 2.5, the result would be 0.0.
   * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator
   * @param value the value
   * @param length the length
   * @returns the looped value
   */
  static Repeat(value, length) {
    return value - Math.floor(value / length) * length;
  }
  /**
   * Normalize the value between 0.0 and 1.0 using min and max values
   * @param value value to normalize
   * @param min max to normalize between
   * @param max min to normalize between
   * @returns the normalized value
   */
  static Normalize(value, min, max) {
    return (value - min) / (max - min);
  }
  /**
   * Denormalize the value from 0.0 and 1.0 using min and max values
   * @param normalized value to denormalize
   * @param min max to denormalize between
   * @param max min to denormalize between
   * @returns the denormalized value
   */
  static Denormalize(normalized, min, max) {
    return normalized * (max - min) + min;
  }
  /**
   * Calculates the shortest difference between two given angles given in degrees.
   * @param current current angle in degrees
   * @param target target angle in degrees
   * @returns the delta
   */
  static DeltaAngle(current, target) {
    let num = _Scalar.Repeat(target - current, 360);
    if (num > 180) {
      num -= 360;
    }
    return num;
  }
  /**
   * PingPongs the value t, so that it is never larger than length and never smaller than 0.
   * @param tx value
   * @param length length
   * @returns The returned value will move back and forth between 0 and length
   */
  static PingPong(tx, length) {
    const t = _Scalar.Repeat(tx, length * 2);
    return length - Math.abs(t - length);
  }
  /**
   * Interpolates between min and max with smoothing at the limits.
   *
   * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up
   * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.
   * @param from from
   * @param to to
   * @param tx value
   * @returns the smooth stepped value
   */
  static SmoothStep(from, to, tx) {
    let t = _Scalar.Clamp(tx);
    t = -2 * t * t * t + 3 * t * t;
    return to * t + from * (1 - t);
  }
  /**
   * Moves a value current towards target.
   *
   * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.
   * Negative values of maxDelta pushes the value away from target.
   * @param current current value
   * @param target target value
   * @param maxDelta max distance to move
   * @returns resulting value
   */
  static MoveTowards(current, target, maxDelta) {
    let result = 0;
    if (Math.abs(target - current) <= maxDelta) {
      result = target;
    } else {
      result = current + _Scalar.Sign(target - current) * maxDelta;
    }
    return result;
  }
  /**
   * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
   *
   * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta
   *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.
   * @param current current value
   * @param target target value
   * @param maxDelta max distance to move
   * @returns resulting angle
   */
  static MoveTowardsAngle(current, target, maxDelta) {
    const num = _Scalar.DeltaAngle(current, target);
    let result = 0;
    if (-maxDelta < num && num < maxDelta) {
      result = target;
    } else {
      target = current + num;
      result = _Scalar.MoveTowards(current, target, maxDelta);
    }
    return result;
  }
  /**
   * Creates a new scalar with values linearly interpolated of "amount" between the start scalar and the end scalar.
   * @param start start value
   * @param end target value
   * @param amount amount to lerp between
   * @returns the lerped value
   */
  static Lerp(start, end, amount) {
    return start + (end - start) * amount;
  }
  /**
   * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
   * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.
   * @param start start value
   * @param end target value
   * @param amount amount to lerp between
   * @returns the lerped value
   */
  static LerpAngle(start, end, amount) {
    let num = _Scalar.Repeat(end - start, 360);
    if (num > 180) {
      num -= 360;
    }
    return start + num * _Scalar.Clamp(amount);
  }
  /**
   * Calculates the linear parameter t that produces the interpolant value within the range [a, b].
   * @param a start value
   * @param b target value
   * @param value value between a and b
   * @returns the inverseLerp value
   */
  static InverseLerp(a, b, value) {
    let result = 0;
    if (a != b) {
      result = _Scalar.Clamp((value - a) / (b - a));
    } else {
      result = 0;
    }
    return result;
  }
  /**
   * Returns a new scalar located for "amount" (float) on the Hermite spline defined by the scalars "value1", "value3", "tangent1", "tangent2".
   * @see http://mathworld.wolfram.com/HermitePolynomial.html
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param amount defines the amount on the interpolation spline (between 0 and 1)
   * @returns hermite result
   */
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;
  }
  /**
   * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars "value1", "value2", "tangent1", "tangent2".
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @returns 1st derivative
   */
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const t2 = time * time;
    return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;
  }
  /**
   * Returns a random float number between and min and max values
   * @param min min value of random
   * @param max max value of random
   * @returns random value
   */
  static RandomRange(min, max) {
    if (min === max) {
      return min;
    }
    return Math.random() * (max - min) + min;
  }
  /**
   * This function returns percentage of a number in a given range.
   *
   * RangeToPercent(40,20,60) will return 0.5 (50%)
   * RangeToPercent(34,0,100) will return 0.34 (34%)
   * @param number to convert to percentage
   * @param min min range
   * @param max max range
   * @returns the percentage
   */
  static RangeToPercent(number, min, max) {
    return (number - min) / (max - min);
  }
  /**
   * This function returns number that corresponds to the percentage in a given range.
   *
   * PercentToRange(0.34,0,100) will return 34.
   * @param percent to convert to number
   * @param min min range
   * @param max max range
   * @returns the number
   */
  static PercentToRange(percent, min, max) {
    return (max - min) * percent + min;
  }
  /**
   * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.
   * @param angle The angle to normalize in radian.
   * @returns The converted angle.
   */
  static NormalizeRadians(angle) {
    angle -= _Scalar.TwoPi * Math.floor((angle + Math.PI) / _Scalar.TwoPi);
    return angle;
  }
  /**
   * Returns the highest common factor of two integers.
   * @param a first parameter
   * @param b second parameter
   * @returns HCF of a and b
   */
  static HCF(a, b) {
    const r = a % b;
    if (r === 0) {
      return b;
    }
    return _Scalar.HCF(b, r);
  }
};
Scalar.TwoPi = Math.PI * 2;

// node_modules/@babylonjs/core/Maths/math.constants.js
var ToGammaSpace = 1 / 2.2;
var ToLinearSpace = 2.2;
var PHI = (1 + Math.sqrt(5)) / 2;
var Epsilon = 1e-3;

// node_modules/@babylonjs/core/Misc/typeStore.js
var _RegisteredTypes = {};
function RegisterClass(className2, type) {
  _RegisteredTypes[className2] = type;
}
function GetClass(fqdn) {
  return _RegisteredTypes[fqdn];
}

// node_modules/@babylonjs/core/Engines/performanceConfigurator.js
var PerformanceConfigurator = class _PerformanceConfigurator {
  /**
   * @internal
   */
  static SetMatrixPrecision(use64bits) {
    _PerformanceConfigurator.MatrixTrackPrecisionChange = false;
    if (use64bits && !_PerformanceConfigurator.MatrixUse64Bits) {
      if (_PerformanceConfigurator.MatrixTrackedMatrices) {
        for (let m = 0; m < _PerformanceConfigurator.MatrixTrackedMatrices.length; ++m) {
          const matrix = _PerformanceConfigurator.MatrixTrackedMatrices[m];
          const values = matrix._m;
          matrix._m = new Array(16);
          for (let i = 0; i < 16; ++i) {
            matrix._m[i] = values[i];
          }
        }
      }
    }
    _PerformanceConfigurator.MatrixUse64Bits = use64bits;
    _PerformanceConfigurator.MatrixCurrentType = _PerformanceConfigurator.MatrixUse64Bits ? Array : Float32Array;
    _PerformanceConfigurator.MatrixTrackedMatrices = null;
  }
};
PerformanceConfigurator.MatrixUse64Bits = false;
PerformanceConfigurator.MatrixTrackPrecisionChange = true;
PerformanceConfigurator.MatrixCurrentType = Float32Array;
PerformanceConfigurator.MatrixTrackedMatrices = [];

// node_modules/@babylonjs/core/Misc/observable.js
var EventState = class {
  /**
   * Create a new EventState
   * @param mask defines the mask associated with this state
   * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
   * @param target defines the original target of the state
   * @param currentTarget defines the current target of the state
   */
  constructor(mask, skipNextObservers = false, target, currentTarget) {
    this.initialize(mask, skipNextObservers, target, currentTarget);
  }
  /**
   * Initialize the current event state
   * @param mask defines the mask associated with this state
   * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
   * @param target defines the original target of the state
   * @param currentTarget defines the current target of the state
   * @returns the current event state
   */
  initialize(mask, skipNextObservers = false, target, currentTarget) {
    this.mask = mask;
    this.skipNextObservers = skipNextObservers;
    this.target = target;
    this.currentTarget = currentTarget;
    return this;
  }
};
var Observer = class {
  /**
   * Creates a new observer
   * @param callback defines the callback to call when the observer is notified
   * @param mask defines the mask of the observer (used to filter notifications)
   * @param scope defines the current scope used to restore the JS context
   */
  constructor(callback, mask, scope = null) {
    this.callback = callback;
    this.mask = mask;
    this.scope = scope;
    this._willBeUnregistered = false;
    this.unregisterOnNextCall = false;
    this._remove = null;
  }
  /**
   * Remove the observer from its observable
   * This can be used instead of using the observable's remove function.
   */
  remove() {
    if (this._remove) {
      this._remove();
    }
  }
};
var Observable = class _Observable {
  /**
   * Create an observable from a Promise.
   * @param promise a promise to observe for fulfillment.
   * @param onErrorObservable an observable to notify if a promise was rejected.
   * @returns the new Observable
   */
  static FromPromise(promise, onErrorObservable) {
    const observable = new _Observable();
    promise.then((ret) => {
      observable.notifyObservers(ret);
    }).catch((err) => {
      if (onErrorObservable) {
        onErrorObservable.notifyObservers(err);
      } else {
        throw err;
      }
    });
    return observable;
  }
  /**
   * Gets the list of observers
   * Note that observers that were recently deleted may still be present in the list because they are only really deleted on the next javascript tick!
   */
  get observers() {
    return this._observers;
  }
  /**
   * Creates a new observable
   * @param onObserverAdded defines a callback to call when a new observer is added
   * @param notifyIfTriggered If set to true the observable will notify when an observer was added if the observable was already triggered.
   */
  constructor(onObserverAdded, notifyIfTriggered = false) {
    this.notifyIfTriggered = notifyIfTriggered;
    this._observers = new Array();
    this._numObserversMarkedAsDeleted = 0;
    this._hasNotified = false;
    this._eventState = new EventState(0);
    if (onObserverAdded) {
      this._onObserverAdded = onObserverAdded;
    }
  }
  add(callback, mask = -1, insertFirst = false, scope = null, unregisterOnFirstCall = false) {
    if (!callback) {
      return null;
    }
    const observer = new Observer(callback, mask, scope);
    observer.unregisterOnNextCall = unregisterOnFirstCall;
    if (insertFirst) {
      this._observers.unshift(observer);
    } else {
      this._observers.push(observer);
    }
    if (this._onObserverAdded) {
      this._onObserverAdded(observer);
    }
    if (this._hasNotified && this.notifyIfTriggered) {
      if (this._lastNotifiedValue !== void 0) {
        this.notifyObserver(observer, this._lastNotifiedValue);
      }
    }
    observer._remove = () => {
      this.remove(observer);
    };
    return observer;
  }
  addOnce(callback) {
    return this.add(callback, void 0, void 0, void 0, true);
  }
  /**
   * Remove an Observer from the Observable object
   * @param observer the instance of the Observer to remove
   * @returns false if it doesn't belong to this Observable
   */
  remove(observer) {
    if (!observer) {
      return false;
    }
    observer._remove = null;
    const index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._deferUnregister(observer);
      return true;
    }
    return false;
  }
  /**
   * Remove a callback from the Observable object
   * @param callback the callback to remove
   * @param scope optional scope. If used only the callbacks with this scope will be removed
   * @returns false if it doesn't belong to this Observable
   */
  removeCallback(callback, scope) {
    for (let index = 0; index < this._observers.length; index++) {
      const observer = this._observers[index];
      if (observer._willBeUnregistered) {
        continue;
      }
      if (observer.callback === callback && (!scope || scope === observer.scope)) {
        this._deferUnregister(observer);
        return true;
      }
    }
    return false;
  }
  /**
   * @internal
   */
  _deferUnregister(observer) {
    if (observer._willBeUnregistered) {
      return;
    }
    this._numObserversMarkedAsDeleted++;
    observer.unregisterOnNextCall = false;
    observer._willBeUnregistered = true;
    setTimeout(() => {
      this._remove(observer);
    }, 0);
  }
  // This should only be called when not iterating over _observers to avoid callback skipping.
  // Removes an observer from the _observer Array.
  _remove(observer, updateCounter = true) {
    if (!observer) {
      return false;
    }
    const index = this._observers.indexOf(observer);
    if (index !== -1) {
      if (updateCounter) {
        this._numObserversMarkedAsDeleted--;
      }
      this._observers.splice(index, 1);
      return true;
    }
    return false;
  }
  /**
   * Moves the observable to the top of the observer list making it get called first when notified
   * @param observer the observer to move
   */
  makeObserverTopPriority(observer) {
    this._remove(observer, false);
    this._observers.unshift(observer);
  }
  /**
   * Moves the observable to the bottom of the observer list making it get called last when notified
   * @param observer the observer to move
   */
  makeObserverBottomPriority(observer) {
    this._remove(observer, false);
    this._observers.push(observer);
  }
  /**
   * Notify all Observers by calling their respective callback with the given data
   * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute
   * @param eventData defines the data to send to all observers
   * @param mask defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)
   * @param target defines the original target of the state
   * @param currentTarget defines the current target of the state
   * @param userInfo defines any user info to send to observers
   * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)
   */
  notifyObservers(eventData, mask = -1, target, currentTarget, userInfo) {
    if (this.notifyIfTriggered) {
      this._hasNotified = true;
      this._lastNotifiedValue = eventData;
    }
    if (!this._observers.length) {
      return true;
    }
    const state = this._eventState;
    state.mask = mask;
    state.target = target;
    state.currentTarget = currentTarget;
    state.skipNextObservers = false;
    state.lastReturnValue = eventData;
    state.userInfo = userInfo;
    for (const obs of this._observers) {
      if (obs._willBeUnregistered) {
        continue;
      }
      if (obs.mask & mask) {
        if (obs.unregisterOnNextCall) {
          this._deferUnregister(obs);
        }
        if (obs.scope) {
          state.lastReturnValue = obs.callback.apply(obs.scope, [eventData, state]);
        } else {
          state.lastReturnValue = obs.callback(eventData, state);
        }
      }
      if (state.skipNextObservers) {
        return false;
      }
    }
    return true;
  }
  /**
   * Notify a specific observer
   * @param observer defines the observer to notify
   * @param eventData defines the data to be sent to each callback
   * @param mask is used to filter observers defaults to -1
   */
  notifyObserver(observer, eventData, mask = -1) {
    if (this.notifyIfTriggered) {
      this._hasNotified = true;
      this._lastNotifiedValue = eventData;
    }
    if (observer._willBeUnregistered) {
      return;
    }
    const state = this._eventState;
    state.mask = mask;
    state.skipNextObservers = false;
    if (observer.unregisterOnNextCall) {
      this._deferUnregister(observer);
    }
    observer.callback(eventData, state);
  }
  /**
   * Gets a boolean indicating if the observable has at least one observer
   * @returns true is the Observable has at least one Observer registered
   */
  hasObservers() {
    return this._observers.length - this._numObserversMarkedAsDeleted > 0;
  }
  /**
   * Clear the list of observers
   */
  clear() {
    while (this._observers.length) {
      const o = this._observers.pop();
      if (o) {
        o._remove = null;
      }
    }
    this._onObserverAdded = null;
    this._numObserversMarkedAsDeleted = 0;
    this.cleanLastNotifiedState();
  }
  /**
   * Clean the last notified state - both the internal last value and the has-notified flag
   */
  cleanLastNotifiedState() {
    this._hasNotified = false;
    this._lastNotifiedValue = void 0;
  }
  /**
   * Clone the current observable
   * @returns a new observable
   */
  clone() {
    const result = new _Observable();
    result._observers = this._observers.slice(0);
    return result;
  }
  /**
   * Does this observable handles observer registered with a given mask
   * @param mask defines the mask to be tested
   * @returns whether or not one observer registered with the given mask is handled
   **/
  hasSpecificMask(mask = -1) {
    for (const obs of this._observers) {
      if (obs.mask & mask || obs.mask === mask) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/@babylonjs/core/Engines/engineStore.js
var EngineStore = class {
  /**
   * Gets the latest created engine
   */
  static get LastCreatedEngine() {
    if (this.Instances.length === 0) {
      return null;
    }
    return this.Instances[this.Instances.length - 1];
  }
  /**
   * Gets the latest created scene
   */
  static get LastCreatedScene() {
    return this._LastCreatedScene;
  }
};
EngineStore.Instances = [];
EngineStore.OnEnginesDisposedObservable = new Observable();
EngineStore._LastCreatedScene = null;
EngineStore.UseFallbackTexture = true;
EngineStore.FallbackTexture = "";

// node_modules/@babylonjs/core/Misc/arrayTools.js
var ArrayTools = class _ArrayTools {
  /**
   * Returns an array of the given size filled with elements built from the given constructor and the parameters.
   * @param size the number of element to construct and put in the array.
   * @param itemBuilder a callback responsible for creating new instance of item. Called once per array entry.
   * @returns a new array filled with new objects.
   */
  static BuildArray(size, itemBuilder) {
    const a = [];
    for (let i = 0; i < size; ++i) {
      a.push(itemBuilder());
    }
    return a;
  }
  /**
   * Returns a tuple of the given size filled with elements built from the given constructor and the parameters.
   * @param size he number of element to construct and put in the tuple.
   * @param itemBuilder a callback responsible for creating new instance of item. Called once per tuple entry.
   * @returns a new tuple filled with new objects.
   */
  static BuildTuple(size, itemBuilder) {
    return _ArrayTools.BuildArray(size, itemBuilder);
  }
};
function _observeArrayfunction(object, functionName, callback) {
  const oldFunction = object[functionName];
  if (typeof oldFunction !== "function") {
    return null;
  }
  const newFunction = function() {
    const previousLength = object.length;
    const returnValue = newFunction.previous.apply(object, arguments);
    callback(functionName, previousLength);
    return returnValue;
  };
  oldFunction.next = newFunction;
  newFunction.previous = oldFunction;
  object[functionName] = newFunction;
  return () => {
    const previous = newFunction.previous;
    if (!previous) {
      return;
    }
    const next = newFunction.next;
    if (next) {
      previous.next = next;
      next.previous = previous;
    } else {
      previous.next = void 0;
      object[functionName] = previous;
    }
    newFunction.next = void 0;
    newFunction.previous = void 0;
  };
}
var observedArrayFunctions = ["push", "splice", "pop", "shift", "unshift"];
function _ObserveArray(array, callback) {
  const unObserveFunctions = observedArrayFunctions.map((name) => {
    return _observeArrayfunction(array, name, callback);
  });
  return () => {
    unObserveFunctions.forEach((unObserveFunction) => {
      unObserveFunction == null ? void 0 : unObserveFunction();
    });
  };
}

// node_modules/@babylonjs/core/Maths/math.vector.js
var _ExtractAsInt = (value) => {
  return parseInt(value.toString().replace(/\W/g, ""));
};
var Vector2 = class _Vector2 {
  /**
   * Creates a new Vector2 from the given x and y coordinates
   * @param x defines the first coordinate
   * @param y defines the second coordinate
   */
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }
  /**
   * Gets a string with the Vector2 coordinates
   * @returns a string with the Vector2 coordinates
   */
  toString() {
    return `{X: ${this.x} Y: ${this.y}}`;
  }
  /**
   * Gets class name
   * @returns the string "Vector2"
   */
  getClassName() {
    return "Vector2";
  }
  /**
   * Gets current vector hash code
   * @returns the Vector2 hash code as a number
   */
  getHashCode() {
    const x = _ExtractAsInt(this.x);
    const y = _ExtractAsInt(this.y);
    let hash = x;
    hash = hash * 397 ^ y;
    return hash;
  }
  // Operators
  /**
   * Sets the Vector2 coordinates in the given array or Float32Array from the given index.
   * Example Playground https://playground.babylonjs.com/#QYBWV4#15
   * @param array defines the source array
   * @param index defines the offset in source array
   * @returns the current Vector2
   */
  toArray(array, index = 0) {
    array[index] = this.x;
    array[index + 1] = this.y;
    return this;
  }
  /**
   * Update the current vector from an array
   * Example Playground https://playground.babylonjs.com/#QYBWV4#39
   * @param array defines the destination array
   * @param index defines the offset in the destination array
   * @returns the current Vector2
   */
  fromArray(array, index = 0) {
    _Vector2.FromArrayToRef(array, index, this);
    return this;
  }
  /**
   * Copy the current vector to an array
   * Example Playground https://playground.babylonjs.com/#QYBWV4#40
   * @returns a new array with 2 elements: the Vector2 coordinates.
   */
  asArray() {
    const result = [];
    this.toArray(result, 0);
    return result;
  }
  /**
   * Sets the Vector2 coordinates with the given Vector2 coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#24
   * @param source defines the source Vector2
   * @returns the current updated Vector2
   */
  copyFrom(source) {
    this.x = source.x;
    this.y = source.y;
    return this;
  }
  /**
   * Sets the Vector2 coordinates with the given floats
   * Example Playground https://playground.babylonjs.com/#QYBWV4#25
   * @param x defines the first coordinate
   * @param y defines the second coordinate
   * @returns the current updated Vector2
   */
  copyFromFloats(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  /**
   * Sets the Vector2 coordinates with the given floats
   * Example Playground https://playground.babylonjs.com/#QYBWV4#62
   * @param x defines the first coordinate
   * @param y defines the second coordinate
   * @returns the current updated Vector2
   */
  set(x, y) {
    return this.copyFromFloats(x, y);
  }
  /**
   * Add another vector with the current one
   * Example Playground https://playground.babylonjs.com/#QYBWV4#11
   * @param otherVector defines the other vector
   * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates
   */
  add(otherVector) {
    return new this.constructor(this.x + otherVector.x, this.y + otherVector.y);
  }
  /**
   * Sets the "result" coordinates with the addition of the current Vector2 and the given one coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#12
   * @param otherVector defines the other vector
   * @param result defines the target vector
   * @returns result input
   */
  addToRef(otherVector, result) {
    result.x = this.x + otherVector.x;
    result.y = this.y + otherVector.y;
    return result;
  }
  /**
   * Set the Vector2 coordinates by adding the given Vector2 coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#13
   * @param otherVector defines the other vector
   * @returns the current updated Vector2
   */
  addInPlace(otherVector) {
    this.x += otherVector.x;
    this.y += otherVector.y;
    return this;
  }
  /**
   * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#14
   * @param otherVector defines the other vector
   * @returns a new Vector2
   */
  addVector3(otherVector) {
    return new this.constructor(this.x + otherVector.x, this.y + otherVector.y);
  }
  /**
   * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2
   * Example Playground https://playground.babylonjs.com/#QYBWV4#61
   * @param otherVector defines the other vector
   * @returns a new Vector2
   */
  subtract(otherVector) {
    return new this.constructor(this.x - otherVector.x, this.y - otherVector.y);
  }
  /**
   * Sets the "result" coordinates with the subtraction of the given one from the current Vector2 coordinates.
   * Example Playground https://playground.babylonjs.com/#QYBWV4#63
   * @param otherVector defines the other vector
   * @param result defines the target vector
   * @returns result input
   */
  subtractToRef(otherVector, result) {
    result.x = this.x - otherVector.x;
    result.y = this.y - otherVector.y;
    return result;
  }
  /**
   * Sets the current Vector2 coordinates by subtracting from it the given one coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#88
   * @param otherVector defines the other vector
   * @returns the current updated Vector2
   */
  subtractInPlace(otherVector) {
    this.x -= otherVector.x;
    this.y -= otherVector.y;
    return this;
  }
  /**
   * Multiplies in place the current Vector2 coordinates by the given ones
   * Example Playground https://playground.babylonjs.com/#QYBWV4#43
   * @param otherVector defines the other vector
   * @returns the current updated Vector2
   */
  multiplyInPlace(otherVector) {
    this.x *= otherVector.x;
    this.y *= otherVector.y;
    return this;
  }
  /**
   * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#42
   * @param otherVector defines the other vector
   * @returns a new Vector2
   */
  multiply(otherVector) {
    return new this.constructor(this.x * otherVector.x, this.y * otherVector.y);
  }
  /**
   * Sets "result" coordinates with the multiplication of the current Vector2 and the given one coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#44
   * @param otherVector defines the other vector
   * @param result defines the target vector
   * @returns result input
   */
  multiplyToRef(otherVector, result) {
    result.x = this.x * otherVector.x;
    result.y = this.y * otherVector.y;
    return result;
  }
  /**
   * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats
   * Example Playground https://playground.babylonjs.com/#QYBWV4#89
   * @param x defines the first coordinate
   * @param y defines the second coordinate
   * @returns a new Vector2
   */
  multiplyByFloats(x, y) {
    return new this.constructor(this.x * x, this.y * y);
  }
  /**
   * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#27
   * @param otherVector defines the other vector
   * @returns a new Vector2
   */
  divide(otherVector) {
    return new this.constructor(this.x / otherVector.x, this.y / otherVector.y);
  }
  /**
   * Sets the "result" coordinates with the Vector2 divided by the given one coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#30
   * @param otherVector defines the other vector
   * @param result defines the target vector
   * @returns result input
   */
  divideToRef(otherVector, result) {
    result.x = this.x / otherVector.x;
    result.y = this.y / otherVector.y;
    return result;
  }
  /**
   * Divides the current Vector2 coordinates by the given ones
   * Example Playground https://playground.babylonjs.com/#QYBWV4#28
   * @param otherVector defines the other vector
   * @returns the current updated Vector2
   */
  divideInPlace(otherVector) {
    return this.divideToRef(otherVector, this);
  }
  /**
   * Gets a new Vector2 with current Vector2 negated coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#22
   * @returns a new Vector2
   */
  negate() {
    return new this.constructor(-this.x, -this.y);
  }
  /**
   * Negate this vector in place
   * Example Playground https://playground.babylonjs.com/#QYBWV4#23
   * @returns this
   */
  negateInPlace() {
    this.x *= -1;
    this.y *= -1;
    return this;
  }
  /**
   * Negate the current Vector2 and stores the result in the given vector "result" coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#41
   * @param result defines the Vector3 object where to store the result
   * @returns the result
   */
  negateToRef(result) {
    return result.copyFromFloats(this.x * -1, this.y * -1);
  }
  /**
   * Multiply the Vector2 coordinates by
   * Example Playground https://playground.babylonjs.com/#QYBWV4#59
   * @param scale defines the scaling factor
   * @returns the current updated Vector2
   */
  scaleInPlace(scale) {
    this.x *= scale;
    this.y *= scale;
    return this;
  }
  /**
   * Returns a new Vector2 scaled by "scale" from the current Vector2
   * Example Playground https://playground.babylonjs.com/#QYBWV4#52
   * @param scale defines the scaling factor
   * @returns a new Vector2
   */
  scale(scale) {
    const result = new this.constructor(0, 0);
    this.scaleToRef(scale, result);
    return result;
  }
  /**
   * Scale the current Vector2 values by a factor to a given Vector2
   * Example Playground https://playground.babylonjs.com/#QYBWV4#57
   * @param scale defines the scale factor
   * @param result defines the Vector2 object where to store the result
   * @returns result input
   */
  scaleToRef(scale, result) {
    result.x = this.x * scale;
    result.y = this.y * scale;
    return result;
  }
  /**
   * Scale the current Vector2 values by a factor and add the result to a given Vector2
   * Example Playground https://playground.babylonjs.com/#QYBWV4#58
   * @param scale defines the scale factor
   * @param result defines the Vector2 object where to store the result
   * @returns result input
   */
  scaleAndAddToRef(scale, result) {
    result.x += this.x * scale;
    result.y += this.y * scale;
    return result;
  }
  /**
   * Gets a boolean if two vectors are equals
   * Example Playground https://playground.babylonjs.com/#QYBWV4#31
   * @param otherVector defines the other vector
   * @returns true if the given vector coordinates strictly equal the current Vector2 ones
   */
  equals(otherVector) {
    return otherVector && this.x === otherVector.x && this.y === otherVector.y;
  }
  /**
   * Gets a boolean if two vectors are equals (using an epsilon value)
   * Example Playground https://playground.babylonjs.com/#QYBWV4#32
   * @param otherVector defines the other vector
   * @param epsilon defines the minimal distance to consider equality
   * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.
   */
  equalsWithEpsilon(otherVector, epsilon = Epsilon) {
    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);
  }
  /**
   * Gets a new Vector2 from current Vector2 floored values
   * Example Playground https://playground.babylonjs.com/#QYBWV4#35
   * eg (1.2, 2.31) returns (1, 2)
   * @returns a new Vector2
   */
  floor() {
    return new this.constructor(Math.floor(this.x), Math.floor(this.y));
  }
  /**
   * Gets a new Vector2 from current Vector2 fractional values
   * Example Playground https://playground.babylonjs.com/#QYBWV4#34
   * eg (1.2, 2.31) returns (0.2, 0.31)
   * @returns a new Vector2
   */
  fract() {
    return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
  }
  /**
   * Rotate the current vector into a given result vector
   * Example Playground https://playground.babylonjs.com/#QYBWV4#49
   * @param angle defines the rotation angle
   * @param result defines the result vector where to store the rotated vector
   * @returns result input
   */
  rotateToRef(angle, result) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const x = cos * this.x - sin * this.y;
    const y = sin * this.x + cos * this.y;
    result.x = x;
    result.y = y;
    return result;
  }
  // Properties
  /**
   * Gets the length of the vector
   * @returns the vector length (float)
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Gets the vector squared length
   * @returns the vector squared length (float)
   */
  lengthSquared() {
    return this.x * this.x + this.y * this.y;
  }
  // Methods
  /**
   * Normalize the vector
   * Example Playground https://playground.babylonjs.com/#QYBWV4#48
   * @returns the current updated Vector2
   */
  normalize() {
    return this.normalizeFromLength(this.length());
  }
  /**
   * Normalize the current Vector2 with the given input length.
   * Please note that this is an in place operation.
   * @param len the length of the vector
   * @returns the current updated Vector2
   */
  normalizeFromLength(len) {
    if (len === 0 || len === 1) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  }
  /**
   * Normalize the current Vector2 to a new vector
   * @returns the new Vector2
   */
  normalizeToNew() {
    const normalized = new this.constructor(0, 0);
    this.normalizeToRef(normalized);
    return normalized;
  }
  /**
   * Normalize the current Vector2 to the reference
   * @param reference define the Vector2 to update
   * @returns the updated Vector2
   */
  normalizeToRef(reference) {
    const len = this.length();
    if (len === 0 || len === 1) {
      return reference.copyFromFloats(this.x, this.y);
    }
    return this.scaleToRef(1 / len, reference);
  }
  /**
   * Gets a new Vector2 copied from the Vector2
   * Example Playground https://playground.babylonjs.com/#QYBWV4#20
   * @returns a new Vector2
   */
  clone() {
    return new this.constructor(this.x, this.y);
  }
  /**
   * Gets the dot product of the current vector and the vector "otherVector"
   * @param otherVector defines second vector
   * @returns the dot product (float)
   */
  dot(otherVector) {
    return this.x * otherVector.x + this.y * otherVector.y;
  }
  // Statics
  /**
   * Gets a new Vector2(0, 0)
   * @returns a new Vector2
   */
  static Zero() {
    return new _Vector2(0, 0);
  }
  /**
   * Gets a new Vector2(1, 1)
   * @returns a new Vector2
   */
  static One() {
    return new _Vector2(1, 1);
  }
  /**
   * Returns a new Vector2 with random values between min and max
   * @param min the minimum random value
   * @param max the maximum random value
   * @returns a Vector2 with random values between min and max
   */
  static Random(min = 0, max = 1) {
    return new _Vector2(Scalar.RandomRange(min, max), Scalar.RandomRange(min, max));
  }
  /**
   * Gets a zero Vector2 that must not be updated
   */
  static get ZeroReadOnly() {
    return _Vector2._ZeroReadOnly;
  }
  /**
   * Gets a new Vector2 set from the given index element of the given array
   * Example Playground https://playground.babylonjs.com/#QYBWV4#79
   * @param array defines the data source
   * @param offset defines the offset in the data source
   * @returns a new Vector2
   */
  static FromArray(array, offset = 0) {
    return new _Vector2(array[offset], array[offset + 1]);
  }
  /**
   * Sets "result" from the given index element of the given array
   * Example Playground https://playground.babylonjs.com/#QYBWV4#80
   * @param array defines the data source
   * @param offset defines the offset in the data source
   * @param result defines the target vector
   * @returns result input
   */
  static FromArrayToRef(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    return result;
  }
  /**
   * Gets a new Vector2 located for "amount" (float) on the CatmullRom spline defined by the given four Vector2
   * Example Playground https://playground.babylonjs.com/#QYBWV4#65
   * @param value1 defines 1st point of control
   * @param value2 defines 2nd point of control
   * @param value3 defines 3rd point of control
   * @param value4 defines 4th point of control
   * @param amount defines the interpolation factor
   * @returns a new Vector2
   */
  static CatmullRom(value1, value2, value3, value4, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const x = 0.5 * (2 * value2.x + (-value1.x + value3.x) * amount + (2 * value1.x - 5 * value2.x + 4 * value3.x - value4.x) * squared + (-value1.x + 3 * value2.x - 3 * value3.x + value4.x) * cubed);
    const y = 0.5 * (2 * value2.y + (-value1.y + value3.y) * amount + (2 * value1.y - 5 * value2.y + 4 * value3.y - value4.y) * squared + (-value1.y + 3 * value2.y - 3 * value3.y + value4.y) * cubed);
    return new value1.constructor(x, y);
  }
  /**
   * Returns a new Vector2 set with same the coordinates than "value" ones if the vector "value" is in the square defined by "min" and "max".
   * If a coordinate of "value" is lower than "min" coordinates, the returned Vector2 is given this "min" coordinate.
   * If a coordinate of "value" is greater than "max" coordinates, the returned Vector2 is given this "max" coordinate
   * Example Playground https://playground.babylonjs.com/#QYBWV4#76
   * @param value defines the value to clamp
   * @param min defines the lower limit
   * @param max defines the upper limit
   * @returns a new Vector2
   */
  static Clamp(value, min, max) {
    let x = value.x;
    x = x > max.x ? max.x : x;
    x = x < min.x ? min.x : x;
    let y = value.y;
    y = y > max.y ? max.y : y;
    y = y < min.y ? min.y : y;
    return new value.constructor(x, y);
  }
  /**
   * Returns a new Vector2 located for "amount" (float) on the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2"
   * Example Playground https://playground.babylonjs.com/#QYBWV4#81
   * @param value1 defines the 1st control point
   * @param tangent1 defines the outgoing tangent
   * @param value2 defines the 2nd control point
   * @param tangent2 defines the incoming tangent
   * @param amount defines the interpolation factor
   * @returns a new Vector2
   */
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    const x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;
    const y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;
    return new value1.constructor(x, y);
  }
  /**
   * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2".
   * Example Playground https://playground.babylonjs.com/#QYBWV4#82
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @returns 1st derivative
   */
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const result = new value1.constructor();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  }
  /**
   * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2".
   * Example Playground https://playground.babylonjs.com/#QYBWV4#83
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @param result define where the derivative will be stored
   * @returns result input
   */
  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
    const t2 = time * time;
    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
    return result;
  }
  /**
   * Returns a new Vector2 located for "amount" (float) on the linear interpolation between the vector "start" adn the vector "end".
   * Example Playground https://playground.babylonjs.com/#QYBWV4#84
   * @param start defines the start vector
   * @param end defines the end vector
   * @param amount defines the interpolation factor
   * @returns a new Vector2
   */
  static Lerp(start, end, amount) {
    const x = start.x + (end.x - start.x) * amount;
    const y = start.y + (end.y - start.y) * amount;
    return new start.constructor(x, y);
  }
  /**
   * Gets the dot product of the vector "left" and the vector "right"
   * Example Playground https://playground.babylonjs.com/#QYBWV4#90
   * @param left defines first vector
   * @param right defines second vector
   * @returns the dot product (float)
   */
  static Dot(left, right) {
    return left.x * right.x + left.y * right.y;
  }
  /**
   * Returns a new Vector2 equal to the normalized given vector
   * Example Playground https://playground.babylonjs.com/#QYBWV4#46
   * @param vector defines the vector to normalize
   * @returns a new Vector2
   */
  static Normalize(vector) {
    const result = new vector.constructor();
    _Vector2.NormalizeToRef(vector, result);
    return result;
  }
  /**
   * Normalize a given vector into a second one
   * Example Playground https://playground.babylonjs.com/#QYBWV4#50
   * @param vector defines the vector to normalize
   * @param result defines the vector where to store the result
   * @returns result input
   */
  static NormalizeToRef(vector, result) {
    vector.normalizeToRef(result);
    return result;
  }
  /**
   * Gets a new Vector2 set with the minimal coordinate values from the "left" and "right" vectors
   * Example Playground https://playground.babylonjs.com/#QYBWV4#86
   * @param left defines 1st vector
   * @param right defines 2nd vector
   * @returns a new Vector2
   */
  static Minimize(left, right) {
    const x = left.x < right.x ? left.x : right.x;
    const y = left.y < right.y ? left.y : right.y;
    return new left.constructor(x, y);
  }
  /**
   * Gets a new Vector2 set with the maximal coordinate values from the "left" and "right" vectors
   * Example Playground https://playground.babylonjs.com/#QYBWV4#86
   * @param left defines 1st vector
   * @param right defines 2nd vector
   * @returns a new Vector2
   */
  static Maximize(left, right) {
    const x = left.x > right.x ? left.x : right.x;
    const y = left.y > right.y ? left.y : right.y;
    return new left.constructor(x, y);
  }
  /**
   * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix
   * Example Playground https://playground.babylonjs.com/#QYBWV4#17
   * @param vector defines the vector to transform
   * @param transformation defines the matrix to apply
   * @returns a new Vector2
   */
  static Transform(vector, transformation) {
    const result = new vector.constructor();
    _Vector2.TransformToRef(vector, transformation, result);
    return result;
  }
  /**
   * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector "result" coordinates
   * Example Playground https://playground.babylonjs.com/#QYBWV4#19
   * @param vector defines the vector to transform
   * @param transformation defines the matrix to apply
   * @param result defines the target vector
   * @returns result input
   */
  static TransformToRef(vector, transformation, result) {
    const m = transformation.m;
    const x = vector.x * m[0] + vector.y * m[4] + m[12];
    const y = vector.x * m[1] + vector.y * m[5] + m[13];
    result.x = x;
    result.y = y;
    return result;
  }
  /**
   * Determines if a given vector is included in a triangle
   * Example Playground https://playground.babylonjs.com/#QYBWV4#87
   * @param p defines the vector to test
   * @param p0 defines 1st triangle point
   * @param p1 defines 2nd triangle point
   * @param p2 defines 3rd triangle point
   * @returns true if the point "p" is in the triangle defined by the vectors "p0", "p1", "p2"
   */
  static PointInTriangle(p, p0, p1, p2) {
    const a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
    const sign = a < 0 ? -1 : 1;
    const s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
    const t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;
    return s > 0 && t > 0 && s + t < 2 * a * sign;
  }
  /**
   * Gets the distance between the vectors "value1" and "value2"
   * Example Playground https://playground.babylonjs.com/#QYBWV4#71
   * @param value1 defines first vector
   * @param value2 defines second vector
   * @returns the distance between vectors
   */
  static Distance(value1, value2) {
    return Math.sqrt(_Vector2.DistanceSquared(value1, value2));
  }
  /**
   * Returns the squared distance between the vectors "value1" and "value2"
   * Example Playground https://playground.babylonjs.com/#QYBWV4#72
   * @param value1 defines first vector
   * @param value2 defines second vector
   * @returns the squared distance between vectors
   */
  static DistanceSquared(value1, value2) {
    const x = value1.x - value2.x;
    const y = value1.y - value2.y;
    return x * x + y * y;
  }
  /**
   * Gets a new Vector2 located at the center of the vectors "value1" and "value2"
   * Example Playground https://playground.babylonjs.com/#QYBWV4#86
   * Example Playground https://playground.babylonjs.com/#QYBWV4#66
   * @param value1 defines first vector
   * @param value2 defines second vector
   * @returns a new Vector2
   */
  static Center(value1, value2) {
    const result = new value1.constructor();
    return _Vector2.CenterToRef(value1, value2, result);
  }
  /**
   * Gets the center of the vectors "value1" and "value2" and stores the result in the vector "ref"
   * Example Playground https://playground.babylonjs.com/#QYBWV4#66
   * @param value1 defines first vector
   * @param value2 defines second vector
   * @param ref defines third vector
   * @returns ref
   */
  static CenterToRef(value1, value2, ref) {
    return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);
  }
  /**
   * Gets the shortest distance (float) between the point "p" and the segment defined by the two points "segA" and "segB".
   * Example Playground https://playground.babylonjs.com/#QYBWV4#77
   * @param p defines the middle point
   * @param segA defines one point of the segment
   * @param segB defines the other point of the segment
   * @returns the shortest distance
   */
  static DistanceOfPointFromSegment(p, segA, segB) {
    const l2 = _Vector2.DistanceSquared(segA, segB);
    if (l2 === 0) {
      return _Vector2.Distance(p, segA);
    }
    const v = segB.subtract(segA);
    const t = Math.max(0, Math.min(1, _Vector2.Dot(p.subtract(segA), v) / l2));
    const proj = segA.add(v.multiplyByFloats(t, t));
    return _Vector2.Distance(p, proj);
  }
};
Vector2._ZeroReadOnly = Vector2.Zero();
var Vector3 = class _Vector3 {
  /** Gets or sets the x coordinate */
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._isDirty = true;
  }
  /** Gets or sets the y coordinate */
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._isDirty = true;
  }
  /** Gets or sets the z coordinate */
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._isDirty = true;
  }
  /**
   * Creates a new Vector3 object from the given x, y, z (floats) coordinates.
   * @param x defines the first coordinates (on X axis)
   * @param y defines the second coordinates (on Y axis)
   * @param z defines the third coordinates (on Z axis)
   */
  constructor(x = 0, y = 0, z = 0) {
    this._isDirty = true;
    this._x = x;
    this._y = y;
    this._z = z;
  }
  /**
   * Creates a string representation of the Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#67
   * @returns a string with the Vector3 coordinates.
   */
  toString() {
    return `{X: ${this._x} Y: ${this._y} Z: ${this._z}}`;
  }
  /**
   * Gets the class name
   * @returns the string "Vector3"
   */
  getClassName() {
    return "Vector3";
  }
  /**
   * Creates the Vector3 hash code
   * @returns a number which tends to be unique between Vector3 instances
   */
  getHashCode() {
    const x = _ExtractAsInt(this._x);
    const y = _ExtractAsInt(this._y);
    const z = _ExtractAsInt(this._z);
    let hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    return hash;
  }
  // Operators
  /**
   * Creates an array containing three elements : the coordinates of the Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#10
   * @returns a new array of numbers
   */
  asArray() {
    const result = [];
    this.toArray(result, 0);
    return result;
  }
  /**
   * Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#65
   * @param array defines the destination array
   * @param index defines the offset in the destination array
   * @returns the current Vector3
   */
  toArray(array, index = 0) {
    array[index] = this._x;
    array[index + 1] = this._y;
    array[index + 2] = this._z;
    return this;
  }
  /**
   * Update the current vector from an array
   * Example Playground https://playground.babylonjs.com/#R1F8YU#24
   * @param array defines the destination array
   * @param index defines the offset in the destination array
   * @returns the current Vector3
   */
  fromArray(array, index = 0) {
    _Vector3.FromArrayToRef(array, index, this);
    return this;
  }
  /**
   * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#66
   * @returns a new Quaternion object, computed from the Vector3 coordinates
   */
  toQuaternion() {
    return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);
  }
  /**
   * Adds the given vector to the current Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#4
   * @param otherVector defines the second operand
   * @returns the current updated Vector3
   */
  addInPlace(otherVector) {
    return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);
  }
  /**
   * Adds the given coordinates to the current Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#5
   * @param x defines the x coordinate of the operand
   * @param y defines the y coordinate of the operand
   * @param z defines the z coordinate of the operand
   * @returns the current updated Vector3
   */
  addInPlaceFromFloats(x, y, z) {
    this._x += x;
    this._y += y;
    this._z += z;
    this._isDirty = true;
    return this;
  }
  /**
   * Gets a new Vector3, result of the addition the current Vector3 and the given vector
   * Example Playground https://playground.babylonjs.com/#R1F8YU#3
   * @param otherVector defines the second operand
   * @returns the resulting Vector3
   */
  add(otherVector) {
    return new this.constructor(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
  }
  /**
   * Adds the current Vector3 to the given one and stores the result in the vector "result"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#6
   * @param otherVector defines the second operand
   * @param result defines the Vector3 object where to store the result
   * @returns the result
   */
  addToRef(otherVector, result) {
    return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
  }
  /**
   * Subtract the given vector from the current Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#61
   * @param otherVector defines the second operand
   * @returns the current updated Vector3
   */
  subtractInPlace(otherVector) {
    this._x -= otherVector._x;
    this._y -= otherVector._y;
    this._z -= otherVector._z;
    this._isDirty = true;
    return this;
  }
  /**
   * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#60
   * @param otherVector defines the second operand
   * @returns the resulting Vector3
   */
  subtract(otherVector) {
    return new this.constructor(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);
  }
  /**
   * Subtracts the given vector from the current Vector3 and stores the result in the vector "result".
   * Example Playground https://playground.babylonjs.com/#R1F8YU#63
   * @param otherVector defines the second operand
   * @param result defines the Vector3 object where to store the result
   * @returns the result
   */
  subtractToRef(otherVector, result) {
    return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);
  }
  /**
   * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates
   * Example Playground https://playground.babylonjs.com/#R1F8YU#62
   * @param x defines the x coordinate of the operand
   * @param y defines the y coordinate of the operand
   * @param z defines the z coordinate of the operand
   * @returns the resulting Vector3
   */
  subtractFromFloats(x, y, z) {
    return new this.constructor(this._x - x, this._y - y, this._z - z);
  }
  /**
   * Subtracts the given floats from the current Vector3 coordinates and set the given vector "result" with this result
   * Example Playground https://playground.babylonjs.com/#R1F8YU#64
   * @param x defines the x coordinate of the operand
   * @param y defines the y coordinate of the operand
   * @param z defines the z coordinate of the operand
   * @param result defines the Vector3 object where to store the result
   * @returns the result
   */
  subtractFromFloatsToRef(x, y, z, result) {
    return result.copyFromFloats(this._x - x, this._y - y, this._z - z);
  }
  /**
   * Gets a new Vector3 set with the current Vector3 negated coordinates
   * Example Playground https://playground.babylonjs.com/#R1F8YU#35
   * @returns a new Vector3
   */
  negate() {
    return new this.constructor(-this._x, -this._y, -this._z);
  }
  /**
   * Negate this vector in place
   * Example Playground https://playground.babylonjs.com/#R1F8YU#36
   * @returns this
   */
  negateInPlace() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._isDirty = true;
    return this;
  }
  /**
   * Negate the current Vector3 and stores the result in the given vector "result" coordinates
   * Example Playground https://playground.babylonjs.com/#R1F8YU#37
   * @param result defines the Vector3 object where to store the result
   * @returns the result
   */
  negateToRef(result) {
    return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);
  }
  /**
   * Multiplies the Vector3 coordinates by the float "scale"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#56
   * @param scale defines the multiplier factor
   * @returns the current updated Vector3
   */
  scaleInPlace(scale) {
    this._x *= scale;
    this._y *= scale;
    this._z *= scale;
    this._isDirty = true;
    return this;
  }
  /**
   * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float "scale"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#53
   * @param scale defines the multiplier factor
   * @returns a new Vector3
   */
  scale(scale) {
    return new this.constructor(this._x * scale, this._y * scale, this._z * scale);
  }
  /**
   * Multiplies the current Vector3 coordinates by the float "scale" and stores the result in the given vector "result" coordinates
   * Example Playground https://playground.babylonjs.com/#R1F8YU#57
   * @param scale defines the multiplier factor
   * @param result defines the Vector3 object where to store the result
   * @returns the result
   */
  scaleToRef(scale, result) {
    return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);
  }
  /**
   * Creates a vector normal (perpendicular) to the current Vector3 and stores the result in the given vector
   * Out of the infinite possibilities the normal chosen is the one formed by rotating the current vector
   * 90 degrees about an axis which lies perpendicular to the current vector
   * and its projection on the xz plane. In the case of a current vector in the xz plane
   * the normal is calculated to be along the y axis.
   * Example Playground https://playground.babylonjs.com/#R1F8YU#230
   * Example Playground https://playground.babylonjs.com/#R1F8YU#231
   * @param result defines the Vector3 object where to store the resultant normal
   * @returns the result
   */
  getNormalToRef(result) {
    const radius = this.length();
    let theta = Math.acos(this.y / radius);
    const phi = Math.atan2(this.z, this.x);
    if (theta > Math.PI / 2) {
      theta -= Math.PI / 2;
    } else {
      theta += Math.PI / 2;
    }
    const x = radius * Math.sin(theta) * Math.cos(phi);
    const y = radius * Math.cos(theta);
    const z = radius * Math.sin(theta) * Math.sin(phi);
    result.set(x, y, z);
    return result;
  }
  /**
   * Rotates the vector using the given unit quaternion and stores the new vector in result
   * Example Playground https://playground.babylonjs.com/#R1F8YU#9
   * @param q the unit quaternion representing the rotation
   * @param result the output vector
   * @returns the result
   */
  applyRotationQuaternionToRef(q, result) {
    const vx = this._x, vy = this._y, vz = this._z;
    const qx = q._x, qy = q._y, qz = q._z, qw = q._w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    result._x = vx + qw * tx + qy * tz - qz * ty;
    result._y = vy + qw * ty + qz * tx - qx * tz;
    result._z = vz + qw * tz + qx * ty - qy * tx;
    result._isDirty = true;
    return result;
  }
  /**
   * Rotates the vector in place using the given unit quaternion
   * Example Playground https://playground.babylonjs.com/#R1F8YU#8
   * @param q the unit quaternion representing the rotation
   * @returns the current updated Vector3
   */
  applyRotationQuaternionInPlace(q) {
    return this.applyRotationQuaternionToRef(q, this);
  }
  /**
   * Rotates the vector using the given unit quaternion and returns the new vector
   * Example Playground https://playground.babylonjs.com/#R1F8YU#7
   * @param q the unit quaternion representing the rotation
   * @returns a new Vector3
   */
  applyRotationQuaternion(q) {
    return this.applyRotationQuaternionToRef(q, new this.constructor());
  }
  /**
   * Scale the current Vector3 values by a factor and add the result to a given Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#55
   * @param scale defines the scale factor
   * @param result defines the Vector3 object where to store the result
   * @returns result input
   */
  scaleAndAddToRef(scale, result) {
    return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);
  }
  /**
   * Projects the current point Vector3 to a plane along a ray starting from a specified origin and passing through the current point Vector3.
   * Example Playground https://playground.babylonjs.com/#R1F8YU#48
   * @param plane defines the plane to project to
   * @param origin defines the origin of the projection ray
   * @returns the projected vector3
   */
  projectOnPlane(plane, origin) {
    const result = new this.constructor();
    this.projectOnPlaneToRef(plane, origin, result);
    return result;
  }
  /**
   * Projects the current point Vector3 to a plane along a ray starting from a specified origin and passing through the current point Vector3.
   * Example Playground https://playground.babylonjs.com/#R1F8YU#49
   * @param plane defines the plane to project to
   * @param origin defines the origin of the projection ray
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  projectOnPlaneToRef(plane, origin, result) {
    const n = plane.normal;
    const d = plane.d;
    const V = MathTmp.Vector3[0];
    this.subtractToRef(origin, V);
    V.normalize();
    const denom = _Vector3.Dot(V, n);
    if (Math.abs(denom) < 1e-10) {
      result.setAll(Infinity);
    } else {
      const t = -(_Vector3.Dot(origin, n) + d) / denom;
      const scaledV = V.scaleInPlace(t);
      origin.addToRef(scaledV, result);
    }
    return result;
  }
  /**
   * Returns true if the current Vector3 and the given vector coordinates are strictly equal
   * Example Playground https://playground.babylonjs.com/#R1F8YU#19
   * @param otherVector defines the second operand
   * @returns true if both vectors are equals
   */
  equals(otherVector) {
    return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;
  }
  /**
   * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon
   * Example Playground https://playground.babylonjs.com/#R1F8YU#21
   * @param otherVector defines the second operand
   * @param epsilon defines the minimal distance to define values as equals
   * @returns true if both vectors are distant less than epsilon
   */
  equalsWithEpsilon(otherVector, epsilon = Epsilon) {
    return otherVector && Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) && Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) && Scalar.WithinEpsilon(this._z, otherVector._z, epsilon);
  }
  /**
   * Returns true if the current Vector3 coordinates equals the given floats
   * Example Playground https://playground.babylonjs.com/#R1F8YU#20
   * @param x defines the x coordinate of the operand
   * @param y defines the y coordinate of the operand
   * @param z defines the z coordinate of the operand
   * @returns true if both vectors are equal
   */
  equalsToFloats(x, y, z) {
    return this._x === x && this._y === y && this._z === z;
  }
  /**
   * Multiplies the current Vector3 coordinates by the given ones
   * Example Playground https://playground.babylonjs.com/#R1F8YU#32
   * @param otherVector defines the second operand
   * @returns the current updated Vector3
   */
  multiplyInPlace(otherVector) {
    this._x *= otherVector._x;
    this._y *= otherVector._y;
    this._z *= otherVector._z;
    this._isDirty = true;
    return this;
  }
  /**
   * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector
   * Example Playground https://playground.babylonjs.com/#R1F8YU#31
   * @param otherVector defines the second operand
   * @returns the new Vector3
   */
  multiply(otherVector) {
    return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);
  }
  /**
   * Multiplies the current Vector3 by the given one and stores the result in the given vector "result"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#33
   * @param otherVector defines the second operand
   * @param result defines the Vector3 object where to store the result
   * @returns the result
   */
  multiplyToRef(otherVector, result) {
    return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);
  }
  /**
   * Returns a new Vector3 set with the result of the multiplication of the current Vector3 coordinates by the given floats
   * Example Playground https://playground.babylonjs.com/#R1F8YU#34
   * @param x defines the x coordinate of the operand
   * @param y defines the y coordinate of the operand
   * @param z defines the z coordinate of the operand
   * @returns the new Vector3
   */
  multiplyByFloats(x, y, z) {
    return new this.constructor(this._x * x, this._y * y, this._z * z);
  }
  /**
   * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones
   * Example Playground https://playground.babylonjs.com/#R1F8YU#16
   * @param otherVector defines the second operand
   * @returns the new Vector3
   */
  divide(otherVector) {
    return new this.constructor(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
  }
  /**
   * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector "result"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#18
   * @param otherVector defines the second operand
   * @param result defines the Vector3 object where to store the result
   * @returns the result
   */
  divideToRef(otherVector, result) {
    return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
  }
  /**
   * Divides the current Vector3 coordinates by the given ones.
   * Example Playground https://playground.babylonjs.com/#R1F8YU#17
   * @param otherVector defines the second operand
   * @returns the current updated Vector3
   */
  divideInPlace(otherVector) {
    return this.divideToRef(otherVector, this);
  }
  /**
   * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones
   * Example Playground https://playground.babylonjs.com/#R1F8YU#29
   * @param other defines the second operand
   * @returns the current updated Vector3
   */
  minimizeInPlace(other) {
    return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);
  }
  /**
   * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.
   * Example Playground https://playground.babylonjs.com/#R1F8YU#27
   * @param other defines the second operand
   * @returns the current updated Vector3
   */
  maximizeInPlace(other) {
    return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);
  }
  /**
   * Updates the current Vector3 with the minimal coordinate values between its and the given coordinates
   * Example Playground https://playground.babylonjs.com/#R1F8YU#30
   * @param x defines the x coordinate of the operand
   * @param y defines the y coordinate of the operand
   * @param z defines the z coordinate of the operand
   * @returns the current updated Vector3
   */
  minimizeInPlaceFromFloats(x, y, z) {
    if (x < this._x) {
      this.x = x;
    }
    if (y < this._y) {
      this.y = y;
    }
    if (z < this._z) {
      this.z = z;
    }
    return this;
  }
  /**
   * Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.
   * Example Playground https://playground.babylonjs.com/#R1F8YU#28
   * @param x defines the x coordinate of the operand
   * @param y defines the y coordinate of the operand
   * @param z defines the z coordinate of the operand
   * @returns the current updated Vector3
   */
  maximizeInPlaceFromFloats(x, y, z) {
    if (x > this._x) {
      this.x = x;
    }
    if (y > this._y) {
      this.y = y;
    }
    if (z > this._z) {
      this.z = z;
    }
    return this;
  }
  /**
   * Due to float precision, scale of a mesh could be uniform but float values are off by a small fraction
   * Check if is non uniform within a certain amount of decimal places to account for this
   * @param epsilon the amount the values can differ
   * @returns if the vector is non uniform to a certain number of decimal places
   */
  isNonUniformWithinEpsilon(epsilon) {
    const absX = Math.abs(this._x);
    const absY = Math.abs(this._y);
    if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {
      return true;
    }
    const absZ = Math.abs(this._z);
    if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {
      return true;
    }
    if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {
      return true;
    }
    return false;
  }
  /**
   * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same
   */
  get isNonUniform() {
    const absX = Math.abs(this._x);
    const absY = Math.abs(this._y);
    if (absX !== absY) {
      return true;
    }
    const absZ = Math.abs(this._z);
    if (absX !== absZ) {
      return true;
    }
    return false;
  }
  /**
   * Gets a new Vector3 from current Vector3 floored values
   * Example Playground https://playground.babylonjs.com/#R1F8YU#22
   * @returns a new Vector3
   */
  floor() {
    return new this.constructor(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
  }
  /**
   * Gets a new Vector3 from current Vector3 fractional values
   * Example Playground https://playground.babylonjs.com/#R1F8YU#23
   * @returns a new Vector3
   */
  fract() {
    return new this.constructor(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));
  }
  // Properties
  /**
   * Gets the length of the Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#25
   * @returns the length of the Vector3
   */
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  }
  /**
   * Gets the squared length of the Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#26
   * @returns squared length of the Vector3
   */
  lengthSquared() {
    return this._x * this._x + this._y * this._y + this._z * this._z;
  }
  /**
   * Gets a boolean indicating if the vector contains a zero in one of its components
   * Example Playground https://playground.babylonjs.com/#R1F8YU#1
   */
  get hasAZeroComponent() {
    return this._x * this._y * this._z === 0;
  }
  /**
   * Normalize the current Vector3.
   * Please note that this is an in place operation.
   * Example Playground https://playground.babylonjs.com/#R1F8YU#122
   * @returns the current updated Vector3
   */
  normalize() {
    return this.normalizeFromLength(this.length());
  }
  /**
   * Reorders the x y z properties of the vector in place
   * Example Playground https://playground.babylonjs.com/#R1F8YU#44
   * @param order new ordering of the properties (eg. for vector 1,2,3 with "ZYX" will produce 3,2,1)
   * @returns the current updated vector
   */
  reorderInPlace(order) {
    order = order.toLowerCase();
    if (order === "xyz") {
      return this;
    }
    const tem = MathTmp.Vector3[0].copyFrom(this);
    this.x = tem[order[0]];
    this.y = tem[order[1]];
    this.z = tem[order[2]];
    return this;
  }
  /**
   * Rotates the vector around 0,0,0 by a quaternion
   * Example Playground https://playground.babylonjs.com/#R1F8YU#47
   * @param quaternion the rotation quaternion
   * @param result vector to store the result
   * @returns the resulting vector
   */
  rotateByQuaternionToRef(quaternion, result) {
    quaternion.toRotationMatrix(MathTmp.Matrix[0]);
    _Vector3.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);
    return result;
  }
  /**
   * Rotates a vector around a given point
   * Example Playground https://playground.babylonjs.com/#R1F8YU#46
   * @param quaternion the rotation quaternion
   * @param point the point to rotate around
   * @param result vector to store the result
   * @returns the resulting vector
   */
  rotateByQuaternionAroundPointToRef(quaternion, point, result) {
    this.subtractToRef(point, MathTmp.Vector3[0]);
    MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);
    point.addToRef(MathTmp.Vector3[0], result);
    return result;
  }
  /**
   * Returns a new Vector3 as the cross product of the current vector and the "other" one
   * The cross product is then orthogonal to both current and "other"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#14
   * @param other defines the right operand
   * @returns the cross product
   */
  cross(other) {
    const result = new this.constructor();
    return _Vector3.CrossToRef(this, other, result);
  }
  /**
   * Normalize the current Vector3 with the given input length.
   * Please note that this is an in place operation.
   * Example Playground https://playground.babylonjs.com/#R1F8YU#123
   * @param len the length of the vector
   * @returns the current updated Vector3
   */
  normalizeFromLength(len) {
    if (len === 0 || len === 1) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  }
  /**
   * Normalize the current Vector3 to a new vector
   * Example Playground https://playground.babylonjs.com/#R1F8YU#124
   * @returns the new Vector3
   */
  normalizeToNew() {
    const normalized = new this.constructor(0, 0, 0);
    this.normalizeToRef(normalized);
    return normalized;
  }
  /**
   * Normalize the current Vector3 to the reference
   * Example Playground https://playground.babylonjs.com/#R1F8YU#125
   * @param reference define the Vector3 to update
   * @returns the updated Vector3
   */
  normalizeToRef(reference) {
    const len = this.length();
    if (len === 0 || len === 1) {
      return reference.copyFromFloats(this._x, this._y, this._z);
    }
    return this.scaleToRef(1 / len, reference);
  }
  /**
   * Creates a new Vector3 copied from the current Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#11
   * @returns the new Vector3
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z);
  }
  /**
   * Copies the given vector coordinates to the current Vector3 ones
   * Example Playground https://playground.babylonjs.com/#R1F8YU#12
   * @param source defines the source Vector3
   * @returns the current updated Vector3
   */
  copyFrom(source) {
    return this.copyFromFloats(source._x, source._y, source._z);
  }
  /**
   * Copies the given floats to the current Vector3 coordinates
   * Example Playground https://playground.babylonjs.com/#R1F8YU#13
   * @param x defines the x coordinate of the operand
   * @param y defines the y coordinate of the operand
   * @param z defines the z coordinate of the operand
   * @returns the current updated Vector3
   */
  copyFromFloats(x, y, z) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._isDirty = true;
    return this;
  }
  /**
   * Copies the given floats to the current Vector3 coordinates
   * Example Playground https://playground.babylonjs.com/#R1F8YU#58
   * @param x defines the x coordinate of the operand
   * @param y defines the y coordinate of the operand
   * @param z defines the z coordinate of the operand
   * @returns the current updated Vector3
   */
  set(x, y, z) {
    return this.copyFromFloats(x, y, z);
  }
  /**
   * Copies the given float to the current Vector3 coordinates
   * Example Playground https://playground.babylonjs.com/#R1F8YU#59
   * @param v defines the x, y and z coordinates of the operand
   * @returns the current updated Vector3
   */
  setAll(v) {
    this._x = this._y = this._z = v;
    this._isDirty = true;
    return this;
  }
  // Statics
  /**
   * Get the clip factor between two vectors
   * Example Playground https://playground.babylonjs.com/#R1F8YU#126
   * @param vector0 defines the first operand
   * @param vector1 defines the second operand
   * @param axis defines the axis to use
   * @param size defines the size along the axis
   * @returns the clip factor
   */
  static GetClipFactor(vector0, vector1, axis, size) {
    const d0 = _Vector3.Dot(vector0, axis);
    const d1 = _Vector3.Dot(vector1, axis);
    return (d0 - size) / (d0 - d1);
  }
  /**
   * Get angle between two vectors
   * Example Playground https://playground.babylonjs.com/#R1F8YU#86
   * @param vector0 the starting point
   * @param vector1 the ending point
   * @param normal direction of the normal
   * @returns the angle between vector0 and vector1
   */
  static GetAngleBetweenVectors(vector0, vector1, normal) {
    const v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);
    const v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);
    let dot = _Vector3.Dot(v0, v1);
    dot = Scalar.Clamp(dot, -1, 1);
    const angle = Math.acos(dot);
    const n = MathTmp.Vector3[3];
    _Vector3.CrossToRef(v0, v1, n);
    if (_Vector3.Dot(n, normal) > 0) {
      return isNaN(angle) ? 0 : angle;
    }
    return isNaN(angle) ? -Math.PI : -Math.acos(dot);
  }
  /**
   * Get angle between two vectors projected on a plane
   * Example Playground https://playground.babylonjs.com/#R1F8YU#87
   * Expectation compute time: 0.01 ms (median) and 0.02 ms (percentile 95%)
   * @param vector0 angle between vector0 and vector1
   * @param vector1 angle between vector0 and vector1
   * @param normal Normal of the projection plane
   * @returns the angle in radians (float) between vector0 and vector1 projected on the plane with the specified normal
   */
  static GetAngleBetweenVectorsOnPlane(vector0, vector1, normal) {
    MathTmp.Vector3[0].copyFrom(vector0);
    const v0 = MathTmp.Vector3[0];
    MathTmp.Vector3[1].copyFrom(vector1);
    const v1 = MathTmp.Vector3[1];
    MathTmp.Vector3[2].copyFrom(normal);
    const vNormal = MathTmp.Vector3[2];
    const right = MathTmp.Vector3[3];
    const forward = MathTmp.Vector3[4];
    v0.normalize();
    v1.normalize();
    vNormal.normalize();
    _Vector3.CrossToRef(vNormal, v0, right);
    _Vector3.CrossToRef(right, vNormal, forward);
    const angle = Math.atan2(_Vector3.Dot(v1, right), _Vector3.Dot(v1, forward));
    return Scalar.NormalizeRadians(angle);
  }
  /**
   * Gets the rotation that aligns the roll axis (Y) to the line joining the start point to the target point and stores it in the ref Vector3
   * Example PG https://playground.babylonjs.com/#R1F8YU#189
   * @param start the starting point
   * @param target the target point
   * @param ref the vector3 to store the result
   * @returns ref in the form (pitch, yaw, 0)
   */
  static PitchYawRollToMoveBetweenPointsToRef(start, target, ref) {
    const diff = TmpVectors.Vector3[0];
    target.subtractToRef(start, diff);
    ref._y = Math.atan2(diff.x, diff.z) || 0;
    ref._x = Math.atan2(Math.sqrt(diff.x ** 2 + diff.z ** 2), diff.y) || 0;
    ref._z = 0;
    ref._isDirty = true;
    return ref;
  }
  /**
   * Gets the rotation that aligns the roll axis (Y) to the line joining the start point to the target point
   * Example PG https://playground.babylonjs.com/#R1F8YU#188
   * @param start the starting point
   * @param target the target point
   * @returns the rotation in the form (pitch, yaw, 0)
   */
  static PitchYawRollToMoveBetweenPoints(start, target) {
    const ref = _Vector3.Zero();
    return _Vector3.PitchYawRollToMoveBetweenPointsToRef(start, target, ref);
  }
  /**
   * Slerp between two vectors. See also `SmoothToRef`
   * Slerp is a spherical linear interpolation
   * giving a slow in and out effect
   * Example Playground 1 https://playground.babylonjs.com/#R1F8YU#108
   * Example Playground 2 https://playground.babylonjs.com/#R1F8YU#109
   * @param vector0 Start vector
   * @param vector1 End vector
   * @param slerp amount (will be clamped between 0 and 1)
   * @param result The slerped vector
   * @returns The slerped vector
   */
  static SlerpToRef(vector0, vector1, slerp, result) {
    slerp = Scalar.Clamp(slerp, 0, 1);
    const vector0Dir = MathTmp.Vector3[0];
    const vector1Dir = MathTmp.Vector3[1];
    vector0Dir.copyFrom(vector0);
    const vector0Length = vector0Dir.length();
    vector0Dir.normalizeFromLength(vector0Length);
    vector1Dir.copyFrom(vector1);
    const vector1Length = vector1Dir.length();
    vector1Dir.normalizeFromLength(vector1Length);
    const dot = _Vector3.Dot(vector0Dir, vector1Dir);
    let scale0;
    let scale1;
    if (dot < 1 - Epsilon) {
      const omega = Math.acos(dot);
      const invSin = 1 / Math.sin(omega);
      scale0 = Math.sin((1 - slerp) * omega) * invSin;
      scale1 = Math.sin(slerp * omega) * invSin;
    } else {
      scale0 = 1 - slerp;
      scale1 = slerp;
    }
    vector0Dir.scaleInPlace(scale0);
    vector1Dir.scaleInPlace(scale1);
    result.copyFrom(vector0Dir).addInPlace(vector1Dir);
    result.scaleInPlace(Scalar.Lerp(vector0Length, vector1Length, slerp));
    return result;
  }
  /**
   * Smooth interpolation between two vectors using Slerp
   * Example Playground https://playground.babylonjs.com/#R1F8YU#110
   * @param source source vector
   * @param goal goal vector
   * @param deltaTime current interpolation frame
   * @param lerpTime total interpolation time
   * @param result the smoothed vector
   * @returns the smoothed vector
   */
  static SmoothToRef(source, goal, deltaTime, lerpTime, result) {
    _Vector3.SlerpToRef(source, goal, lerpTime === 0 ? 1 : deltaTime / lerpTime, result);
    return result;
  }
  /**
   * Returns a new Vector3 set from the index "offset" of the given array
   * Example Playground https://playground.babylonjs.com/#R1F8YU#83
   * @param array defines the source array
   * @param offset defines the offset in the source array
   * @returns the new Vector3
   */
  static FromArray(array, offset = 0) {
    return new _Vector3(array[offset], array[offset + 1], array[offset + 2]);
  }
  /**
   * Returns a new Vector3 set from the index "offset" of the given Float32Array
   * @param array defines the source array
   * @param offset defines the offset in the source array
   * @returns the new Vector3
   * @deprecated Please use FromArray instead.
   */
  static FromFloatArray(array, offset) {
    return _Vector3.FromArray(array, offset);
  }
  /**
   * Sets the given vector "result" with the element values from the index "offset" of the given array
   * Example Playground https://playground.babylonjs.com/#R1F8YU#84
   * @param array defines the source array
   * @param offset defines the offset in the source array
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  static FromArrayToRef(array, offset, result) {
    result._x = array[offset];
    result._y = array[offset + 1];
    result._z = array[offset + 2];
    result._isDirty = true;
    return result;
  }
  /**
   * Sets the given vector "result" with the element values from the index "offset" of the given Float32Array
   * @param array defines the source array
   * @param offset defines the offset in the source array
   * @param result defines the Vector3 where to store the result
   * @deprecated Please use FromArrayToRef instead.
   * @returns result input
   */
  static FromFloatArrayToRef(array, offset, result) {
    return _Vector3.FromArrayToRef(array, offset, result);
  }
  /**
   * Sets the given vector "result" with the given floats.
   * Example Playground https://playground.babylonjs.com/#R1F8YU#85
   * @param x defines the x coordinate of the source
   * @param y defines the y coordinate of the source
   * @param z defines the z coordinate of the source
   * @param result defines the Vector3 where to store the result
   * @returns the result vector
   */
  static FromFloatsToRef(x, y, z, result) {
    result.copyFromFloats(x, y, z);
    return result;
  }
  /**
   * Returns a new Vector3 set to (0.0, 0.0, 0.0)
   * @returns a new empty Vector3
   */
  static Zero() {
    return new _Vector3(0, 0, 0);
  }
  /**
   * Returns a new Vector3 set to (1.0, 1.0, 1.0)
   * @returns a new Vector3
   */
  static One() {
    return new _Vector3(1, 1, 1);
  }
  /**
   * Returns a new Vector3 set to (0.0, 1.0, 0.0)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#71
   * @returns a new up Vector3
   */
  static Up() {
    return new _Vector3(0, 1, 0);
  }
  /**
   * Gets an up Vector3 that must not be updated
   */
  static get UpReadOnly() {
    return _Vector3._UpReadOnly;
  }
  /**
   * Gets a down Vector3 that must not be updated
   */
  static get DownReadOnly() {
    return _Vector3._DownReadOnly;
  }
  /**
   * Gets a right Vector3 that must not be updated
   */
  static get RightReadOnly() {
    return _Vector3._RightReadOnly;
  }
  /**
   * Gets a left Vector3 that must not be updated
   */
  static get LeftReadOnly() {
    return _Vector3._LeftReadOnly;
  }
  /**
   * Gets a forward Vector3 that must not be updated
   */
  static get LeftHandedForwardReadOnly() {
    return _Vector3._LeftHandedForwardReadOnly;
  }
  /**
   * Gets a forward Vector3 that must not be updated
   */
  static get RightHandedForwardReadOnly() {
    return _Vector3._RightHandedForwardReadOnly;
  }
  /**
   * Gets a backward Vector3 that must not be updated
   */
  static get LeftHandedBackwardReadOnly() {
    return _Vector3._LeftHandedBackwardReadOnly;
  }
  /**
   * Gets a backward Vector3 that must not be updated
   */
  static get RightHandedBackwardReadOnly() {
    return _Vector3._RightHandedBackwardReadOnly;
  }
  /**
   * Gets a zero Vector3 that must not be updated
   */
  static get ZeroReadOnly() {
    return _Vector3._ZeroReadOnly;
  }
  /**
   * Gets a one Vector3 that must not be updated
   */
  static get OneReadOnly() {
    return _Vector3._OneReadOnly;
  }
  /**
   * Returns a new Vector3 set to (0.0, -1.0, 0.0)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#71
   * @returns a new down Vector3
   */
  static Down() {
    return new _Vector3(0, -1, 0);
  }
  /**
   * Returns a new Vector3 set to (0.0, 0.0, 1.0)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#71
   * @param rightHandedSystem is the scene right-handed (negative z)
   * @returns a new forward Vector3
   */
  static Forward(rightHandedSystem = false) {
    return new _Vector3(0, 0, rightHandedSystem ? -1 : 1);
  }
  /**
   * Returns a new Vector3 set to (0.0, 0.0, -1.0)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#71
   * @param rightHandedSystem is the scene right-handed (negative-z)
   * @returns a new Backward Vector3
   */
  static Backward(rightHandedSystem = false) {
    return new _Vector3(0, 0, rightHandedSystem ? 1 : -1);
  }
  /**
   * Returns a new Vector3 set to (1.0, 0.0, 0.0)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#71
   * @returns a new right Vector3
   */
  static Right() {
    return new _Vector3(1, 0, 0);
  }
  /**
   * Returns a new Vector3 set to (-1.0, 0.0, 0.0)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#71
   * @returns a new left Vector3
   */
  static Left() {
    return new _Vector3(-1, 0, 0);
  }
  /**
   * Returns a new Vector3 with random values between min and max
   * @param min the minimum random value
   * @param max the maximum random value
   * @returns a Vector3 with random values between min and max
   */
  static Random(min = 0, max = 1) {
    return new _Vector3(Scalar.RandomRange(min, max), Scalar.RandomRange(min, max), Scalar.RandomRange(min, max));
  }
  /**
   * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.
   * This method computes transformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#111
   * @param vector defines the Vector3 to transform
   * @param transformation defines the transformation matrix
   * @returns the transformed Vector3
   */
  static TransformCoordinates(vector, transformation) {
    const result = _Vector3.Zero();
    _Vector3.TransformCoordinatesToRef(vector, transformation, result);
    return result;
  }
  /**
   * Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given vector
   * This method computes transformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#113
   * @param vector defines the Vector3 to transform
   * @param transformation defines the transformation matrix
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  static TransformCoordinatesToRef(vector, transformation, result) {
    _Vector3.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
    return result;
  }
  /**
   * Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)
   * This method computes transformed coordinates only, not transformed direction vectors
   * Example Playground https://playground.babylonjs.com/#R1F8YU#115
   * @param x define the x coordinate of the source vector
   * @param y define the y coordinate of the source vector
   * @param z define the z coordinate of the source vector
   * @param transformation defines the transformation matrix
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  static TransformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {
    const m = transformation.m;
    const rx = x * m[0] + y * m[4] + z * m[8] + m[12];
    const ry = x * m[1] + y * m[5] + z * m[9] + m[13];
    const rz = x * m[2] + y * m[6] + z * m[10] + m[14];
    const rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);
    result._x = rx * rw;
    result._y = ry * rw;
    result._z = rz * rw;
    result._isDirty = true;
    return result;
  }
  /**
   * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector
   * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#112
   * @param vector defines the Vector3 to transform
   * @param transformation defines the transformation matrix
   * @returns the new Vector3
   */
  static TransformNormal(vector, transformation) {
    const result = _Vector3.Zero();
    _Vector3.TransformNormalToRef(vector, transformation, result);
    return result;
  }
  /**
   * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector
   * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#114
   * @param vector defines the Vector3 to transform
   * @param transformation defines the transformation matrix
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  static TransformNormalToRef(vector, transformation, result) {
    this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
    return result;
  }
  /**
   * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z)
   * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)
   * Example Playground https://playground.babylonjs.com/#R1F8YU#116
   * @param x define the x coordinate of the source vector
   * @param y define the y coordinate of the source vector
   * @param z define the z coordinate of the source vector
   * @param transformation defines the transformation matrix
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  static TransformNormalFromFloatsToRef(x, y, z, transformation, result) {
    const m = transformation.m;
    result._x = x * m[0] + y * m[4] + z * m[8];
    result._y = x * m[1] + y * m[5] + z * m[9];
    result._z = x * m[2] + y * m[6] + z * m[10];
    result._isDirty = true;
    return result;
  }
  /**
   * Returns a new Vector3 located for "amount" on the CatmullRom interpolation spline defined by the vectors "value1", "value2", "value3", "value4"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#69
   * @param value1 defines the first control point
   * @param value2 defines the second control point
   * @param value3 defines the third control point
   * @param value4 defines the fourth control point
   * @param amount defines the amount on the spline to use
   * @returns the new Vector3
   */
  static CatmullRom(value1, value2, value3, value4, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const x = 0.5 * (2 * value2._x + (-value1._x + value3._x) * amount + (2 * value1._x - 5 * value2._x + 4 * value3._x - value4._x) * squared + (-value1._x + 3 * value2._x - 3 * value3._x + value4._x) * cubed);
    const y = 0.5 * (2 * value2._y + (-value1._y + value3._y) * amount + (2 * value1._y - 5 * value2._y + 4 * value3._y - value4._y) * squared + (-value1._y + 3 * value2._y - 3 * value3._y + value4._y) * cubed);
    const z = 0.5 * (2 * value2._z + (-value1._z + value3._z) * amount + (2 * value1._z - 5 * value2._z + 4 * value3._z - value4._z) * squared + (-value1._z + 3 * value2._z - 3 * value3._z + value4._z) * cubed);
    return new value1.constructor(x, y, z);
  }
  /**
   * Returns a new Vector3 set with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
   * If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
   * If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one
   * Example Playground https://playground.babylonjs.com/#R1F8YU#76
   * @param value defines the current value
   * @param min defines the lower range value
   * @param max defines the upper range value
   * @returns the new Vector3
   */
  static Clamp(value, min, max) {
    const result = new value.constructor();
    _Vector3.ClampToRef(value, min, max, result);
    return result;
  }
  /**
   * Sets the given vector "result" with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
   * If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
   * If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one
   * Example Playground https://playground.babylonjs.com/#R1F8YU#77
   * @param value defines the current value
   * @param min defines the lower range value
   * @param max defines the upper range value
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  static ClampToRef(value, min, max, result) {
    let x = value._x;
    x = x > max._x ? max._x : x;
    x = x < min._x ? min._x : x;
    let y = value._y;
    y = y > max._y ? max._y : y;
    y = y < min._y ? min._y : y;
    let z = value._z;
    z = z > max._z ? max._z : z;
    z = z < min._z ? min._z : z;
    result.copyFromFloats(x, y, z);
    return result;
  }
  /**
   * Checks if a given vector is inside a specific range
   * Example Playground https://playground.babylonjs.com/#R1F8YU#75
   * @param v defines the vector to test
   * @param min defines the minimum range
   * @param max defines the maximum range
   */
  static CheckExtends(v, min, max) {
    min.minimizeInPlace(v);
    max.maximizeInPlace(v);
  }
  /**
   * Returns a new Vector3 located for "amount" (float) on the Hermite interpolation spline defined by the vectors "value1", "tangent1", "value2", "tangent2"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#89
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent vector
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent vector
   * @param amount defines the amount on the interpolation spline (between 0 and 1)
   * @returns the new Vector3
   */
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    const x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
    const y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
    const z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
    return new value1.constructor(x, y, z);
  }
  /**
   * Returns a new Vector3 which is the 1st derivative of the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2".
   * Example Playground https://playground.babylonjs.com/#R1F8YU#90
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @returns 1st derivative
   */
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const result = new value1.constructor();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  }
  /**
   * Update a Vector3 with the 1st derivative of the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2".
   * Example Playground https://playground.babylonjs.com/#R1F8YU#91
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @param result define where to store the derivative
   * @returns result input
   */
  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
    const t2 = time * time;
    result._x = (t2 - time) * 6 * value1._x + (3 * t2 - 4 * time + 1) * tangent1._x + (-t2 + time) * 6 * value2._x + (3 * t2 - 2 * time) * tangent2._x;
    result._y = (t2 - time) * 6 * value1._y + (3 * t2 - 4 * time + 1) * tangent1._y + (-t2 + time) * 6 * value2._y + (3 * t2 - 2 * time) * tangent2._y;
    result._z = (t2 - time) * 6 * value1._z + (3 * t2 - 4 * time + 1) * tangent1._z + (-t2 + time) * 6 * value2._z + (3 * t2 - 2 * time) * tangent2._z;
    result._isDirty = true;
    return result;
  }
  /**
   * Returns a new Vector3 located for "amount" (float) on the linear interpolation between the vectors "start" and "end"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#95
   * @param start defines the start value
   * @param end defines the end value
   * @param amount max defines amount between both (between 0 and 1)
   * @returns the new Vector3
   */
  static Lerp(start, end, amount) {
    const result = new start.constructor(0, 0, 0);
    _Vector3.LerpToRef(start, end, amount, result);
    return result;
  }
  /**
   * Sets the given vector "result" with the result of the linear interpolation from the vector "start" for "amount" to the vector "end"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#93
   * @param start defines the start value
   * @param end defines the end value
   * @param amount max defines amount between both (between 0 and 1)
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  static LerpToRef(start, end, amount, result) {
    result._x = start._x + (end._x - start._x) * amount;
    result._y = start._y + (end._y - start._y) * amount;
    result._z = start._z + (end._z - start._z) * amount;
    result._isDirty = true;
    return result;
  }
  /**
   * Returns the dot product (float) between the vectors "left" and "right"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#82
   * @param left defines the left operand
   * @param right defines the right operand
   * @returns the dot product
   */
  static Dot(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z;
  }
  /**
   * Returns the dot product (float) between the current vectors and "otherVector"
   * @param otherVector defines the right operand
   * @returns the dot product
   */
  dot(otherVector) {
    return this._x * otherVector._x + this._y * otherVector._y + this._z * otherVector._z;
  }
  /**
   * Returns a new Vector3 as the cross product of the vectors "left" and "right"
   * The cross product is then orthogonal to both "left" and "right"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#15
   * @param left defines the left operand
   * @param right defines the right operand
   * @returns the cross product
   */
  static Cross(left, right) {
    const result = new left.constructor();
    _Vector3.CrossToRef(left, right, result);
    return result;
  }
  /**
   * Sets the given vector "result" with the cross product of "left" and "right"
   * The cross product is then orthogonal to both "left" and "right"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#78
   * @param left defines the left operand
   * @param right defines the right operand
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  static CrossToRef(left, right, result) {
    const x = left._y * right._z - left._z * right._y;
    const y = left._z * right._x - left._x * right._z;
    const z = left._x * right._y - left._y * right._x;
    result.copyFromFloats(x, y, z);
    return result;
  }
  /**
   * Returns a new Vector3 as the normalization of the given vector
   * Example Playground https://playground.babylonjs.com/#R1F8YU#98
   * @param vector defines the Vector3 to normalize
   * @returns the new Vector3
   */
  static Normalize(vector) {
    const result = _Vector3.Zero();
    _Vector3.NormalizeToRef(vector, result);
    return result;
  }
  /**
   * Sets the given vector "result" with the normalization of the given first vector
   * Example Playground https://playground.babylonjs.com/#R1F8YU#98
   * @param vector defines the Vector3 to normalize
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  static NormalizeToRef(vector, result) {
    vector.normalizeToRef(result);
    return result;
  }
  /**
   * Project a Vector3 onto screen space
   * Example Playground https://playground.babylonjs.com/#R1F8YU#101
   * @param vector defines the Vector3 to project
   * @param world defines the world matrix to use
   * @param transform defines the transform (view x projection) matrix to use
   * @param viewport defines the screen viewport to use
   * @returns the new Vector3
   */
  static Project(vector, world, transform, viewport) {
    const result = new vector.constructor();
    _Vector3.ProjectToRef(vector, world, transform, viewport, result);
    return result;
  }
  /**
   * Project a Vector3 onto screen space to reference
   * Example Playground https://playground.babylonjs.com/#R1F8YU#102
   * @param vector defines the Vector3 to project
   * @param world defines the world matrix to use
   * @param transform defines the transform (view x projection) matrix to use
   * @param viewport defines the screen viewport to use
   * @param result the vector in which the screen space will be stored
   * @returns result input
   */
  static ProjectToRef(vector, world, transform, viewport, result) {
    const cw = viewport.width;
    const ch = viewport.height;
    const cx = viewport.x;
    const cy = viewport.y;
    const viewportMatrix = MathTmp.Matrix[1];
    Matrix.FromValuesToRef(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, 0.5, 0, cx + cw / 2, ch / 2 + cy, 0.5, 1, viewportMatrix);
    const matrix = MathTmp.Matrix[0];
    world.multiplyToRef(transform, matrix);
    matrix.multiplyToRef(viewportMatrix, matrix);
    _Vector3.TransformCoordinatesToRef(vector, matrix, result);
    return result;
  }
  /**
   * Reflects a vector off the plane defined by a normalized normal
   * @param inDirection defines the vector direction
   * @param normal defines the normal - Must be normalized
   * @returns the resulting vector
   */
  static Reflect(inDirection, normal) {
    return this.ReflectToRef(inDirection, normal, new _Vector3());
  }
  /**
   * Reflects a vector off the plane defined by a normalized normal to reference
   * @param inDirection defines the vector direction
   * @param normal defines the normal - Must be normalized
   * @param ref defines the Vector3 where to store the result
   * @returns the resulting vector
   */
  static ReflectToRef(inDirection, normal, ref) {
    const tmp = TmpVectors.Vector3[0];
    tmp.copyFrom(normal).scaleInPlace(2 * _Vector3.Dot(inDirection, normal));
    return ref.copyFrom(inDirection).subtractInPlace(tmp);
  }
  /**
   * @internal
   */
  static _UnprojectFromInvertedMatrixToRef(source, matrix, result) {
    _Vector3.TransformCoordinatesToRef(source, matrix, result);
    const m = matrix.m;
    const num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];
    if (Scalar.WithinEpsilon(num, 1)) {
      result.scaleInPlace(1 / num);
    }
    return result;
  }
  /**
   * Unproject from screen space to object space
   * Example Playground https://playground.babylonjs.com/#R1F8YU#121
   * @param source defines the screen space Vector3 to use
   * @param viewportWidth defines the current width of the viewport
   * @param viewportHeight defines the current height of the viewport
   * @param world defines the world matrix to use (can be set to Identity to go to world space)
   * @param transform defines the transform (view x projection) matrix to use
   * @returns the new Vector3
   */
  static UnprojectFromTransform(source, viewportWidth, viewportHeight, world, transform) {
    return this.Unproject(source, viewportWidth, viewportHeight, world, transform, Matrix.IdentityReadOnly);
  }
  /**
   * Unproject from screen space to object space
   * Example Playground https://playground.babylonjs.com/#R1F8YU#117
   * @param source defines the screen space Vector3 to use
   * @param viewportWidth defines the current width of the viewport
   * @param viewportHeight defines the current height of the viewport
   * @param world defines the world matrix to use (can be set to Identity to go to world space)
   * @param view defines the view matrix to use
   * @param projection defines the projection matrix to use
   * @returns the new Vector3
   */
  static Unproject(source, viewportWidth, viewportHeight, world, view, projection) {
    const result = new source.constructor();
    _Vector3.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);
    return result;
  }
  /**
   * Unproject from screen space to object space
   * Example Playground https://playground.babylonjs.com/#R1F8YU#119
   * @param source defines the screen space Vector3 to use
   * @param viewportWidth defines the current width of the viewport
   * @param viewportHeight defines the current height of the viewport
   * @param world defines the world matrix to use (can be set to Identity to go to world space)
   * @param view defines the view matrix to use
   * @param projection defines the projection matrix to use
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  static UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result) {
    _Vector3.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);
    return result;
  }
  /**
   * Unproject from screen space to object space
   * Example Playground https://playground.babylonjs.com/#R1F8YU#120
   * @param sourceX defines the screen space x coordinate to use
   * @param sourceY defines the screen space y coordinate to use
   * @param sourceZ defines the screen space z coordinate to use
   * @param viewportWidth defines the current width of the viewport
   * @param viewportHeight defines the current height of the viewport
   * @param world defines the world matrix to use (can be set to Identity to go to world space)
   * @param view defines the view matrix to use
   * @param projection defines the projection matrix to use
   * @param result defines the Vector3 where to store the result
   * @returns result input
   */
  static UnprojectFloatsToRef(sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {
    var _a;
    const matrix = MathTmp.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    const screenSource = MathTmp.Vector3[0];
    screenSource.x = sourceX / viewportWidth * 2 - 1;
    screenSource.y = -(sourceY / viewportHeight * 2 - 1);
    if ((_a = EngineStore.LastCreatedEngine) == null ? void 0 : _a.isNDCHalfZRange) {
      screenSource.z = sourceZ;
    } else {
      screenSource.z = 2 * sourceZ - 1;
    }
    _Vector3._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);
    return result;
  }
  /**
   * Gets the minimal coordinate values between two Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#97
   * @param left defines the first operand
   * @param right defines the second operand
   * @returns the new Vector3
   */
  static Minimize(left, right) {
    const min = new left.constructor();
    min.copyFrom(left);
    min.minimizeInPlace(right);
    return min;
  }
  /**
   * Gets the maximal coordinate values between two Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#96
   * @param left defines the first operand
   * @param right defines the second operand
   * @returns the new Vector3
   */
  static Maximize(left, right) {
    const max = new left.constructor();
    max.copyFrom(left);
    max.maximizeInPlace(right);
    return max;
  }
  /**
   * Returns the distance between the vectors "value1" and "value2"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#81
   * @param value1 defines the first operand
   * @param value2 defines the second operand
   * @returns the distance
   */
  static Distance(value1, value2) {
    return Math.sqrt(_Vector3.DistanceSquared(value1, value2));
  }
  /**
   * Returns the squared distance between the vectors "value1" and "value2"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#80
   * @param value1 defines the first operand
   * @param value2 defines the second operand
   * @returns the squared distance
   */
  static DistanceSquared(value1, value2) {
    const x = value1._x - value2._x;
    const y = value1._y - value2._y;
    const z = value1._z - value2._z;
    return x * x + y * y + z * z;
  }
  /**
   * Projects "vector" on the triangle determined by its extremities "p0", "p1" and "p2", stores the result in "ref"
   * and returns the distance to the projected point.
   * Example Playground https://playground.babylonjs.com/#R1F8YU#104
   * From http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.4264&rep=rep1&type=pdf
   *
   * @param vector the vector to get distance from
   * @param p0 extremity of the triangle
   * @param p1 extremity of the triangle
   * @param p2 extremity of the triangle
   * @param ref variable to store the result to
   * @returns The distance between "ref" and "vector"
   */
  static ProjectOnTriangleToRef(vector, p0, p1, p2, ref) {
    const p1p0 = MathTmp.Vector3[0];
    const p2p0 = MathTmp.Vector3[1];
    const p2p1 = MathTmp.Vector3[2];
    const normal = MathTmp.Vector3[3];
    const vectorp0 = MathTmp.Vector3[4];
    p1.subtractToRef(p0, p1p0);
    p2.subtractToRef(p0, p2p0);
    p2.subtractToRef(p1, p2p1);
    const p1p0L = p1p0.length();
    const p2p0L = p2p0.length();
    const p2p1L = p2p1.length();
    if (p1p0L < Epsilon || p2p0L < Epsilon || p2p1L < Epsilon) {
      ref.copyFrom(p0);
      return _Vector3.Distance(vector, p0);
    }
    vector.subtractToRef(p0, vectorp0);
    _Vector3.CrossToRef(p1p0, p2p0, normal);
    const nl = normal.length();
    if (nl < Epsilon) {
      ref.copyFrom(p0);
      return _Vector3.Distance(vector, p0);
    }
    normal.normalizeFromLength(nl);
    let l = vectorp0.length();
    if (l < Epsilon) {
      ref.copyFrom(p0);
      return 0;
    }
    vectorp0.normalizeFromLength(l);
    const cosA = _Vector3.Dot(normal, vectorp0);
    const projVector = MathTmp.Vector3[5];
    const proj = MathTmp.Vector3[6];
    projVector.copyFrom(normal).scaleInPlace(-l * cosA);
    proj.copyFrom(vector).addInPlace(projVector);
    const v0 = MathTmp.Vector3[4];
    const v1 = MathTmp.Vector3[5];
    const v2 = MathTmp.Vector3[7];
    const tmp = MathTmp.Vector3[8];
    v0.copyFrom(p1p0).scaleInPlace(1 / p1p0L);
    tmp.copyFrom(p2p0).scaleInPlace(1 / p2p0L);
    v0.addInPlace(tmp).scaleInPlace(-1);
    v1.copyFrom(p1p0).scaleInPlace(-1 / p1p0L);
    tmp.copyFrom(p2p1).scaleInPlace(1 / p2p1L);
    v1.addInPlace(tmp).scaleInPlace(-1);
    v2.copyFrom(p2p1).scaleInPlace(-1 / p2p1L);
    tmp.copyFrom(p2p0).scaleInPlace(-1 / p2p0L);
    v2.addInPlace(tmp).scaleInPlace(-1);
    const projP = MathTmp.Vector3[9];
    let dot;
    projP.copyFrom(proj).subtractInPlace(p0);
    _Vector3.CrossToRef(v0, projP, tmp);
    dot = _Vector3.Dot(tmp, normal);
    const s0 = dot;
    projP.copyFrom(proj).subtractInPlace(p1);
    _Vector3.CrossToRef(v1, projP, tmp);
    dot = _Vector3.Dot(tmp, normal);
    const s1 = dot;
    projP.copyFrom(proj).subtractInPlace(p2);
    _Vector3.CrossToRef(v2, projP, tmp);
    dot = _Vector3.Dot(tmp, normal);
    const s2 = dot;
    const edge = MathTmp.Vector3[10];
    let e0, e1;
    if (s0 > 0 && s1 < 0) {
      edge.copyFrom(p1p0);
      e0 = p0;
      e1 = p1;
    } else if (s1 > 0 && s2 < 0) {
      edge.copyFrom(p2p1);
      e0 = p1;
      e1 = p2;
    } else {
      edge.copyFrom(p2p0).scaleInPlace(-1);
      e0 = p2;
      e1 = p0;
    }
    const tmp2 = MathTmp.Vector3[9];
    const tmp3 = MathTmp.Vector3[4];
    e0.subtractToRef(proj, tmp);
    e1.subtractToRef(proj, tmp2);
    _Vector3.CrossToRef(tmp, tmp2, tmp3);
    const isOutside = _Vector3.Dot(tmp3, normal) < 0;
    if (!isOutside) {
      ref.copyFrom(proj);
      return Math.abs(l * cosA);
    }
    const r = MathTmp.Vector3[5];
    _Vector3.CrossToRef(edge, tmp3, r);
    r.normalize();
    const e0proj = MathTmp.Vector3[9];
    e0proj.copyFrom(e0).subtractInPlace(proj);
    const e0projL = e0proj.length();
    if (e0projL < Epsilon) {
      ref.copyFrom(e0);
      return _Vector3.Distance(vector, e0);
    }
    e0proj.normalizeFromLength(e0projL);
    const cosG = _Vector3.Dot(r, e0proj);
    const triProj = MathTmp.Vector3[7];
    triProj.copyFrom(proj).addInPlace(r.scaleInPlace(e0projL * cosG));
    tmp.copyFrom(triProj).subtractInPlace(e0);
    l = edge.length();
    edge.normalizeFromLength(l);
    let t = _Vector3.Dot(tmp, edge) / Math.max(l, Epsilon);
    t = Scalar.Clamp(t, 0, 1);
    triProj.copyFrom(e0).addInPlace(edge.scaleInPlace(t * l));
    ref.copyFrom(triProj);
    return _Vector3.Distance(vector, triProj);
  }
  /**
   * Returns a new Vector3 located at the center between "value1" and "value2"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#72
   * @param value1 defines the first operand
   * @param value2 defines the second operand
   * @returns the new Vector3
   */
  static Center(value1, value2) {
    return _Vector3.CenterToRef(value1, value2, _Vector3.Zero());
  }
  /**
   * Gets the center of the vectors "value1" and "value2" and stores the result in the vector "ref"
   * Example Playground https://playground.babylonjs.com/#R1F8YU#73
   * @param value1 defines first vector
   * @param value2 defines second vector
   * @param ref defines third vector
   * @returns ref
   */
  static CenterToRef(value1, value2, ref) {
    return ref.copyFromFloats((value1._x + value2._x) / 2, (value1._y + value2._y) / 2, (value1._z + value2._z) / 2);
  }
  /**
   * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),
   * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply
   * to something in order to rotate it from its local system to the given target system
   * Note: axis1, axis2 and axis3 are normalized during this operation
   * Example Playground https://playground.babylonjs.com/#R1F8YU#106
   * @param axis1 defines the first axis
   * @param axis2 defines the second axis
   * @param axis3 defines the third axis
   * @returns a new Vector3
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/target_align
   */
  static RotationFromAxis(axis1, axis2, axis3) {
    const rotation = new axis1.constructor();
    _Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);
    return rotation;
  }
  /**
   * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3
   * Example Playground https://playground.babylonjs.com/#R1F8YU#107
   * @param axis1 defines the first axis
   * @param axis2 defines the second axis
   * @param axis3 defines the third axis
   * @param ref defines the Vector3 where to store the result
   * @returns result input
   */
  static RotationFromAxisToRef(axis1, axis2, axis3, ref) {
    const quat = MathTmp.Quaternion[0];
    Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
    quat.toEulerAnglesToRef(ref);
    return ref;
  }
};
Vector3._UpReadOnly = Vector3.Up();
Vector3._DownReadOnly = Vector3.Down();
Vector3._LeftHandedForwardReadOnly = Vector3.Forward(false);
Vector3._RightHandedForwardReadOnly = Vector3.Forward(true);
Vector3._LeftHandedBackwardReadOnly = Vector3.Backward(false);
Vector3._RightHandedBackwardReadOnly = Vector3.Backward(true);
Vector3._RightReadOnly = Vector3.Right();
Vector3._LeftReadOnly = Vector3.Left();
Vector3._ZeroReadOnly = Vector3.Zero();
Vector3._OneReadOnly = Vector3.One();
var Vector4 = class _Vector4 {
  /**
   * Creates a Vector4 object from the given floats.
   * @param x x value of the vector
   * @param y y value of the vector
   * @param z z value of the vector
   * @param w w value of the vector
   */
  constructor(x = 0, y = 0, z = 0, w = 0) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  /**
   * Returns the string with the Vector4 coordinates.
   * @returns a string containing all the vector values
   */
  toString() {
    return `{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`;
  }
  /**
   * Returns the string "Vector4".
   * @returns "Vector4"
   */
  getClassName() {
    return "Vector4";
  }
  /**
   * Returns the Vector4 hash code.
   * @returns a unique hash code
   */
  getHashCode() {
    const x = _ExtractAsInt(this.x);
    const y = _ExtractAsInt(this.y);
    const z = _ExtractAsInt(this.z);
    const w = _ExtractAsInt(this.w);
    let hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    hash = hash * 397 ^ w;
    return hash;
  }
  // Operators
  /**
   * Returns a new array populated with 4 elements : the Vector4 coordinates.
   * @returns the resulting array
   */
  asArray() {
    const result = [];
    this.toArray(result, 0);
    return result;
  }
  /**
   * Populates the given array from the given index with the Vector4 coordinates.
   * @param array array to populate
   * @param index index of the array to start at (default: 0)
   * @returns the Vector4.
   */
  toArray(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.x;
    array[index + 1] = this.y;
    array[index + 2] = this.z;
    array[index + 3] = this.w;
    return this;
  }
  /**
   * Update the current vector from an array
   * @param array defines the destination array
   * @param index defines the offset in the destination array
   * @returns the current Vector3
   */
  fromArray(array, index = 0) {
    _Vector4.FromArrayToRef(array, index, this);
    return this;
  }
  /**
   * Adds the given vector to the current Vector4.
   * @param otherVector the vector to add
   * @returns the updated Vector4.
   */
  addInPlace(otherVector) {
    this.x += otherVector.x;
    this.y += otherVector.y;
    this.z += otherVector.z;
    this.w += otherVector.w;
    return this;
  }
  /**
   * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.
   * @param otherVector the vector to add
   * @returns the resulting vector
   */
  add(otherVector) {
    return new this.constructor(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);
  }
  /**
   * Updates the given vector "result" with the result of the addition of the current Vector4 and the given one.
   * @param otherVector the vector to add
   * @param result the vector to store the result
   * @returns result input
   */
  addToRef(otherVector, result) {
    result.x = this.x + otherVector.x;
    result.y = this.y + otherVector.y;
    result.z = this.z + otherVector.z;
    result.w = this.w + otherVector.w;
    return result;
  }
  /**
   * Subtract in place the given vector from the current Vector4.
   * @param otherVector the vector to subtract
   * @returns the updated Vector4.
   */
  subtractInPlace(otherVector) {
    this.x -= otherVector.x;
    this.y -= otherVector.y;
    this.z -= otherVector.z;
    this.w -= otherVector.w;
    return this;
  }
  /**
   * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.
   * @param otherVector the vector to add
   * @returns the new vector with the result
   */
  subtract(otherVector) {
    return new this.constructor(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);
  }
  /**
   * Sets the given vector "result" with the result of the subtraction of the given vector from the current Vector4.
   * @param otherVector the vector to subtract
   * @param result the vector to store the result
   * @returns result input
   */
  subtractToRef(otherVector, result) {
    result.x = this.x - otherVector.x;
    result.y = this.y - otherVector.y;
    result.z = this.z - otherVector.z;
    result.w = this.w - otherVector.w;
    return result;
  }
  /**
   * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.
   */
  /**
   * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.
   * @param x value to subtract
   * @param y value to subtract
   * @param z value to subtract
   * @param w value to subtract
   * @returns new vector containing the result
   */
  subtractFromFloats(x, y, z, w) {
    return new this.constructor(this.x - x, this.y - y, this.z - z, this.w - w);
  }
  /**
   * Sets the given vector "result" set with the result of the subtraction of the given floats from the current Vector4 coordinates.
   * @param x value to subtract
   * @param y value to subtract
   * @param z value to subtract
   * @param w value to subtract
   * @param result the vector to store the result in
   * @returns result input
   */
  subtractFromFloatsToRef(x, y, z, w, result) {
    result.x = this.x - x;
    result.y = this.y - y;
    result.z = this.z - z;
    result.w = this.w - w;
    return result;
  }
  /**
   * Returns a new Vector4 set with the current Vector4 negated coordinates.
   * @returns a new vector with the negated values
   */
  negate() {
    return new this.constructor(-this.x, -this.y, -this.z, -this.w);
  }
  /**
   * Negate this vector in place
   * @returns this
   */
  negateInPlace() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    this.w *= -1;
    return this;
  }
  /**
   * Negate the current Vector4 and stores the result in the given vector "result" coordinates
   * @param result defines the Vector3 object where to store the result
   * @returns the result
   */
  negateToRef(result) {
    return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);
  }
  /**
   * Multiplies the current Vector4 coordinates by scale (float).
   * @param scale the number to scale with
   * @returns the updated Vector4.
   */
  scaleInPlace(scale) {
    this.x *= scale;
    this.y *= scale;
    this.z *= scale;
    this.w *= scale;
    return this;
  }
  /**
   * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).
   * @param scale the number to scale with
   * @returns a new vector with the result
   */
  scale(scale) {
    return new this.constructor(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
  }
  /**
   * Sets the given vector "result" with the current Vector4 coordinates multiplied by scale (float).
   * @param scale the number to scale with
   * @param result a vector to store the result in
   * @returns result input
   */
  scaleToRef(scale, result) {
    result.x = this.x * scale;
    result.y = this.y * scale;
    result.z = this.z * scale;
    result.w = this.w * scale;
    return result;
  }
  /**
   * Scale the current Vector4 values by a factor and add the result to a given Vector4
   * @param scale defines the scale factor
   * @param result defines the Vector4 object where to store the result
   * @returns result input
   */
  scaleAndAddToRef(scale, result) {
    result.x += this.x * scale;
    result.y += this.y * scale;
    result.z += this.z * scale;
    result.w += this.w * scale;
    return result;
  }
  /**
   * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.
   * @param otherVector the vector to compare against
   * @returns true if they are equal
   */
  equals(otherVector) {
    return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;
  }
  /**
   * Boolean : True if the current Vector4 coordinates are each beneath the distance "epsilon" from the given vector ones.
   * @param otherVector vector to compare against
   * @param epsilon (Default: very small number)
   * @returns true if they are equal
   */
  equalsWithEpsilon(otherVector, epsilon = Epsilon) {
    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) && Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) && Scalar.WithinEpsilon(this.w, otherVector.w, epsilon);
  }
  /**
   * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.
   * @param x x value to compare against
   * @param y y value to compare against
   * @param z z value to compare against
   * @param w w value to compare against
   * @returns true if equal
   */
  equalsToFloats(x, y, z, w) {
    return this.x === x && this.y === y && this.z === z && this.w === w;
  }
  /**
   * Multiplies in place the current Vector4 by the given one.
   * @param otherVector vector to multiple with
   * @returns the updated Vector4.
   */
  multiplyInPlace(otherVector) {
    this.x *= otherVector.x;
    this.y *= otherVector.y;
    this.z *= otherVector.z;
    this.w *= otherVector.w;
    return this;
  }
  /**
   * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.
   * @param otherVector vector to multiple with
   * @returns resulting new vector
   */
  multiply(otherVector) {
    return new this.constructor(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);
  }
  /**
   * Updates the given vector "result" with the multiplication result of the current Vector4 and the given one.
   * @param otherVector vector to multiple with
   * @param result vector to store the result
   * @returns result input
   */
  multiplyToRef(otherVector, result) {
    result.x = this.x * otherVector.x;
    result.y = this.y * otherVector.y;
    result.z = this.z * otherVector.z;
    result.w = this.w * otherVector.w;
    return result;
  }
  /**
   * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.
   * @param x x value multiply with
   * @param y y value multiply with
   * @param z z value multiply with
   * @param w w value multiply with
   * @returns resulting new vector
   */
  multiplyByFloats(x, y, z, w) {
    return new this.constructor(this.x * x, this.y * y, this.z * z, this.w * w);
  }
  /**
   * Returns a new Vector4 set with the division result of the current Vector4 by the given one.
   * @param otherVector vector to devide with
   * @returns resulting new vector
   */
  divide(otherVector) {
    return new this.constructor(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);
  }
  /**
   * Updates the given vector "result" with the division result of the current Vector4 by the given one.
   * @param otherVector vector to devide with
   * @param result vector to store the result
   * @returns result input
   */
  divideToRef(otherVector, result) {
    result.x = this.x / otherVector.x;
    result.y = this.y / otherVector.y;
    result.z = this.z / otherVector.z;
    result.w = this.w / otherVector.w;
    return result;
  }
  /**
   * Divides the current Vector3 coordinates by the given ones.
   * @param otherVector vector to devide with
   * @returns the updated Vector3.
   */
  divideInPlace(otherVector) {
    return this.divideToRef(otherVector, this);
  }
  /**
   * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones
   * @param other defines the second operand
   * @returns the current updated Vector4
   */
  minimizeInPlace(other) {
    if (other.x < this.x) {
      this.x = other.x;
    }
    if (other.y < this.y) {
      this.y = other.y;
    }
    if (other.z < this.z) {
      this.z = other.z;
    }
    if (other.w < this.w) {
      this.w = other.w;
    }
    return this;
  }
  /**
   * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones
   * @param other defines the second operand
   * @returns the current updated Vector4
   */
  maximizeInPlace(other) {
    if (other.x > this.x) {
      this.x = other.x;
    }
    if (other.y > this.y) {
      this.y = other.y;
    }
    if (other.z > this.z) {
      this.z = other.z;
    }
    if (other.w > this.w) {
      this.w = other.w;
    }
    return this;
  }
  /**
   * Gets a new Vector4 from current Vector4 floored values
   * @returns a new Vector4
   */
  floor() {
    return new this.constructor(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));
  }
  /**
   * Gets a new Vector4 from current Vector4 fractional values
   * @returns a new Vector4
   */
  fract() {
    return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));
  }
  // Properties
  /**
   * Returns the Vector4 length (float).
   * @returns the length
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  /**
   * Returns the Vector4 squared length (float).
   * @returns the length squared
   */
  lengthSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  // Methods
  /**
   * Normalizes in place the Vector4.
   * @returns the updated Vector4.
   */
  normalize() {
    return this.normalizeFromLength(this.length());
  }
  /**
   * Normalize the current Vector4 with the given input length.
   * Please note that this is an in place operation.
   * @param len the length of the vector
   * @returns the current updated Vector4
   */
  normalizeFromLength(len) {
    if (len === 0 || len === 1) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  }
  /**
   * Normalize the current Vector4 to a new vector
   * @returns the new Vector4
   */
  normalizeToNew() {
    const normalized = new this.constructor(0, 0, 0, 0);
    this.normalizeToRef(normalized);
    return normalized;
  }
  /**
   * Normalize the current Vector4 to the reference
   * @param reference define the Vector4 to update
   * @returns the updated Vector4
   */
  normalizeToRef(reference) {
    const len = this.length();
    if (len === 0 || len === 1) {
      return reference.copyFromFloats(this.x, this.y, this.z, this.w);
    }
    return this.scaleToRef(1 / len, reference);
  }
  /**
   * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.
   * @returns this converted to a new vector3
   */
  toVector3() {
    return new Vector3(this.x, this.y, this.z);
  }
  /**
   * Returns a new Vector4 copied from the current one.
   * @returns the new cloned vector
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  /**
   * Updates the current Vector4 with the given one coordinates.
   * @param source the source vector to copy from
   * @returns the updated Vector4.
   */
  copyFrom(source) {
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    this.w = source.w;
    return this;
  }
  /**
   * Updates the current Vector4 coordinates with the given floats.
   * @param x float to copy from
   * @param y float to copy from
   * @param z float to copy from
   * @param w float to copy from
   * @returns the updated Vector4.
   */
  copyFromFloats(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  /**
   * Updates the current Vector4 coordinates with the given floats.
   * @param x float to set from
   * @param y float to set from
   * @param z float to set from
   * @param w float to set from
   * @returns the updated Vector4.
   */
  set(x, y, z, w) {
    return this.copyFromFloats(x, y, z, w);
  }
  /**
   * Copies the given float to the current Vector3 coordinates
   * @param v defines the x, y, z and w coordinates of the operand
   * @returns the current updated Vector3
   */
  setAll(v) {
    this.x = this.y = this.z = this.w = v;
    return this;
  }
  /**
   * Returns the dot product (float) between the current vectors and "otherVector"
   * @param otherVector defines the right operand
   * @returns the dot product
   */
  dot(otherVector) {
    return this.x * otherVector.x + this.y * otherVector.y + this.z * otherVector.z + this.w * otherVector.w;
  }
  // Statics
  /**
   * Returns a new Vector4 set from the starting index of the given array.
   * @param array the array to pull values from
   * @param offset the offset into the array to start at
   * @returns the new vector
   */
  static FromArray(array, offset) {
    if (!offset) {
      offset = 0;
    }
    return new _Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  }
  /**
   * Updates the given vector "result" from the starting index of the given array.
   * @param array the array to pull values from
   * @param offset the offset into the array to start at
   * @param result the vector to store the result in
   * @returns result input
   */
  static FromArrayToRef(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
    result.w = array[offset + 3];
    return result;
  }
  /**
   * Updates the given vector "result" from the starting index of the given Float32Array.
   * @param array the array to pull values from
   * @param offset the offset into the array to start at
   * @param result the vector to store the result in
   * @returns result input
   */
  static FromFloatArrayToRef(array, offset, result) {
    _Vector4.FromArrayToRef(array, offset, result);
    return result;
  }
  /**
   * Updates the given vector "result" coordinates from the given floats.
   * @param x float to set from
   * @param y float to set from
   * @param z float to set from
   * @param w float to set from
   * @param result the vector to the floats in
   * @returns result input
   */
  static FromFloatsToRef(x, y, z, w, result) {
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
    return result;
  }
  /**
   * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)
   * @returns the new vector
   */
  static Zero() {
    return new _Vector4(0, 0, 0, 0);
  }
  /**
   * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)
   * @returns the new vector
   */
  static One() {
    return new _Vector4(1, 1, 1, 1);
  }
  /**
   * Returns a new Vector4 with random values between min and max
   * @param min the minimum random value
   * @param max the maximum random value
   * @returns a Vector4 with random values between min and max
   */
  static Random(min = 0, max = 1) {
    return new _Vector4(Scalar.RandomRange(min, max), Scalar.RandomRange(min, max), Scalar.RandomRange(min, max), Scalar.RandomRange(min, max));
  }
  /**
   * Gets a zero Vector4 that must not be updated
   */
  static get ZeroReadOnly() {
    return _Vector4._ZeroReadOnly;
  }
  /**
   * Returns a new normalized Vector4 from the given one.
   * @param vector the vector to normalize
   * @returns the vector
   */
  static Normalize(vector) {
    const result = _Vector4.Zero();
    _Vector4.NormalizeToRef(vector, result);
    return result;
  }
  /**
   * Updates the given vector "result" from the normalization of the given one.
   * @param vector the vector to normalize
   * @param result the vector to store the result in
   * @returns result input
   */
  static NormalizeToRef(vector, result) {
    vector.normalizeToRef(result);
    return result;
  }
  /**
   * Returns a vector with the minimum values from the left and right vectors
   * @param left left vector to minimize
   * @param right right vector to minimize
   * @returns a new vector with the minimum of the left and right vector values
   */
  static Minimize(left, right) {
    const min = new left.constructor();
    min.copyFrom(left);
    min.minimizeInPlace(right);
    return min;
  }
  /**
   * Returns a vector with the maximum values from the left and right vectors
   * @param left left vector to maximize
   * @param right right vector to maximize
   * @returns a new vector with the maximum of the left and right vector values
   */
  static Maximize(left, right) {
    const max = new left.constructor();
    max.copyFrom(left);
    max.maximizeInPlace(right);
    return max;
  }
  /**
   * Returns the distance (float) between the vectors "value1" and "value2".
   * @param value1 value to calulate the distance between
   * @param value2 value to calulate the distance between
   * @returns the distance between the two vectors
   */
  static Distance(value1, value2) {
    return Math.sqrt(_Vector4.DistanceSquared(value1, value2));
  }
  /**
   * Returns the squared distance (float) between the vectors "value1" and "value2".
   * @param value1 value to calulate the distance between
   * @param value2 value to calulate the distance between
   * @returns the distance between the two vectors squared
   */
  static DistanceSquared(value1, value2) {
    const x = value1.x - value2.x;
    const y = value1.y - value2.y;
    const z = value1.z - value2.z;
    const w = value1.w - value2.w;
    return x * x + y * y + z * z + w * w;
  }
  /**
   * Returns a new Vector4 located at the center between the vectors "value1" and "value2".
   * @param value1 value to calulate the center between
   * @param value2 value to calulate the center between
   * @returns the center between the two vectors
   */
  static Center(value1, value2) {
    return _Vector4.CenterToRef(value1, value2, _Vector4.Zero());
  }
  /**
   * Gets the center of the vectors "value1" and "value2" and stores the result in the vector "ref"
   * @param value1 defines first vector
   * @param value2 defines second vector
   * @param ref defines third vector
   * @returns ref
   */
  static CenterToRef(value1, value2, ref) {
    return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2, (value1.z + value2.z) / 2, (value1.w + value2.w) / 2);
  }
  /**
   * Returns a new Vector4 set with the result of the transformation by the given matrix of the given vector.
   * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
   * The difference with Vector3.TransformCoordinates is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead
   * @param vector defines the Vector3 to transform
   * @param transformation defines the transformation matrix
   * @returns the transformed Vector4
   */
  static TransformCoordinates(vector, transformation) {
    const result = _Vector4.Zero();
    _Vector4.TransformCoordinatesToRef(vector, transformation, result);
    return result;
  }
  /**
   * Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given vector
   * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)
   * The difference with Vector3.TransformCoordinatesToRef is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead
   * @param vector defines the Vector3 to transform
   * @param transformation defines the transformation matrix
   * @param result defines the Vector4 where to store the result
   * @returns result input
   */
  static TransformCoordinatesToRef(vector, transformation, result) {
    _Vector4.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
    return result;
  }
  /**
   * Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)
   * This method computes tranformed coordinates only, not transformed direction vectors
   * The difference with Vector3.TransformCoordinatesFromFloatsToRef is that the w component is not used to divide the other coordinates but is returned in the w coordinate instead
   * @param x define the x coordinate of the source vector
   * @param y define the y coordinate of the source vector
   * @param z define the z coordinate of the source vector
   * @param transformation defines the transformation matrix
   * @param result defines the Vector4 where to store the result
   * @returns result input
   */
  static TransformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {
    const m = transformation.m;
    const rx = x * m[0] + y * m[4] + z * m[8] + m[12];
    const ry = x * m[1] + y * m[5] + z * m[9] + m[13];
    const rz = x * m[2] + y * m[6] + z * m[10] + m[14];
    const rw = x * m[3] + y * m[7] + z * m[11] + m[15];
    result.x = rx;
    result.y = ry;
    result.z = rz;
    result.w = rw;
    return result;
  }
  /**
   * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.
   * This methods computes transformed normalized direction vectors only.
   * @param vector the vector to transform
   * @param transformation the transformation matrix to apply
   * @returns the new vector
   */
  static TransformNormal(vector, transformation) {
    const result = new vector.constructor();
    _Vector4.TransformNormalToRef(vector, transformation, result);
    return result;
  }
  /**
   * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector.
   * This methods computes transformed normalized direction vectors only.
   * @param vector the vector to transform
   * @param transformation the transformation matrix to apply
   * @param result the vector to store the result in
   * @returns result input
   */
  static TransformNormalToRef(vector, transformation, result) {
    const m = transformation.m;
    const x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];
    const y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];
    const z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = vector.w;
    return result;
  }
  /**
   * Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).
   * This methods computes transformed normalized direction vectors only.
   * @param x value to transform
   * @param y value to transform
   * @param z value to transform
   * @param w value to transform
   * @param transformation the transformation matrix to apply
   * @param result the vector to store the results in
   * @returns result input
   */
  static TransformNormalFromFloatsToRef(x, y, z, w, transformation, result) {
    const m = transformation.m;
    result.x = x * m[0] + y * m[4] + z * m[8];
    result.y = x * m[1] + y * m[5] + z * m[9];
    result.z = x * m[2] + y * m[6] + z * m[10];
    result.w = w;
    return result;
  }
  /**
   * Creates a new Vector4 from a Vector3
   * @param source defines the source data
   * @param w defines the 4th component (default is 0)
   * @returns a new Vector4
   */
  static FromVector3(source, w = 0) {
    return new _Vector4(source._x, source._y, source._z, w);
  }
  /**
   * Returns the dot product (float) between the vectors "left" and "right"
   * @param left defines the left operand
   * @param right defines the right operand
   * @returns the dot product
   */
  static Dot(left, right) {
    return left.dot(right);
  }
};
Vector4._ZeroReadOnly = Vector4.Zero();
var Quaternion = class _Quaternion {
  /** Gets or sets the x coordinate */
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._isDirty = true;
  }
  /** Gets or sets the y coordinate */
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._isDirty = true;
  }
  /** Gets or sets the z coordinate */
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._isDirty = true;
  }
  /** Gets or sets the w coordinate */
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._isDirty = true;
  }
  /**
   * Creates a new Quaternion from the given floats
   * @param x defines the first component (0 by default)
   * @param y defines the second component (0 by default)
   * @param z defines the third component (0 by default)
   * @param w defines the fourth component (1.0 by default)
   */
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this._isDirty = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  /**
   * Gets a string representation for the current quaternion
   * @returns a string with the Quaternion coordinates
   */
  toString() {
    return `{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`;
  }
  /**
   * Gets the class name of the quaternion
   * @returns the string "Quaternion"
   */
  getClassName() {
    return "Quaternion";
  }
  /**
   * Gets a hash code for this quaternion
   * @returns the quaternion hash code
   */
  getHashCode() {
    const x = _ExtractAsInt(this._x);
    const y = _ExtractAsInt(this._y);
    const z = _ExtractAsInt(this._z);
    const w = _ExtractAsInt(this._w);
    let hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    hash = hash * 397 ^ w;
    return hash;
  }
  /**
   * Copy the quaternion to an array
   * Example Playground https://playground.babylonjs.com/#L49EJ7#13
   * @returns a new array populated with 4 elements from the quaternion coordinates
   */
  asArray() {
    return [this._x, this._y, this._z, this._w];
  }
  /**
   * Stores from the starting index in the given array the Quaternion successive values
   * Example Playground https://playground.babylonjs.com/#L49EJ7#59
   * @param array defines the array where to store the x,y,z,w components
   * @param index defines an optional index in the target array to define where to start storing values
   * @returns the current Quaternion object
   */
  toArray(array, index = 0) {
    array[index] = this._x;
    array[index + 1] = this._y;
    array[index + 2] = this._z;
    array[index + 3] = this._w;
    return this;
  }
  /**
   * Check if two quaternions are equals
   * Example Playground https://playground.babylonjs.com/#L49EJ7#38
   * @param otherQuaternion defines the second operand
   * @returns true if the current quaternion and the given one coordinates are strictly equals
   */
  equals(otherQuaternion) {
    return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;
  }
  /**
   * Gets a boolean if two quaternions are equals (using an epsilon value)
   * Example Playground https://playground.babylonjs.com/#L49EJ7#37
   * @param otherQuaternion defines the other quaternion
   * @param epsilon defines the minimal distance to consider equality
   * @returns true if the given quaternion coordinates are close to the current ones by a distance of epsilon.
   */
  equalsWithEpsilon(otherQuaternion, epsilon = Epsilon) {
    return otherQuaternion && Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) && Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) && Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) && Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon);
  }
  /**
   * Clone the current quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#12
   * @returns a new quaternion copied from the current one
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  /**
   * Copy a quaternion to the current one
   * Example Playground https://playground.babylonjs.com/#L49EJ7#86
   * @param other defines the other quaternion
   * @returns the updated current quaternion
   */
  copyFrom(other) {
    this._x = other._x;
    this._y = other._y;
    this._z = other._z;
    this._w = other._w;
    this._isDirty = true;
    return this;
  }
  /**
   * Updates the current quaternion with the given float coordinates
   * Example Playground https://playground.babylonjs.com/#L49EJ7#87
   * @param x defines the x coordinate
   * @param y defines the y coordinate
   * @param z defines the z coordinate
   * @param w defines the w coordinate
   * @returns the updated current quaternion
   */
  copyFromFloats(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._isDirty = true;
    return this;
  }
  /**
   * Updates the current quaternion from the given float coordinates
   * Example Playground https://playground.babylonjs.com/#L49EJ7#56
   * @param x defines the x coordinate
   * @param y defines the y coordinate
   * @param z defines the z coordinate
   * @param w defines the w coordinate
   * @returns the updated current quaternion
   */
  set(x, y, z, w) {
    return this.copyFromFloats(x, y, z, w);
  }
  /**
   * Adds two quaternions
   * Example Playground https://playground.babylonjs.com/#L49EJ7#10
   * @param other defines the second operand
   * @returns a new quaternion as the addition result of the given one and the current quaternion
   */
  add(other) {
    return new this.constructor(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);
  }
  /**
   * Add a quaternion to the current one
   * Example Playground https://playground.babylonjs.com/#L49EJ7#11
   * @param other defines the quaternion to add
   * @returns the current quaternion
   */
  addInPlace(other) {
    this._x += other._x;
    this._y += other._y;
    this._z += other._z;
    this._w += other._w;
    this._isDirty = true;
    return this;
  }
  /**
   * Subtract two quaternions
   * Example Playground https://playground.babylonjs.com/#L49EJ7#57
   * @param other defines the second operand
   * @returns a new quaternion as the subtraction result of the given one from the current one
   */
  subtract(other) {
    return new this.constructor(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);
  }
  /**
   * Subtract a quaternion to the current one
   * Example Playground https://playground.babylonjs.com/#L49EJ7#58
   * @param other defines the quaternion to subtract
   * @returns the current quaternion
   */
  subtractInPlace(other) {
    this._x -= other._x;
    this._y -= other._y;
    this._z -= other._z;
    this._w -= other._w;
    this._isDirty = true;
    return this;
  }
  /**
   * Multiplies the current quaternion by a scale factor
   * Example Playground https://playground.babylonjs.com/#L49EJ7#88
   * @param value defines the scale factor
   * @returns a new quaternion set by multiplying the current quaternion coordinates by the float "scale"
   */
  scale(value) {
    return new this.constructor(this._x * value, this._y * value, this._z * value, this._w * value);
  }
  /**
   * Scale the current quaternion values by a factor and stores the result to a given quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#89
   * @param scale defines the scale factor
   * @param result defines the Quaternion object where to store the result
   * @returns result input
   */
  scaleToRef(scale, result) {
    result._x = this._x * scale;
    result._y = this._y * scale;
    result._z = this._z * scale;
    result._w = this._w * scale;
    result._isDirty = true;
    return result;
  }
  /**
   * Multiplies in place the current quaternion by a scale factor
   * Example Playground https://playground.babylonjs.com/#L49EJ7#90
   * @param value defines the scale factor
   * @returns the current modified quaternion
   */
  scaleInPlace(value) {
    this._x *= value;
    this._y *= value;
    this._z *= value;
    this._w *= value;
    this._isDirty = true;
    return this;
  }
  /**
   * Scale the current quaternion values by a factor and add the result to a given quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#91
   * @param scale defines the scale factor
   * @param result defines the Quaternion object where to store the result
   * @returns result input
   */
  scaleAndAddToRef(scale, result) {
    result._x += this._x * scale;
    result._y += this._y * scale;
    result._z += this._z * scale;
    result._w += this._w * scale;
    result._isDirty = true;
    return result;
  }
  /**
   * Multiplies two quaternions
   * Example Playground https://playground.babylonjs.com/#L49EJ7#43
   * @param q1 defines the second operand
   * @returns a new quaternion set as the multiplication result of the current one with the given one "q1"
   */
  multiply(q1) {
    const result = new this.constructor(0, 0, 0, 1);
    this.multiplyToRef(q1, result);
    return result;
  }
  /**
   * Sets the given "result" as the multiplication result of the current one with the given one "q1"
   * Example Playground https://playground.babylonjs.com/#L49EJ7#45
   * @param q1 defines the second operand
   * @param result defines the target quaternion
   * @returns the current quaternion
   */
  multiplyToRef(q1, result) {
    const x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;
    const y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;
    const z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;
    const w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;
    result.copyFromFloats(x, y, z, w);
    return result;
  }
  /**
   * Updates the current quaternion with the multiplication of itself with the given one "q1"
   * Example Playground https://playground.babylonjs.com/#L49EJ7#46
   * @param q1 defines the second operand
   * @returns the currentupdated quaternion
   */
  multiplyInPlace(q1) {
    this.multiplyToRef(q1, this);
    return this;
  }
  /**
   * Conjugates the current quaternion and stores the result in the given quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#81
   * @param ref defines the target quaternion
   * @returns result input
   */
  conjugateToRef(ref) {
    ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);
    return ref;
  }
  /**
   * Conjugates in place the current quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#82
   * @returns the current updated quaternion
   */
  conjugateInPlace() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._isDirty = true;
    return this;
  }
  /**
   * Conjugates (1-q) the current quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#83
   * @returns a new quaternion
   */
  conjugate() {
    return new this.constructor(-this._x, -this._y, -this._z, this._w);
  }
  /**
   * Returns the inverse of the current quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#84
   * @returns a new quaternion
   */
  invert() {
    const conjugate = this.conjugate();
    const lengthSquared = this.lengthSquared();
    if (lengthSquared == 0 || lengthSquared == 1) {
      return conjugate;
    }
    conjugate.scaleInPlace(1 / lengthSquared);
    return conjugate;
  }
  /**
   * Invert in place the current quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#85
   * @returns this quaternion
   */
  invertInPlace() {
    this.conjugateInPlace();
    const lengthSquared = this.lengthSquared();
    if (lengthSquared == 0 || lengthSquared == 1) {
      return this;
    }
    this.scaleInPlace(1 / lengthSquared);
    return this;
  }
  /**
   * Gets squared length of current quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#29
   * @returns the quaternion length (float)
   */
  lengthSquared() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  /**
   * Gets length of current quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#28
   * @returns the quaternion length (float)
   */
  length() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Normalize in place the current quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#54
   * @returns the current updated quaternion
   */
  normalize() {
    return this.normalizeFromLength(this.length());
  }
  /**
   * Normalize the current quaternion with the given input length.
   * Please note that this is an in place operation.
   * @param len the length of the quaternion
   * @returns the current updated Quaternion
   */
  normalizeFromLength(len) {
    if (len === 0 || len === 1) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  }
  /**
   * Normalize a copy of the current quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#55
   * @returns the normalized quaternion
   */
  normalizeToNew() {
    const normalized = new this.constructor(0, 0, 0, 1);
    this.normalizeToRef(normalized);
    return normalized;
  }
  /**
   * Normalize the current Quaternion to the reference
   * @param reference define the Quaternion to update
   * @returns the updated Quaternion
   */
  normalizeToRef(reference) {
    const len = this.length();
    if (len === 0 || len === 1) {
      return reference.copyFromFloats(this._x, this._y, this._z, this._w);
    }
    return this.scaleToRef(1 / len, reference);
  }
  /**
   * Returns a new Vector3 set with the Euler angles translated from the current quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#32
   * @returns a new Vector3 containing the Euler angles
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/rotation_conventions
   */
  toEulerAngles() {
    const result = Vector3.Zero();
    this.toEulerAnglesToRef(result);
    return result;
  }
  /**
   * Sets the given vector3 "result" with the Euler angles translated from the current quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#31
   * @param result defines the vector which will be filled with the Euler angles
   * @returns result input
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/center_origin/rotation_conventions
   */
  toEulerAnglesToRef(result) {
    const qz = this._z;
    const qx = this._x;
    const qy = this._y;
    const qw = this._w;
    const zAxisY = qy * qz - qx * qw;
    const limit = 0.4999999;
    if (zAxisY < -limit) {
      result._y = 2 * Math.atan2(qy, qw);
      result._x = Math.PI / 2;
      result._z = 0;
      result._isDirty = true;
    } else if (zAxisY > limit) {
      result._y = 2 * Math.atan2(qy, qw);
      result._x = -Math.PI / 2;
      result._z = 0;
      result._isDirty = true;
    } else {
      const sqw = qw * qw;
      const sqz = qz * qz;
      const sqx = qx * qx;
      const sqy = qy * qy;
      result._z = Math.atan2(2 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);
      result._x = Math.asin(-2 * zAxisY);
      result._y = Math.atan2(2 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);
      result._isDirty = true;
    }
    return result;
  }
  /**
   * Updates the given rotation matrix with the current quaternion values
   * Example Playground https://playground.babylonjs.com/#L49EJ7#67
   * @param result defines the target matrix
   * @returns the updated matrix with the rotation
   */
  toRotationMatrix(result) {
    Matrix.FromQuaternionToRef(this, result);
    return result;
  }
  /**
   * Updates the current quaternion from the given rotation matrix values
   * Example Playground https://playground.babylonjs.com/#L49EJ7#41
   * @param matrix defines the source matrix
   * @returns the current updated quaternion
   */
  fromRotationMatrix(matrix) {
    _Quaternion.FromRotationMatrixToRef(matrix, this);
    return this;
  }
  /**
   * Returns the dot product (float) between the current quaternions and "other"
   * @param other defines the right operand
   * @returns the dot product
   */
  dot(other) {
    return this._x * other._x + this._y * other._y + this._z * other._z + this._w * other._w;
  }
  // Statics
  /**
   * Creates a new quaternion from a rotation matrix
   * Example Playground https://playground.babylonjs.com/#L49EJ7#101
   * @param matrix defines the source matrix
   * @returns a new quaternion created from the given rotation matrix values
   */
  static FromRotationMatrix(matrix) {
    const result = new _Quaternion();
    _Quaternion.FromRotationMatrixToRef(matrix, result);
    return result;
  }
  /**
   * Updates the given quaternion with the given rotation matrix values
   * Example Playground https://playground.babylonjs.com/#L49EJ7#102
   * @param matrix defines the source matrix
   * @param result defines the target quaternion
   * @returns result input
   */
  static FromRotationMatrixToRef(matrix, result) {
    const data = matrix.m;
    const m11 = data[0], m12 = data[4], m13 = data[8];
    const m21 = data[1], m22 = data[5], m23 = data[9];
    const m31 = data[2], m32 = data[6], m33 = data[10];
    const trace = m11 + m22 + m33;
    let s;
    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1);
      result._w = 0.25 / s;
      result._x = (m32 - m23) * s;
      result._y = (m13 - m31) * s;
      result._z = (m21 - m12) * s;
      result._isDirty = true;
    } else if (m11 > m22 && m11 > m33) {
      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      result._w = (m32 - m23) / s;
      result._x = 0.25 * s;
      result._y = (m12 + m21) / s;
      result._z = (m13 + m31) / s;
      result._isDirty = true;
    } else if (m22 > m33) {
      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      result._w = (m13 - m31) / s;
      result._x = (m12 + m21) / s;
      result._y = 0.25 * s;
      result._z = (m23 + m32) / s;
      result._isDirty = true;
    } else {
      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      result._w = (m21 - m12) / s;
      result._x = (m13 + m31) / s;
      result._y = (m23 + m32) / s;
      result._z = 0.25 * s;
      result._isDirty = true;
    }
    return result;
  }
  /**
   * Returns the dot product (float) between the quaternions "left" and "right"
   * Example Playground https://playground.babylonjs.com/#L49EJ7#61
   * @param left defines the left operand
   * @param right defines the right operand
   * @returns the dot product
   */
  static Dot(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
  }
  /**
   * Checks if the orientations of two rotation quaternions are close to each other
   * Example Playground https://playground.babylonjs.com/#L49EJ7#60
   * @param quat0 defines the first quaternion to check
   * @param quat1 defines the second quaternion to check
   * @param epsilon defines closeness, 0 same orientation, 1 PI apart, default 0.1
   * @returns true if the two quaternions are close to each other within epsilon
   */
  static AreClose(quat0, quat1, epsilon = 0.1) {
    const dot = _Quaternion.Dot(quat0, quat1);
    return 1 - dot * dot <= epsilon;
  }
  /**
   * Smooth interpolation between two quaternions using Slerp
   * Example Playground https://playground.babylonjs.com/#L49EJ7#93
   * @param source source quaternion
   * @param goal goal quaternion
   * @param deltaTime current interpolation frame
   * @param lerpTime total interpolation time
   * @param result the smoothed quaternion
   * @returns the smoothed quaternion
   */
  static SmoothToRef(source, goal, deltaTime, lerpTime, result) {
    let slerp = lerpTime === 0 ? 1 : deltaTime / lerpTime;
    slerp = Scalar.Clamp(slerp, 0, 1);
    _Quaternion.SlerpToRef(source, goal, slerp, result);
    return result;
  }
  /**
   * Creates an empty quaternion
   * @returns a new quaternion set to (0.0, 0.0, 0.0)
   */
  static Zero() {
    return new _Quaternion(0, 0, 0, 0);
  }
  /**
   * Inverse a given quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#103
   * @param q defines the source quaternion
   * @returns a new quaternion as the inverted current quaternion
   */
  static Inverse(q) {
    return new q.constructor(-q._x, -q._y, -q._z, q._w);
  }
  /**
   * Inverse a given quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#104
   * @param q defines the source quaternion
   * @param result the quaternion the result will be stored in
   * @returns the result quaternion
   */
  static InverseToRef(q, result) {
    result.set(-q._x, -q._y, -q._z, q._w);
    return result;
  }
  /**
   * Creates an identity quaternion
   * @returns the identity quaternion
   */
  static Identity() {
    return new _Quaternion(0, 0, 0, 1);
  }
  /**
   * Gets a boolean indicating if the given quaternion is identity
   * @param quaternion defines the quaternion to check
   * @returns true if the quaternion is identity
   */
  static IsIdentity(quaternion) {
    return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;
  }
  /**
   * Creates a quaternion from a rotation around an axis
   * Example Playground https://playground.babylonjs.com/#L49EJ7#72
   * @param axis defines the axis to use
   * @param angle defines the angle to use
   * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)
   */
  static RotationAxis(axis, angle) {
    return _Quaternion.RotationAxisToRef(axis, angle, new _Quaternion());
  }
  /**
   * Creates a rotation around an axis and stores it into the given quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#73
   * @param axis defines the axis to use
   * @param angle defines the angle to use
   * @param result defines the target quaternion
   * @returns the target quaternion
   */
  static RotationAxisToRef(axis, angle, result) {
    const sin = Math.sin(angle / 2);
    axis.normalize();
    result._w = Math.cos(angle / 2);
    result._x = axis._x * sin;
    result._y = axis._y * sin;
    result._z = axis._z * sin;
    result._isDirty = true;
    return result;
  }
  /**
   * Creates a new quaternion from data stored into an array
   * Example Playground https://playground.babylonjs.com/#L49EJ7#63
   * @param array defines the data source
   * @param offset defines the offset in the source array where the data starts
   * @returns a new quaternion
   */
  static FromArray(array, offset) {
    if (!offset) {
      offset = 0;
    }
    return new _Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  }
  /**
   * Updates the given quaternion "result" from the starting index of the given array.
   * Example Playground https://playground.babylonjs.com/#L49EJ7#64
   * @param array the array to pull values from
   * @param offset the offset into the array to start at
   * @param result the quaternion to store the result in
   * @returns result input
   */
  static FromArrayToRef(array, offset, result) {
    result._x = array[offset];
    result._y = array[offset + 1];
    result._z = array[offset + 2];
    result._w = array[offset + 3];
    result._isDirty = true;
    return result;
  }
  /**
   * Create a quaternion from Euler rotation angles
   * Example Playground https://playground.babylonjs.com/#L49EJ7#33
   * @param x Pitch
   * @param y Yaw
   * @param z Roll
   * @returns the new Quaternion
   */
  static FromEulerAngles(x, y, z) {
    const q = new _Quaternion();
    _Quaternion.RotationYawPitchRollToRef(y, x, z, q);
    return q;
  }
  /**
   * Updates a quaternion from Euler rotation angles
   * Example Playground https://playground.babylonjs.com/#L49EJ7#34
   * @param x Pitch
   * @param y Yaw
   * @param z Roll
   * @param result the quaternion to store the result
   * @returns the updated quaternion
   */
  static FromEulerAnglesToRef(x, y, z, result) {
    _Quaternion.RotationYawPitchRollToRef(y, x, z, result);
    return result;
  }
  /**
   * Create a quaternion from Euler rotation vector
   * Example Playground https://playground.babylonjs.com/#L49EJ7#35
   * @param vec the Euler vector (x Pitch, y Yaw, z Roll)
   * @returns the new Quaternion
   */
  static FromEulerVector(vec) {
    const q = new _Quaternion();
    _Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);
    return q;
  }
  /**
   * Updates a quaternion from Euler rotation vector
   * Example Playground https://playground.babylonjs.com/#L49EJ7#36
   * @param vec the Euler vector (x Pitch, y Yaw, z Roll)
   * @param result the quaternion to store the result
   * @returns the updated quaternion
   */
  static FromEulerVectorToRef(vec, result) {
    _Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);
    return result;
  }
  /**
   * Updates a quaternion so that it rotates vector vecFrom to vector vecTo
   * Example Playground - https://playground.babylonjs.com/#L49EJ7#70
   * @param vecFrom defines the direction vector from which to rotate
   * @param vecTo defines the direction vector to which to rotate
   * @param result the quaternion to store the result
   * @param epsilon defines the minimal dot value to define vecs as opposite. Default: `BABYLON.Epsilon`
   * @returns the updated quaternion
   */
  static FromUnitVectorsToRef(vecFrom, vecTo, result, epsilon = Epsilon) {
    const r = Vector3.Dot(vecFrom, vecTo) + 1;
    if (r < epsilon) {
      if (Math.abs(vecFrom.x) > Math.abs(vecFrom.z)) {
        result.set(-vecFrom.y, vecFrom.x, 0, 0);
      } else {
        result.set(0, -vecFrom.z, vecFrom.y, 0);
      }
    } else {
      Vector3.CrossToRef(vecFrom, vecTo, TmpVectors.Vector3[0]);
      result.set(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z, r);
    }
    return result.normalize();
  }
  /**
   * Creates a new quaternion from the given Euler float angles (y, x, z)
   * Example Playground https://playground.babylonjs.com/#L49EJ7#77
   * @param yaw defines the rotation around Y axis
   * @param pitch defines the rotation around X axis
   * @param roll defines the rotation around Z axis
   * @returns the new quaternion
   */
  static RotationYawPitchRoll(yaw, pitch, roll) {
    const q = new _Quaternion();
    _Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);
    return q;
  }
  /**
   * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#78
   * @param yaw defines the rotation around Y axis
   * @param pitch defines the rotation around X axis
   * @param roll defines the rotation around Z axis
   * @param result defines the target quaternion
   * @returns result input
   */
  static RotationYawPitchRollToRef(yaw, pitch, roll, result) {
    const halfRoll = roll * 0.5;
    const halfPitch = pitch * 0.5;
    const halfYaw = yaw * 0.5;
    const sinRoll = Math.sin(halfRoll);
    const cosRoll = Math.cos(halfRoll);
    const sinPitch = Math.sin(halfPitch);
    const cosPitch = Math.cos(halfPitch);
    const sinYaw = Math.sin(halfYaw);
    const cosYaw = Math.cos(halfYaw);
    result._x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
    result._y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
    result._z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
    result._w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
    result._isDirty = true;
    return result;
  }
  /**
   * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation
   * Example Playground https://playground.babylonjs.com/#L49EJ7#68
   * @param alpha defines the rotation around first axis
   * @param beta defines the rotation around second axis
   * @param gamma defines the rotation around third axis
   * @returns the new quaternion
   */
  static RotationAlphaBetaGamma(alpha, beta, gamma) {
    const result = new _Quaternion();
    _Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);
    return result;
  }
  /**
   * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#69
   * @param alpha defines the rotation around first axis
   * @param beta defines the rotation around second axis
   * @param gamma defines the rotation around third axis
   * @param result defines the target quaternion
   * @returns result input
   */
  static RotationAlphaBetaGammaToRef(alpha, beta, gamma, result) {
    const halfGammaPlusAlpha = (gamma + alpha) * 0.5;
    const halfGammaMinusAlpha = (gamma - alpha) * 0.5;
    const halfBeta = beta * 0.5;
    result._x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);
    result._y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);
    result._z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);
    result._w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);
    result._isDirty = true;
    return result;
  }
  /**
   * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)
   * Example Playground https://playground.babylonjs.com/#L49EJ7#75
   * @param axis1 defines the first axis
   * @param axis2 defines the second axis
   * @param axis3 defines the third axis
   * @returns the new quaternion
   */
  static RotationQuaternionFromAxis(axis1, axis2, axis3) {
    const quat = new _Quaternion(0, 0, 0, 0);
    _Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
    return quat;
  }
  /**
   * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#76
   * @param axis1 defines the first axis
   * @param axis2 defines the second axis
   * @param axis3 defines the third axis
   * @param ref defines the target quaternion
   * @returns result input
   */
  static RotationQuaternionFromAxisToRef(axis1, axis2, axis3, ref) {
    const rotMat = MathTmp.Matrix[0];
    Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);
    _Quaternion.FromRotationMatrixToRef(rotMat, ref);
    return ref;
  }
  /**
   * Creates a new rotation value to orient an object to look towards the given forward direction, the up direction being oriented like "up".
   * This function works in left handed mode
   * Example Playground https://playground.babylonjs.com/#L49EJ7#96
   * @param forward defines the forward direction - Must be normalized and orthogonal to up.
   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.
   * @returns A new quaternion oriented toward the specified forward and up.
   */
  static FromLookDirectionLH(forward, up) {
    const quat = new _Quaternion();
    _Quaternion.FromLookDirectionLHToRef(forward, up, quat);
    return quat;
  }
  /**
   * Creates a new rotation value to orient an object to look towards the given forward direction with the up direction being oriented like "up", and stores it in the target quaternion.
   * This function works in left handed mode
   * Example Playground https://playground.babylonjs.com/#L49EJ7#97
   * @param forward defines the forward direction - Must be normalized and orthogonal to up.
   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.
   * @param ref defines the target quaternion.
   * @returns result input
   */
  static FromLookDirectionLHToRef(forward, up, ref) {
    const rotMat = MathTmp.Matrix[0];
    Matrix.LookDirectionLHToRef(forward, up, rotMat);
    _Quaternion.FromRotationMatrixToRef(rotMat, ref);
    return ref;
  }
  /**
   * Creates a new rotation value to orient an object to look towards the given forward direction, the up direction being oriented like "up".
   * This function works in right handed mode
   * Example Playground https://playground.babylonjs.com/#L49EJ7#98
   * @param forward defines the forward direction - Must be normalized and orthogonal to up.
   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.
   * @returns A new quaternion oriented toward the specified forward and up.
   */
  static FromLookDirectionRH(forward, up) {
    const quat = new _Quaternion();
    _Quaternion.FromLookDirectionRHToRef(forward, up, quat);
    return quat;
  }
  /**
   * Creates a new rotation value to orient an object to look towards the given forward direction with the up direction being oriented like "up", and stores it in the target quaternion.
   * This function works in right handed mode
   * Example Playground https://playground.babylonjs.com/#L49EJ7#105
   * @param forward defines the forward direction - Must be normalized and orthogonal to up.
   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.
   * @param ref defines the target quaternion.
   * @returns result input
   */
  static FromLookDirectionRHToRef(forward, up, ref) {
    const rotMat = MathTmp.Matrix[0];
    Matrix.LookDirectionRHToRef(forward, up, rotMat);
    return _Quaternion.FromRotationMatrixToRef(rotMat, ref);
  }
  /**
   * Interpolates between two quaternions
   * Example Playground https://playground.babylonjs.com/#L49EJ7#79
   * @param left defines first quaternion
   * @param right defines second quaternion
   * @param amount defines the gradient to use
   * @returns the new interpolated quaternion
   */
  static Slerp(left, right, amount) {
    const result = _Quaternion.Identity();
    _Quaternion.SlerpToRef(left, right, amount, result);
    return result;
  }
  /**
   * Interpolates between two quaternions and stores it into a target quaternion
   * Example Playground https://playground.babylonjs.com/#L49EJ7#92
   * @param left defines first quaternion
   * @param right defines second quaternion
   * @param amount defines the gradient to use
   * @param result defines the target quaternion
   * @returns result input
   */
  static SlerpToRef(left, right, amount, result) {
    let num2;
    let num3;
    let num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    let flag = false;
    if (num4 < 0) {
      flag = true;
      num4 = -num4;
    }
    if (num4 > 0.999999) {
      num3 = 1 - amount;
      num2 = flag ? -amount : amount;
    } else {
      const num5 = Math.acos(num4);
      const num6 = 1 / Math.sin(num5);
      num3 = Math.sin((1 - amount) * num5) * num6;
      num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;
    }
    result._x = num3 * left._x + num2 * right._x;
    result._y = num3 * left._y + num2 * right._y;
    result._z = num3 * left._z + num2 * right._z;
    result._w = num3 * left._w + num2 * right._w;
    result._isDirty = true;
    return result;
  }
  /**
   * Interpolate between two quaternions using Hermite interpolation
   * Example Playground https://playground.babylonjs.com/#L49EJ7#47
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/drawCurves#hermite-quaternion-spline
   * @param value1 defines first quaternion
   * @param tangent1 defines the incoming tangent
   * @param value2 defines second quaternion
   * @param tangent2 defines the outgoing tangent
   * @param amount defines the target quaternion
   * @returns the new interpolated quaternion
   */
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    const x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
    const y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
    const z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
    const w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;
    return new value1.constructor(x, y, z, w);
  }
  /**
   * Returns a new Quaternion which is the 1st derivative of the Hermite spline defined by the quaternions "value1", "value2", "tangent1", "tangent2".
   * Example Playground https://playground.babylonjs.com/#L49EJ7#48
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @returns 1st derivative
   */
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const result = new value1.constructor();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  }
  /**
   * Update a Quaternion with the 1st derivative of the Hermite spline defined by the quaternions "value1", "value2", "tangent1", "tangent2".
   * Example Playground https://playground.babylonjs.com/#L49EJ7#49
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @param result define where to store the derivative
   * @returns result input
   */
  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
    const t2 = time * time;
    result._x = (t2 - time) * 6 * value1._x + (3 * t2 - 4 * time + 1) * tangent1._x + (-t2 + time) * 6 * value2._x + (3 * t2 - 2 * time) * tangent2._x;
    result._y = (t2 - time) * 6 * value1._y + (3 * t2 - 4 * time + 1) * tangent1._y + (-t2 + time) * 6 * value2._y + (3 * t2 - 2 * time) * tangent2._y;
    result._z = (t2 - time) * 6 * value1._z + (3 * t2 - 4 * time + 1) * tangent1._z + (-t2 + time) * 6 * value2._z + (3 * t2 - 2 * time) * tangent2._z;
    result._w = (t2 - time) * 6 * value1._w + (3 * t2 - 4 * time + 1) * tangent1._w + (-t2 + time) * 6 * value2._w + (3 * t2 - 2 * time) * tangent2._w;
    result._isDirty = true;
    return result;
  }
  /**
   * Returns a new Quaternion as the normalization of the given Quaternion
   * @param quat defines the Quaternion to normalize
   * @returns the new Quaternion
   */
  static Normalize(quat) {
    const result = _Quaternion.Zero();
    _Quaternion.NormalizeToRef(quat, result);
    return result;
  }
  /**
   * Sets the given Quaternion "result" with the normalization of the given first Quaternion
   * @param quat defines the Quaternion to normalize
   * @param result defines the Quaternion where to store the result
   * @returns result input
   */
  static NormalizeToRef(quat, result) {
    quat.normalizeToRef(result);
    return result;
  }
};
var Matrix = class _Matrix {
  /**
   * Gets the precision of matrix computations
   */
  static get Use64Bits() {
    return PerformanceConfigurator.MatrixUse64Bits;
  }
  /**
   * Gets the internal data of the matrix
   */
  get m() {
    return this._m;
  }
  /**
   * Update the updateFlag to indicate that the matrix has been updated
   */
  markAsUpdated() {
    this.updateFlag = _Matrix._UpdateFlagSeed++;
    this._isIdentity = false;
    this._isIdentity3x2 = false;
    this._isIdentityDirty = true;
    this._isIdentity3x2Dirty = true;
  }
  _updateIdentityStatus(isIdentity, isIdentityDirty = false, isIdentity3x2 = false, isIdentity3x2Dirty = true) {
    this._isIdentity = isIdentity;
    this._isIdentity3x2 = isIdentity || isIdentity3x2;
    this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;
    this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;
  }
  /**
   * Creates an empty matrix (filled with zeros)
   */
  constructor() {
    this._isIdentity = false;
    this._isIdentityDirty = true;
    this._isIdentity3x2 = true;
    this._isIdentity3x2Dirty = true;
    this.updateFlag = -1;
    if (PerformanceConfigurator.MatrixTrackPrecisionChange) {
      PerformanceConfigurator.MatrixTrackedMatrices.push(this);
    }
    this._m = new PerformanceConfigurator.MatrixCurrentType(16);
    this.markAsUpdated();
  }
  // Properties
  /**
   * Check if the current matrix is identity
   * @returns true is the matrix is the identity matrix
   */
  isIdentity() {
    if (this._isIdentityDirty) {
      this._isIdentityDirty = false;
      const m = this._m;
      this._isIdentity = m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
    }
    return this._isIdentity;
  }
  /**
   * Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)
   * @returns true is the matrix is the identity matrix
   */
  isIdentityAs3x2() {
    if (this._isIdentity3x2Dirty) {
      this._isIdentity3x2Dirty = false;
      if (this._m[0] !== 1 || this._m[5] !== 1 || this._m[15] !== 1) {
        this._isIdentity3x2 = false;
      } else if (this._m[1] !== 0 || this._m[2] !== 0 || this._m[3] !== 0 || this._m[4] !== 0 || this._m[6] !== 0 || this._m[7] !== 0 || this._m[8] !== 0 || this._m[9] !== 0 || this._m[10] !== 0 || this._m[11] !== 0 || this._m[12] !== 0 || this._m[13] !== 0 || this._m[14] !== 0) {
        this._isIdentity3x2 = false;
      } else {
        this._isIdentity3x2 = true;
      }
    }
    return this._isIdentity3x2;
  }
  /**
   * Gets the determinant of the matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#34
   * @returns the matrix determinant
   */
  determinant() {
    if (this._isIdentity === true) {
      return 1;
    }
    const m = this._m;
    const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
    const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
    const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
    const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
    const det_22_33 = m22 * m33 - m32 * m23;
    const det_21_33 = m21 * m33 - m31 * m23;
    const det_21_32 = m21 * m32 - m31 * m22;
    const det_20_33 = m20 * m33 - m30 * m23;
    const det_20_32 = m20 * m32 - m22 * m30;
    const det_20_31 = m20 * m31 - m30 * m21;
    const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
    const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
    const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
    const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
    return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
  }
  // Methods
  /**
   * Gets a string with the Matrix values
   * @returns a string with the Matrix values
   */
  toString() {
    return `{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}
${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}
${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}
${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`;
  }
  /**
   * Returns the matrix as a Float32Array or Array<number>
   * Example Playground - https://playground.babylonjs.com/#AV9X17#49
   * @returns the matrix underlying array
   */
  toArray() {
    return this._m;
  }
  /**
   * Returns the matrix as a Float32Array or Array<number>
   * Example Playground - https://playground.babylonjs.com/#AV9X17#114
   * @returns the matrix underlying array.
   */
  asArray() {
    return this._m;
  }
  /**
   * Inverts the current matrix in place
   * Example Playground - https://playground.babylonjs.com/#AV9X17#118
   * @returns the current inverted matrix
   */
  invert() {
    this.invertToRef(this);
    return this;
  }
  /**
   * Sets all the matrix elements to zero
   * @returns the current matrix
   */
  reset() {
    _Matrix.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this);
    this._updateIdentityStatus(false);
    return this;
  }
  /**
   * Adds the current matrix with a second one
   * Example Playground - https://playground.babylonjs.com/#AV9X17#44
   * @param other defines the matrix to add
   * @returns a new matrix as the addition of the current matrix and the given one
   */
  add(other) {
    const result = new this.constructor();
    this.addToRef(other, result);
    return result;
  }
  /**
   * Sets the given matrix "result" to the addition of the current matrix and the given one
   * Example Playground - https://playground.babylonjs.com/#AV9X17#45
   * @param other defines the matrix to add
   * @param result defines the target matrix
   * @returns result input
   */
  addToRef(other, result) {
    const m = this._m;
    const resultM = result._m;
    const otherM = other.m;
    for (let index = 0; index < 16; index++) {
      resultM[index] = m[index] + otherM[index];
    }
    result.markAsUpdated();
    return result;
  }
  /**
   * Adds in place the given matrix to the current matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#46
   * @param other defines the second operand
   * @returns the current updated matrix
   */
  addToSelf(other) {
    const m = this._m;
    const otherM = other.m;
    for (let index = 0; index < 16; index++) {
      m[index] += otherM[index];
    }
    this.markAsUpdated();
    return this;
  }
  /**
   * Sets the given matrix to the current inverted Matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#119
   * @param other defines the target matrix
   * @returns result input
   */
  invertToRef(other) {
    if (this._isIdentity === true) {
      _Matrix.IdentityToRef(other);
      return other;
    }
    const m = this._m;
    const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
    const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
    const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
    const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
    const det_22_33 = m22 * m33 - m32 * m23;
    const det_21_33 = m21 * m33 - m31 * m23;
    const det_21_32 = m21 * m32 - m31 * m22;
    const det_20_33 = m20 * m33 - m30 * m23;
    const det_20_32 = m20 * m32 - m22 * m30;
    const det_20_31 = m20 * m31 - m30 * m21;
    const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
    const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
    const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
    const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
    const det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
    if (det === 0) {
      other.copyFrom(this);
      return other;
    }
    const detInv = 1 / det;
    const det_12_33 = m12 * m33 - m32 * m13;
    const det_11_33 = m11 * m33 - m31 * m13;
    const det_11_32 = m11 * m32 - m31 * m12;
    const det_10_33 = m10 * m33 - m30 * m13;
    const det_10_32 = m10 * m32 - m30 * m12;
    const det_10_31 = m10 * m31 - m30 * m11;
    const det_12_23 = m12 * m23 - m22 * m13;
    const det_11_23 = m11 * m23 - m21 * m13;
    const det_11_22 = m11 * m22 - m21 * m12;
    const det_10_23 = m10 * m23 - m20 * m13;
    const det_10_22 = m10 * m22 - m20 * m12;
    const det_10_21 = m10 * m21 - m20 * m11;
    const cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);
    const cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);
    const cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);
    const cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);
    const cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);
    const cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);
    const cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);
    const cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);
    const cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);
    const cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);
    const cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);
    const cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);
    _Matrix.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);
    return other;
  }
  /**
   * add a value at the specified position in the current Matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#47
   * @param index the index of the value within the matrix. between 0 and 15.
   * @param value the value to be added
   * @returns the current updated matrix
   */
  addAtIndex(index, value) {
    this._m[index] += value;
    this.markAsUpdated();
    return this;
  }
  /**
   * mutiply the specified position in the current Matrix by a value
   * @param index the index of the value within the matrix. between 0 and 15.
   * @param value the value to be added
   * @returns the current updated matrix
   */
  multiplyAtIndex(index, value) {
    this._m[index] *= value;
    this.markAsUpdated();
    return this;
  }
  /**
   * Inserts the translation vector (using 3 floats) in the current matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#120
   * @param x defines the 1st component of the translation
   * @param y defines the 2nd component of the translation
   * @param z defines the 3rd component of the translation
   * @returns the current updated matrix
   */
  setTranslationFromFloats(x, y, z) {
    this._m[12] = x;
    this._m[13] = y;
    this._m[14] = z;
    this.markAsUpdated();
    return this;
  }
  /**
   * Adds the translation vector (using 3 floats) in the current matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#20
   * Example Playground - https://playground.babylonjs.com/#AV9X17#48
   * @param x defines the 1st component of the translation
   * @param y defines the 2nd component of the translation
   * @param z defines the 3rd component of the translation
   * @returns the current updated matrix
   */
  addTranslationFromFloats(x, y, z) {
    this._m[12] += x;
    this._m[13] += y;
    this._m[14] += z;
    this.markAsUpdated();
    return this;
  }
  /**
   * Inserts the translation vector in the current matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#121
   * @param vector3 defines the translation to insert
   * @returns the current updated matrix
   */
  setTranslation(vector3) {
    return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);
  }
  /**
   * Gets the translation value of the current matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#122
   * @returns a new Vector3 as the extracted translation from the matrix
   */
  getTranslation() {
    return new Vector3(this._m[12], this._m[13], this._m[14]);
  }
  /**
   * Fill a Vector3 with the extracted translation from the matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#123
   * @param result defines the Vector3 where to store the translation
   * @returns the current matrix
   */
  getTranslationToRef(result) {
    result.x = this._m[12];
    result.y = this._m[13];
    result.z = this._m[14];
    return result;
  }
  /**
   * Remove rotation and scaling part from the matrix
   * @returns the updated matrix
   */
  removeRotationAndScaling() {
    const m = this.m;
    _Matrix.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, m[12], m[13], m[14], m[15], this);
    this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);
    return this;
  }
  /**
   * Multiply two matrices
   * Example Playground - https://playground.babylonjs.com/#AV9X17#15
   * A.multiply(B) means apply B to A so result is B x A
   * @param other defines the second operand
   * @returns a new matrix set with the multiplication result of the current Matrix and the given one
   */
  multiply(other) {
    const result = new this.constructor();
    this.multiplyToRef(other, result);
    return result;
  }
  /**
   * Copy the current matrix from the given one
   * Example Playground - https://playground.babylonjs.com/#AV9X17#21
   * @param other defines the source matrix
   * @returns the current updated matrix
   */
  copyFrom(other) {
    other.copyToArray(this._m);
    const o = other;
    this.updateFlag = o.updateFlag;
    this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);
    return this;
  }
  /**
   * Populates the given array from the starting index with the current matrix values
   * @param array defines the target array
   * @param offset defines the offset in the target array where to start storing values
   * @returns the current matrix
   */
  copyToArray(array, offset = 0) {
    const source = this._m;
    array[offset] = source[0];
    array[offset + 1] = source[1];
    array[offset + 2] = source[2];
    array[offset + 3] = source[3];
    array[offset + 4] = source[4];
    array[offset + 5] = source[5];
    array[offset + 6] = source[6];
    array[offset + 7] = source[7];
    array[offset + 8] = source[8];
    array[offset + 9] = source[9];
    array[offset + 10] = source[10];
    array[offset + 11] = source[11];
    array[offset + 12] = source[12];
    array[offset + 13] = source[13];
    array[offset + 14] = source[14];
    array[offset + 15] = source[15];
    return this;
  }
  /**
   * Sets the given matrix "result" with the multiplication result of the current Matrix and the given one
   * A.multiplyToRef(B, R) means apply B to A and store in R and R = B x A
   * Example Playground - https://playground.babylonjs.com/#AV9X17#16
   * @param other defines the second operand
   * @param result defines the matrix where to store the multiplication
   * @returns result input
   */
  multiplyToRef(other, result) {
    if (this._isIdentity) {
      result.copyFrom(other);
      return result;
    }
    if (other._isIdentity) {
      result.copyFrom(this);
      return result;
    }
    this.multiplyToArray(other, result._m, 0);
    result.markAsUpdated();
    return result;
  }
  /**
   * Sets the Float32Array "result" from the given index "offset" with the multiplication of the current matrix and the given one
   * @param other defines the second operand
   * @param result defines the array where to store the multiplication
   * @param offset defines the offset in the target array where to start storing values
   * @returns the current matrix
   */
  multiplyToArray(other, result, offset) {
    const m = this._m;
    const otherM = other.m;
    const tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];
    const tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];
    const tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];
    const tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];
    const om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];
    const om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];
    const om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];
    const om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];
    result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;
    result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;
    result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;
    result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;
    result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;
    result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;
    result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;
    result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;
    result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;
    result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;
    result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;
    result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;
    result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;
    result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;
    result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;
    result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;
    return this;
  }
  /**
   * Check equality between this matrix and a second one
   * @param value defines the second matrix to compare
   * @returns true is the current matrix and the given one values are strictly equal
   */
  equals(value) {
    const other = value;
    if (!other) {
      return false;
    }
    if (this._isIdentity || other._isIdentity) {
      if (!this._isIdentityDirty && !other._isIdentityDirty) {
        return this._isIdentity && other._isIdentity;
      }
    }
    const m = this.m;
    const om = other.m;
    return m[0] === om[0] && m[1] === om[1] && m[2] === om[2] && m[3] === om[3] && m[4] === om[4] && m[5] === om[5] && m[6] === om[6] && m[7] === om[7] && m[8] === om[8] && m[9] === om[9] && m[10] === om[10] && m[11] === om[11] && m[12] === om[12] && m[13] === om[13] && m[14] === om[14] && m[15] === om[15];
  }
  /**
   * Clone the current matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#18
   * @returns a new matrix from the current matrix
   */
  clone() {
    const matrix = new this.constructor();
    matrix.copyFrom(this);
    return matrix;
  }
  /**
   * Returns the name of the current matrix class
   * @returns the string "Matrix"
   */
  getClassName() {
    return "Matrix";
  }
  /**
   * Gets the hash code of the current matrix
   * @returns the hash code
   */
  getHashCode() {
    let hash = _ExtractAsInt(this._m[0]);
    for (let i = 1; i < 16; i++) {
      hash = hash * 397 ^ _ExtractAsInt(this._m[i]);
    }
    return hash;
  }
  /**
   * Decomposes the current Matrix into a translation, rotation and scaling components of the provided node
   * Example Playground - https://playground.babylonjs.com/#AV9X17#13
   * @param node the node to decompose the matrix to
   * @returns true if operation was successful
   */
  decomposeToTransformNode(node) {
    node.rotationQuaternion = node.rotationQuaternion || new Quaternion();
    return this.decompose(node.scaling, node.rotationQuaternion, node.position);
  }
  /**
   * Decomposes the current Matrix into a translation, rotation and scaling components
   * Example Playground - https://playground.babylonjs.com/#AV9X17#12
   * @param scale defines the scale vector3 given as a reference to update
   * @param rotation defines the rotation quaternion given as a reference to update
   * @param translation defines the translation vector3 given as a reference to update
   * @param preserveScalingNode Use scaling sign coming from this node. Otherwise scaling sign might change.
   * @param useAbsoluteScaling Use scaling sign coming from this absoluteScaling when true or scaling otherwise.
   * @returns true if operation was successful
   */
  decompose(scale, rotation, translation, preserveScalingNode, useAbsoluteScaling = true) {
    if (this._isIdentity) {
      if (translation) {
        translation.setAll(0);
      }
      if (scale) {
        scale.setAll(1);
      }
      if (rotation) {
        rotation.copyFromFloats(0, 0, 0, 1);
      }
      return true;
    }
    const m = this._m;
    if (translation) {
      translation.copyFromFloats(m[12], m[13], m[14]);
    }
    scale = scale || MathTmp.Vector3[0];
    scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
    scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);
    scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);
    if (preserveScalingNode) {
      const signX = (useAbsoluteScaling ? preserveScalingNode.absoluteScaling.x : preserveScalingNode.scaling.x) < 0 ? -1 : 1;
      const signY = (useAbsoluteScaling ? preserveScalingNode.absoluteScaling.y : preserveScalingNode.scaling.y) < 0 ? -1 : 1;
      const signZ = (useAbsoluteScaling ? preserveScalingNode.absoluteScaling.z : preserveScalingNode.scaling.z) < 0 ? -1 : 1;
      scale.x *= signX;
      scale.y *= signY;
      scale.z *= signZ;
    } else {
      if (this.determinant() <= 0) {
        scale.y *= -1;
      }
    }
    if (scale._x === 0 || scale._y === 0 || scale._z === 0) {
      if (rotation) {
        rotation.copyFromFloats(0, 0, 0, 1);
      }
      return false;
    }
    if (rotation) {
      const sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
      _Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, MathTmp.Matrix[0]);
      Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);
    }
    return true;
  }
  /**
   * Gets specific row of the matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#36
   * @param index defines the number of the row to get
   * @returns the index-th row of the current matrix as a new Vector4
   */
  getRow(index) {
    if (index < 0 || index > 3) {
      return null;
    }
    const i = index * 4;
    return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);
  }
  /**
   * Gets specific row of the matrix to ref
   * Example Playground - https://playground.babylonjs.com/#AV9X17#36
   * @param index defines the number of the row to get
   * @param rowVector vector to store the index-th row of the current matrix
   * @returns result input
   */
  getRowToRef(index, rowVector) {
    if (index >= 0 && index <= 3) {
      const i = index * 4;
      rowVector.x = this._m[i + 0];
      rowVector.y = this._m[i + 1];
      rowVector.z = this._m[i + 2];
      rowVector.w = this._m[i + 3];
    }
    return rowVector;
  }
  /**
   * Sets the index-th row of the current matrix to the vector4 values
   * Example Playground - https://playground.babylonjs.com/#AV9X17#36
   * @param index defines the number of the row to set
   * @param row defines the target vector4
   * @returns the updated current matrix
   */
  setRow(index, row) {
    return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);
  }
  /**
   * Compute the transpose of the matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#40
   * @returns the new transposed matrix
   */
  transpose() {
    const result = new this.constructor();
    _Matrix.TransposeToRef(this, result);
    return result;
  }
  /**
   * Compute the transpose of the matrix and store it in a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#41
   * @param result defines the target matrix
   * @returns result input
   */
  transposeToRef(result) {
    _Matrix.TransposeToRef(this, result);
    return result;
  }
  /**
   * Sets the index-th row of the current matrix with the given 4 x float values
   * Example Playground - https://playground.babylonjs.com/#AV9X17#36
   * @param index defines the row index
   * @param x defines the x component to set
   * @param y defines the y component to set
   * @param z defines the z component to set
   * @param w defines the w component to set
   * @returns the updated current matrix
   */
  setRowFromFloats(index, x, y, z, w) {
    if (index < 0 || index > 3) {
      return this;
    }
    const i = index * 4;
    this._m[i + 0] = x;
    this._m[i + 1] = y;
    this._m[i + 2] = z;
    this._m[i + 3] = w;
    this.markAsUpdated();
    return this;
  }
  /**
   * Compute a new matrix set with the current matrix values multiplied by scale (float)
   * @param scale defines the scale factor
   * @returns a new matrix
   */
  scale(scale) {
    const result = new this.constructor();
    this.scaleToRef(scale, result);
    return result;
  }
  /**
   * Scale the current matrix values by a factor to a given result matrix
   * @param scale defines the scale factor
   * @param result defines the matrix to store the result
   * @returns result input
   */
  scaleToRef(scale, result) {
    for (let index = 0; index < 16; index++) {
      result._m[index] = this._m[index] * scale;
    }
    result.markAsUpdated();
    return result;
  }
  /**
   * Scale the current matrix values by a factor and add the result to a given matrix
   * @param scale defines the scale factor
   * @param result defines the Matrix to store the result
   * @returns result input
   */
  scaleAndAddToRef(scale, result) {
    for (let index = 0; index < 16; index++) {
      result._m[index] += this._m[index] * scale;
    }
    result.markAsUpdated();
    return result;
  }
  /**
   * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).
   * Example Playground - https://playground.babylonjs.com/#AV9X17#17
   * @param ref matrix to store the result
   * @returns the reference matrix
   */
  toNormalMatrix(ref) {
    const tmp = MathTmp.Matrix[0];
    this.invertToRef(tmp);
    tmp.transposeToRef(ref);
    const m = ref._m;
    _Matrix.FromValuesToRef(m[0], m[1], m[2], 0, m[4], m[5], m[6], 0, m[8], m[9], m[10], 0, 0, 0, 0, 1, ref);
    return ref;
  }
  /**
   * Gets only rotation part of the current matrix
   * @returns a new matrix sets to the extracted rotation matrix from the current one
   */
  getRotationMatrix() {
    const result = new this.constructor();
    this.getRotationMatrixToRef(result);
    return result;
  }
  /**
   * Extracts the rotation matrix from the current one and sets it as the given "result"
   * @param result defines the target matrix to store data to
   * @returns result input
   */
  getRotationMatrixToRef(result) {
    const scale = MathTmp.Vector3[0];
    if (!this.decompose(scale)) {
      _Matrix.IdentityToRef(result);
      return result;
    }
    const m = this._m;
    const sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
    _Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, result);
    return result;
  }
  /**
   * Toggles model matrix from being right handed to left handed in place and vice versa
   * @returns the current updated matrix
   */
  toggleModelMatrixHandInPlace() {
    const m = this._m;
    m[2] *= -1;
    m[6] *= -1;
    m[8] *= -1;
    m[9] *= -1;
    m[14] *= -1;
    this.markAsUpdated();
    return this;
  }
  /**
   * Toggles projection matrix from being right handed to left handed in place and vice versa
   * @returns the current updated matrix
   */
  toggleProjectionMatrixHandInPlace() {
    const m = this._m;
    m[8] *= -1;
    m[9] *= -1;
    m[10] *= -1;
    m[11] *= -1;
    this.markAsUpdated();
    return this;
  }
  // Statics
  /**
   * Creates a matrix from an array
   * Example Playground - https://playground.babylonjs.com/#AV9X17#42
   * @param array defines the source array
   * @param offset defines an offset in the source array
   * @returns a new Matrix set from the starting index of the given array
   */
  static FromArray(array, offset = 0) {
    const result = new _Matrix();
    _Matrix.FromArrayToRef(array, offset, result);
    return result;
  }
  /**
   * Copy the content of an array into a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#43
   * @param array defines the source array
   * @param offset defines an offset in the source array
   * @param result defines the target matrix
   * @returns result input
   */
  static FromArrayToRef(array, offset, result) {
    for (let index = 0; index < 16; index++) {
      result._m[index] = array[index + offset];
    }
    result.markAsUpdated();
    return result;
  }
  /**
   * Stores an array into a matrix after having multiplied each component by a given factor
   * Example Playground - https://playground.babylonjs.com/#AV9X17#50
   * @param array defines the source array
   * @param offset defines the offset in the source array
   * @param scale defines the scaling factor
   * @param result defines the target matrix
   * @returns result input
   */
  static FromFloat32ArrayToRefScaled(array, offset, scale, result) {
    for (let index = 0; index < 16; index++) {
      result._m[index] = array[index + offset] * scale;
    }
    result.markAsUpdated();
    return result;
  }
  /**
   * Gets an identity matrix that must not be updated
   */
  static get IdentityReadOnly() {
    return _Matrix._IdentityReadOnly;
  }
  /**
   * Stores a list of values (16) inside a given matrix
   * @param initialM11 defines 1st value of 1st row
   * @param initialM12 defines 2nd value of 1st row
   * @param initialM13 defines 3rd value of 1st row
   * @param initialM14 defines 4th value of 1st row
   * @param initialM21 defines 1st value of 2nd row
   * @param initialM22 defines 2nd value of 2nd row
   * @param initialM23 defines 3rd value of 2nd row
   * @param initialM24 defines 4th value of 2nd row
   * @param initialM31 defines 1st value of 3rd row
   * @param initialM32 defines 2nd value of 3rd row
   * @param initialM33 defines 3rd value of 3rd row
   * @param initialM34 defines 4th value of 3rd row
   * @param initialM41 defines 1st value of 4th row
   * @param initialM42 defines 2nd value of 4th row
   * @param initialM43 defines 3rd value of 4th row
   * @param initialM44 defines 4th value of 4th row
   * @param result defines the target matrix
   */
  static FromValuesToRef(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {
    const m = result._m;
    m[0] = initialM11;
    m[1] = initialM12;
    m[2] = initialM13;
    m[3] = initialM14;
    m[4] = initialM21;
    m[5] = initialM22;
    m[6] = initialM23;
    m[7] = initialM24;
    m[8] = initialM31;
    m[9] = initialM32;
    m[10] = initialM33;
    m[11] = initialM34;
    m[12] = initialM41;
    m[13] = initialM42;
    m[14] = initialM43;
    m[15] = initialM44;
    result.markAsUpdated();
  }
  /**
   * Creates new matrix from a list of values (16)
   * @param initialM11 defines 1st value of 1st row
   * @param initialM12 defines 2nd value of 1st row
   * @param initialM13 defines 3rd value of 1st row
   * @param initialM14 defines 4th value of 1st row
   * @param initialM21 defines 1st value of 2nd row
   * @param initialM22 defines 2nd value of 2nd row
   * @param initialM23 defines 3rd value of 2nd row
   * @param initialM24 defines 4th value of 2nd row
   * @param initialM31 defines 1st value of 3rd row
   * @param initialM32 defines 2nd value of 3rd row
   * @param initialM33 defines 3rd value of 3rd row
   * @param initialM34 defines 4th value of 3rd row
   * @param initialM41 defines 1st value of 4th row
   * @param initialM42 defines 2nd value of 4th row
   * @param initialM43 defines 3rd value of 4th row
   * @param initialM44 defines 4th value of 4th row
   * @returns the new matrix
   */
  static FromValues(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {
    const result = new _Matrix();
    const m = result._m;
    m[0] = initialM11;
    m[1] = initialM12;
    m[2] = initialM13;
    m[3] = initialM14;
    m[4] = initialM21;
    m[5] = initialM22;
    m[6] = initialM23;
    m[7] = initialM24;
    m[8] = initialM31;
    m[9] = initialM32;
    m[10] = initialM33;
    m[11] = initialM34;
    m[12] = initialM41;
    m[13] = initialM42;
    m[14] = initialM43;
    m[15] = initialM44;
    result.markAsUpdated();
    return result;
  }
  /**
   * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)
   * Example Playground - https://playground.babylonjs.com/#AV9X17#24
   * @param scale defines the scale vector3
   * @param rotation defines the rotation quaternion
   * @param translation defines the translation vector3
   * @returns a new matrix
   */
  static Compose(scale, rotation, translation) {
    const result = new _Matrix();
    _Matrix.ComposeToRef(scale, rotation, translation, result);
    return result;
  }
  /**
   * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)
   * Example Playground - https://playground.babylonjs.com/#AV9X17#25
   * @param scale defines the scale vector3
   * @param rotation defines the rotation quaternion
   * @param translation defines the translation vector3
   * @param result defines the target matrix
   * @returns result input
   */
  static ComposeToRef(scale, rotation, translation, result) {
    const m = result._m;
    const x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale._x, sy = scale._y, sz = scale._z;
    m[0] = (1 - (yy + zz)) * sx;
    m[1] = (xy + wz) * sx;
    m[2] = (xz - wy) * sx;
    m[3] = 0;
    m[4] = (xy - wz) * sy;
    m[5] = (1 - (xx + zz)) * sy;
    m[6] = (yz + wx) * sy;
    m[7] = 0;
    m[8] = (xz + wy) * sz;
    m[9] = (yz - wx) * sz;
    m[10] = (1 - (xx + yy)) * sz;
    m[11] = 0;
    m[12] = translation._x;
    m[13] = translation._y;
    m[14] = translation._z;
    m[15] = 1;
    result.markAsUpdated();
    return result;
  }
  /**
   * Creates a new identity matrix
   * @returns a new identity matrix
   */
  static Identity() {
    const identity = _Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    identity._updateIdentityStatus(true);
    return identity;
  }
  /**
   * Creates a new identity matrix and stores the result in a given matrix
   * @param result defines the target matrix
   * @returns result input
   */
  static IdentityToRef(result) {
    _Matrix.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(true);
    return result;
  }
  /**
   * Creates a new zero matrix
   * @returns a new zero matrix
   */
  static Zero() {
    const zero = _Matrix.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    zero._updateIdentityStatus(false);
    return zero;
  }
  /**
   * Creates a new rotation matrix for "angle" radians around the X axis
   * Example Playground - https://playground.babylonjs.com/#AV9X17#97
   * @param angle defines the angle (in radians) to use
   * @returns the new matrix
   */
  static RotationX(angle) {
    const result = new _Matrix();
    _Matrix.RotationXToRef(angle, result);
    return result;
  }
  /**
   * Creates a new matrix as the invert of a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#124
   * @param source defines the source matrix
   * @returns the new matrix
   */
  static Invert(source) {
    const result = new source.constructor();
    source.invertToRef(result);
    return result;
  }
  /**
   * Creates a new rotation matrix for "angle" radians around the X axis and stores it in a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#98
   * @param angle defines the angle (in radians) to use
   * @param result defines the target matrix
   * @returns result input
   */
  static RotationXToRef(angle, result) {
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    _Matrix.FromValuesToRef(1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
    return result;
  }
  /**
   * Creates a new rotation matrix for "angle" radians around the Y axis
   * Example Playground - https://playground.babylonjs.com/#AV9X17#99
   * @param angle defines the angle (in radians) to use
   * @returns the new matrix
   */
  static RotationY(angle) {
    const result = new _Matrix();
    _Matrix.RotationYToRef(angle, result);
    return result;
  }
  /**
   * Creates a new rotation matrix for "angle" radians around the Y axis and stores it in a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#100
   * @param angle defines the angle (in radians) to use
   * @param result defines the target matrix
   * @returns result input
   */
  static RotationYToRef(angle, result) {
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    _Matrix.FromValuesToRef(c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
    return result;
  }
  /**
   * Creates a new rotation matrix for "angle" radians around the Z axis
   * Example Playground - https://playground.babylonjs.com/#AV9X17#101
   * @param angle defines the angle (in radians) to use
   * @returns the new matrix
   */
  static RotationZ(angle) {
    const result = new _Matrix();
    _Matrix.RotationZToRef(angle, result);
    return result;
  }
  /**
   * Creates a new rotation matrix for "angle" radians around the Z axis and stores it in a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#102
   * @param angle defines the angle (in radians) to use
   * @param result defines the target matrix
   * @returns result input
   */
  static RotationZToRef(angle, result) {
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    _Matrix.FromValuesToRef(c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
    return result;
  }
  /**
   * Creates a new rotation matrix for "angle" radians around the given axis
   * Example Playground - https://playground.babylonjs.com/#AV9X17#96
   * @param axis defines the axis to use
   * @param angle defines the angle (in radians) to use
   * @returns the new matrix
   */
  static RotationAxis(axis, angle) {
    const result = new _Matrix();
    _Matrix.RotationAxisToRef(axis, angle, result);
    return result;
  }
  /**
   * Creates a new rotation matrix for "angle" radians around the given axis and stores it in a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#94
   * @param axis defines the axis to use
   * @param angle defines the angle (in radians) to use
   * @param result defines the target matrix
   * @returns result input
   */
  static RotationAxisToRef(axis, angle, result) {
    const s = Math.sin(-angle);
    const c = Math.cos(-angle);
    const c1 = 1 - c;
    axis.normalize();
    const m = result._m;
    m[0] = axis._x * axis._x * c1 + c;
    m[1] = axis._x * axis._y * c1 - axis._z * s;
    m[2] = axis._x * axis._z * c1 + axis._y * s;
    m[3] = 0;
    m[4] = axis._y * axis._x * c1 + axis._z * s;
    m[5] = axis._y * axis._y * c1 + c;
    m[6] = axis._y * axis._z * c1 - axis._x * s;
    m[7] = 0;
    m[8] = axis._z * axis._x * c1 - axis._y * s;
    m[9] = axis._z * axis._y * c1 + axis._x * s;
    m[10] = axis._z * axis._z * c1 + c;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    result.markAsUpdated();
    return result;
  }
  /**
   * Takes normalised vectors and returns a rotation matrix to align "from" with "to".
   * Taken from http://www.iquilezles.org/www/articles/noacos/noacos.htm
   * Example Playground - https://playground.babylonjs.com/#AV9X17#93
   * @param from defines the vector to align
   * @param to defines the vector to align to
   * @param result defines the target matrix
   * @param useYAxisForCoplanar defines a boolean indicating that we should favor Y axis for coplanar vectors (default is false)
   * @returns result input
   */
  static RotationAlignToRef(from, to, result, useYAxisForCoplanar = false) {
    const c = Vector3.Dot(to, from);
    const m = result._m;
    if (c < -1 + Epsilon) {
      m[0] = -1;
      m[1] = 0;
      m[2] = 0;
      m[3] = 0;
      m[4] = 0;
      m[5] = useYAxisForCoplanar ? 1 : -1;
      m[6] = 0;
      m[7] = 0;
      m[8] = 0;
      m[9] = 0;
      m[10] = useYAxisForCoplanar ? -1 : 1;
      m[11] = 0;
    } else {
      const v = Vector3.Cross(to, from);
      const k = 1 / (1 + c);
      m[0] = v._x * v._x * k + c;
      m[1] = v._y * v._x * k - v._z;
      m[2] = v._z * v._x * k + v._y;
      m[3] = 0;
      m[4] = v._x * v._y * k + v._z;
      m[5] = v._y * v._y * k + c;
      m[6] = v._z * v._y * k - v._x;
      m[7] = 0;
      m[8] = v._x * v._z * k - v._y;
      m[9] = v._y * v._z * k + v._x;
      m[10] = v._z * v._z * k + c;
      m[11] = 0;
    }
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    result.markAsUpdated();
    return result;
  }
  /**
   * Creates a rotation matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#103
   * Example Playground - https://playground.babylonjs.com/#AV9X17#105
   * @param yaw defines the yaw angle in radians (Y axis)
   * @param pitch defines the pitch angle in radians (X axis)
   * @param roll defines the roll angle in radians (Z axis)
   * @returns the new rotation matrix
   */
  static RotationYawPitchRoll(yaw, pitch, roll) {
    const result = new _Matrix();
    _Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);
    return result;
  }
  /**
   * Creates a rotation matrix and stores it in a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#104
   * @param yaw defines the yaw angle in radians (Y axis)
   * @param pitch defines the pitch angle in radians (X axis)
   * @param roll defines the roll angle in radians (Z axis)
   * @param result defines the target matrix
   * @returns result input
   */
  static RotationYawPitchRollToRef(yaw, pitch, roll, result) {
    Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);
    MathTmp.Quaternion[0].toRotationMatrix(result);
    return result;
  }
  /**
   * Creates a scaling matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#107
   * @param x defines the scale factor on X axis
   * @param y defines the scale factor on Y axis
   * @param z defines the scale factor on Z axis
   * @returns the new matrix
   */
  static Scaling(x, y, z) {
    const result = new _Matrix();
    _Matrix.ScalingToRef(x, y, z, result);
    return result;
  }
  /**
   * Creates a scaling matrix and stores it in a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#108
   * @param x defines the scale factor on X axis
   * @param y defines the scale factor on Y axis
   * @param z defines the scale factor on Z axis
   * @param result defines the target matrix
   * @returns result input
   */
  static ScalingToRef(x, y, z, result) {
    _Matrix.FromValuesToRef(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(x === 1 && y === 1 && z === 1);
    return result;
  }
  /**
   * Creates a translation matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#109
   * @param x defines the translation on X axis
   * @param y defines the translation on Y axis
   * @param z defines the translationon Z axis
   * @returns the new matrix
   */
  static Translation(x, y, z) {
    const result = new _Matrix();
    _Matrix.TranslationToRef(x, y, z, result);
    return result;
  }
  /**
   * Creates a translation matrix and stores it in a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#110
   * @param x defines the translation on X axis
   * @param y defines the translation on Y axis
   * @param z defines the translationon Z axis
   * @param result defines the target matrix
   * @returns result input
   */
  static TranslationToRef(x, y, z, result) {
    _Matrix.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1, result);
    result._updateIdentityStatus(x === 0 && y === 0 && z === 0);
    return result;
  }
  /**
   * Returns a new Matrix whose values are the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".
   * Example Playground - https://playground.babylonjs.com/#AV9X17#55
   * @param startValue defines the start value
   * @param endValue defines the end value
   * @param gradient defines the gradient factor
   * @returns the new matrix
   */
  static Lerp(startValue, endValue, gradient) {
    const result = new startValue.constructor();
    _Matrix.LerpToRef(startValue, endValue, gradient, result);
    return result;
  }
  /**
   * Set the given matrix "result" as the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".
   * Example Playground - https://playground.babylonjs.com/#AV9X17#54
   * @param startValue defines the start value
   * @param endValue defines the end value
   * @param gradient defines the gradient factor
   * @param result defines the Matrix object where to store data
   * @returns result input
   */
  static LerpToRef(startValue, endValue, gradient, result) {
    const resultM = result._m;
    const startM = startValue.m;
    const endM = endValue.m;
    for (let index = 0; index < 16; index++) {
      resultM[index] = startM[index] * (1 - gradient) + endM[index] * gradient;
    }
    result.markAsUpdated();
    return result;
  }
  /**
   * Builds a new matrix whose values are computed by:
   * * decomposing the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
   * * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
   * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices
   * Example Playground - https://playground.babylonjs.com/#AV9X17#22
   * Example Playground - https://playground.babylonjs.com/#AV9X17#51
   * @param startValue defines the first matrix
   * @param endValue defines the second matrix
   * @param gradient defines the gradient between the two matrices
   * @returns the new matrix
   */
  static DecomposeLerp(startValue, endValue, gradient) {
    const result = new startValue.constructor();
    _Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);
    return result;
  }
  /**
   * Update a matrix to values which are computed by:
   * * decomposing the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
   * * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
   * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices
   * Example Playground - https://playground.babylonjs.com/#AV9X17#23
   * Example Playground - https://playground.babylonjs.com/#AV9X17#53
   * @param startValue defines the first matrix
   * @param endValue defines the second matrix
   * @param gradient defines the gradient between the two matrices
   * @param result defines the target matrix
   * @returns result input
   */
  static DecomposeLerpToRef(startValue, endValue, gradient, result) {
    const startScale = MathTmp.Vector3[0];
    const startRotation = MathTmp.Quaternion[0];
    const startTranslation = MathTmp.Vector3[1];
    startValue.decompose(startScale, startRotation, startTranslation);
    const endScale = MathTmp.Vector3[2];
    const endRotation = MathTmp.Quaternion[1];
    const endTranslation = MathTmp.Vector3[3];
    endValue.decompose(endScale, endRotation, endTranslation);
    const resultScale = MathTmp.Vector3[4];
    Vector3.LerpToRef(startScale, endScale, gradient, resultScale);
    const resultRotation = MathTmp.Quaternion[2];
    Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);
    const resultTranslation = MathTmp.Vector3[5];
    Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);
    _Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);
    return result;
  }
  /**
   * Creates a new matrix that transforms vertices from world space to camera space. It takes three vectors as arguments that together describe the position and orientation of the camera.
   * This function generates a matrix suitable for a left handed coordinate system
   * Example Playground - https://playground.babylonjs.com/#AV9X17#58
   * Example Playground - https://playground.babylonjs.com/#AV9X17#59
   * @param eye defines the final position of the entity
   * @param target defines where the entity should look at
   * @param up defines the up vector for the entity
   * @returns the new matrix
   */
  static LookAtLH(eye, target, up) {
    const result = new _Matrix();
    _Matrix.LookAtLHToRef(eye, target, up, result);
    return result;
  }
  /**
   * Sets the given "result" Matrix to a matrix that transforms vertices from world space to camera space. It takes three vectors as arguments that together describe the position and orientation of the camera.
   * This function generates a matrix suitable for a left handed coordinate system
   * Example Playground - https://playground.babylonjs.com/#AV9X17#60
   * Example Playground - https://playground.babylonjs.com/#AV9X17#61
   * @param eye defines the final position of the entity
   * @param target defines where the entity should look at
   * @param up defines the up vector for the entity
   * @param result defines the target matrix
   * @returns result input
   */
  static LookAtLHToRef(eye, target, up, result) {
    const xAxis = MathTmp.Vector3[0];
    const yAxis = MathTmp.Vector3[1];
    const zAxis = MathTmp.Vector3[2];
    target.subtractToRef(eye, zAxis);
    zAxis.normalize();
    Vector3.CrossToRef(up, zAxis, xAxis);
    const xSquareLength = xAxis.lengthSquared();
    if (xSquareLength === 0) {
      xAxis.x = 1;
    } else {
      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
    }
    Vector3.CrossToRef(zAxis, xAxis, yAxis);
    yAxis.normalize();
    const ex = -Vector3.Dot(xAxis, eye);
    const ey = -Vector3.Dot(yAxis, eye);
    const ez = -Vector3.Dot(zAxis, eye);
    _Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
    return result;
  }
  /**
   * Creates a new matrix that transforms vertices from world space to camera space. It takes three vectors as arguments that together describe the position and orientation of the camera.
   * This function generates a matrix suitable for a right handed coordinate system
   * Example Playground - https://playground.babylonjs.com/#AV9X17#62
   * Example Playground - https://playground.babylonjs.com/#AV9X17#63
   * @param eye defines the final position of the entity
   * @param target defines where the entity should look at
   * @param up defines the up vector for the entity
   * @returns the new matrix
   */
  static LookAtRH(eye, target, up) {
    const result = new _Matrix();
    _Matrix.LookAtRHToRef(eye, target, up, result);
    return result;
  }
  /**
   * Sets the given "result" Matrix to a matrix that transforms vertices from world space to camera space. It takes three vectors as arguments that together describe the position and orientation of the camera.
   * This function generates a matrix suitable for a right handed coordinate system
   * Example Playground - https://playground.babylonjs.com/#AV9X17#64
   * Example Playground - https://playground.babylonjs.com/#AV9X17#65
   * @param eye defines the final position of the entity
   * @param target defines where the entity should look at
   * @param up defines the up vector for the entity
   * @param result defines the target matrix
   * @returns result input
   */
  static LookAtRHToRef(eye, target, up, result) {
    const xAxis = MathTmp.Vector3[0];
    const yAxis = MathTmp.Vector3[1];
    const zAxis = MathTmp.Vector3[2];
    eye.subtractToRef(target, zAxis);
    zAxis.normalize();
    Vector3.CrossToRef(up, zAxis, xAxis);
    const xSquareLength = xAxis.lengthSquared();
    if (xSquareLength === 0) {
      xAxis.x = 1;
    } else {
      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
    }
    Vector3.CrossToRef(zAxis, xAxis, yAxis);
    yAxis.normalize();
    const ex = -Vector3.Dot(xAxis, eye);
    const ey = -Vector3.Dot(yAxis, eye);
    const ez = -Vector3.Dot(zAxis, eye);
    _Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
    return result;
  }
  /**
   * Creates a new matrix that transforms vertices from world space to camera space. It takes two vectors as arguments that together describe the orientation of the camera. The position is assumed to be at the origin (0,0,0)
   * This function generates a matrix suitable for a left handed coordinate system
   * Example Playground - https://playground.babylonjs.com/#AV9X17#66
   * @param forward defines the forward direction - Must be normalized and orthogonal to up.
   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.
   * @returns the new matrix
   */
  static LookDirectionLH(forward, up) {
    const result = new _Matrix();
    _Matrix.LookDirectionLHToRef(forward, up, result);
    return result;
  }
  /**
   * Sets the given "result" Matrix to a matrix that transforms vertices from world space to camera space. It takes two vectors as arguments that together describe the orientation of the camera. The position is assumed to be at the origin (0,0,0)
   * This function generates a matrix suitable for a left handed coordinate system
   * Example Playground - https://playground.babylonjs.com/#AV9X17#67
   * @param forward defines the forward direction - Must be normalized and orthogonal to up.
   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.
   * @param result defines the target matrix
   * @returns result input
   */
  static LookDirectionLHToRef(forward, up, result) {
    const back = MathTmp.Vector3[0];
    back.copyFrom(forward);
    back.scaleInPlace(-1);
    const left = MathTmp.Vector3[1];
    Vector3.CrossToRef(up, back, left);
    _Matrix.FromValuesToRef(left._x, left._y, left._z, 0, up._x, up._y, up._z, 0, back._x, back._y, back._z, 0, 0, 0, 0, 1, result);
    return result;
  }
  /**
   * Creates a new matrix that transforms vertices from world space to camera space. It takes two vectors as arguments that together describe the orientation of the camera. The position is assumed to be at the origin (0,0,0)
   * This function generates a matrix suitable for a right handed coordinate system
   * Example Playground - https://playground.babylonjs.com/#AV9X17#68
   * @param forward defines the forward direction - Must be normalized and orthogonal to up.
   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.
   * @returns the new matrix
   */
  static LookDirectionRH(forward, up) {
    const result = new _Matrix();
    _Matrix.LookDirectionRHToRef(forward, up, result);
    return result;
  }
  /**
   * Sets the given "result" Matrix to a matrix that transforms vertices from world space to camera space. It takes two vectors as arguments that together describe the orientation of the camera. The position is assumed to be at the origin (0,0,0)
   * This function generates a matrix suitable for a right handed coordinate system
   * Example Playground - https://playground.babylonjs.com/#AV9X17#69
   * @param forward defines the forward direction - Must be normalized and orthogonal to up.
   * @param up defines the up vector for the entity - Must be normalized and orthogonal to forward.
   * @param result defines the target matrix
   * @returns result input
   */
  static LookDirectionRHToRef(forward, up, result) {
    const right = MathTmp.Vector3[2];
    Vector3.CrossToRef(up, forward, right);
    _Matrix.FromValuesToRef(right._x, right._y, right._z, 0, up._x, up._y, up._z, 0, forward._x, forward._y, forward._z, 0, 0, 0, 0, 1, result);
    return result;
  }
  /**
   * Create a left-handed orthographic projection matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#70
   * @param width defines the viewport width
   * @param height defines the viewport height
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @returns a new matrix as a left-handed orthographic projection matrix
   */
  static OrthoLH(width, height, znear, zfar, halfZRange) {
    const matrix = new _Matrix();
    _Matrix.OrthoLHToRef(width, height, znear, zfar, matrix, halfZRange);
    return matrix;
  }
  /**
   * Store a left-handed orthographic projection to a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#71
   * @param width defines the viewport width
   * @param height defines the viewport height
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane
   * @param result defines the target matrix
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @returns result input
   */
  static OrthoLHToRef(width, height, znear, zfar, result, halfZRange) {
    const n = znear;
    const f = zfar;
    const a = 2 / width;
    const b = 2 / height;
    const c = 2 / (f - n);
    const d = -(f + n) / (f - n);
    _Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, d, 1, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);
    return result;
  }
  /**
   * Create a left-handed orthographic projection matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#72
   * @param left defines the viewport left coordinate
   * @param right defines the viewport right coordinate
   * @param bottom defines the viewport bottom coordinate
   * @param top defines the viewport top coordinate
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @returns a new matrix as a left-handed orthographic projection matrix
   */
  static OrthoOffCenterLH(left, right, bottom, top, znear, zfar, halfZRange) {
    const matrix = new _Matrix();
    _Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
    return matrix;
  }
  /**
   * Stores a left-handed orthographic projection into a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#73
   * @param left defines the viewport left coordinate
   * @param right defines the viewport right coordinate
   * @param bottom defines the viewport bottom coordinate
   * @param top defines the viewport top coordinate
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane
   * @param result defines the target matrix
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @returns result input
   */
  static OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange) {
    const n = znear;
    const f = zfar;
    const a = 2 / (right - left);
    const b = 2 / (top - bottom);
    const c = 2 / (f - n);
    const d = -(f + n) / (f - n);
    const i0 = (left + right) / (left - right);
    const i1 = (top + bottom) / (bottom - top);
    _Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, i0, i1, d, 1, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result.markAsUpdated();
    return result;
  }
  /**
   * Stores a left-handed oblique projection into a given matrix
   * @param left defines the viewport left coordinate
   * @param right defines the viewport right coordinate
   * @param bottom defines the viewport bottom coordinate
   * @param top defines the viewport top coordinate
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane
   * @param length Length of the shear
   * @param angle Angle (along X/Y Plane) to apply shear
   * @param distance Distance from shear point
   * @param result defines the target matrix
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @returns result input
   */
  static ObliqueOffCenterLHToRef(left, right, bottom, top, znear, zfar, length, angle, distance, result, halfZRange) {
    const a = -length * Math.cos(angle);
    const b = -length * Math.sin(angle);
    _Matrix.TranslationToRef(0, 0, -distance, MathTmp.Matrix[1]);
    _Matrix.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, a, b, 1, 0, 0, 0, 0, 1, MathTmp.Matrix[0]);
    MathTmp.Matrix[1].multiplyToRef(MathTmp.Matrix[0], MathTmp.Matrix[0]);
    _Matrix.TranslationToRef(0, 0, distance, MathTmp.Matrix[1]);
    MathTmp.Matrix[0].multiplyToRef(MathTmp.Matrix[1], MathTmp.Matrix[0]);
    _Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);
    MathTmp.Matrix[0].multiplyToRef(result, result);
    return result;
  }
  /**
   * Creates a right-handed orthographic projection matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#76
   * @param left defines the viewport left coordinate
   * @param right defines the viewport right coordinate
   * @param bottom defines the viewport bottom coordinate
   * @param top defines the viewport top coordinate
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @returns a new matrix as a right-handed orthographic projection matrix
   */
  static OrthoOffCenterRH(left, right, bottom, top, znear, zfar, halfZRange) {
    const matrix = new _Matrix();
    _Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
    return matrix;
  }
  /**
   * Stores a right-handed orthographic projection into a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#77
   * @param left defines the viewport left coordinate
   * @param right defines the viewport right coordinate
   * @param bottom defines the viewport bottom coordinate
   * @param top defines the viewport top coordinate
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane
   * @param result defines the target matrix
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @returns result input
   */
  static OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, result, halfZRange) {
    _Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);
    result._m[10] *= -1;
    return result;
  }
  /**
   * Stores a right-handed oblique projection into a given matrix
   * @param left defines the viewport left coordinate
   * @param right defines the viewport right coordinate
   * @param bottom defines the viewport bottom coordinate
   * @param top defines the viewport top coordinate
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane
   * @param length Length of the shear
   * @param angle Angle (along X/Y Plane) to apply shear
   * @param distance Distance from shear point
   * @param result defines the target matrix
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @returns result input
   */
  static ObliqueOffCenterRHToRef(left, right, bottom, top, znear, zfar, length, angle, distance, result, halfZRange) {
    const a = length * Math.cos(angle);
    const b = length * Math.sin(angle);
    _Matrix.TranslationToRef(0, 0, distance, MathTmp.Matrix[1]);
    _Matrix.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, a, b, 1, 0, 0, 0, 0, 1, MathTmp.Matrix[0]);
    MathTmp.Matrix[1].multiplyToRef(MathTmp.Matrix[0], MathTmp.Matrix[0]);
    _Matrix.TranslationToRef(0, 0, -distance, MathTmp.Matrix[1]);
    MathTmp.Matrix[0].multiplyToRef(MathTmp.Matrix[1], MathTmp.Matrix[0]);
    _Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);
    MathTmp.Matrix[0].multiplyToRef(result, result);
    return result;
  }
  /**
   * Creates a left-handed perspective projection matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#85
   * @param width defines the viewport width
   * @param height defines the viewport height
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)
   * @returns a new matrix as a left-handed perspective projection matrix
   */
  static PerspectiveLH(width, height, znear, zfar, halfZRange, projectionPlaneTilt = 0) {
    const matrix = new _Matrix();
    const n = znear;
    const f = zfar;
    const a = 2 * n / width;
    const b = 2 * n / height;
    const c = (f + n) / (f - n);
    const d = -2 * f * n / (f - n);
    const rot = Math.tan(projectionPlaneTilt);
    _Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, matrix);
    if (halfZRange) {
      matrix.multiplyToRef(mtxConvertNDCToHalfZRange, matrix);
    }
    matrix._updateIdentityStatus(false);
    return matrix;
  }
  /**
   * Creates a left-handed perspective projection matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#78
   * @param fov defines the horizontal field of view
   * @param aspect defines the aspect ratio
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane. If 0, assume we are in "infinite zfar" mode
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)
   * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)
   * @returns a new matrix as a left-handed perspective projection matrix
   */
  static PerspectiveFovLH(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
    const matrix = new _Matrix();
    _Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
    return matrix;
  }
  /**
   * Stores a left-handed perspective projection into a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#81
   * @param fov defines the horizontal field of view
   * @param aspect defines the aspect ratio
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane. If 0, assume we are in "infinite zfar" mode
   * @param result defines the target matrix
   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)
   * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)
   * @returns result input
   */
  static PerspectiveFovLHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
    const n = znear;
    const f = zfar;
    const t = 1 / Math.tan(fov * 0.5);
    const a = isVerticalFovFixed ? t / aspect : t;
    const b = isVerticalFovFixed ? t : t * aspect;
    const c = reverseDepthBufferMode && n === 0 ? -1 : f !== 0 ? (f + n) / (f - n) : 1;
    const d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
    const rot = Math.tan(projectionPlaneTilt);
    _Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
    return result;
  }
  /**
   * Stores a left-handed perspective projection into a given matrix with depth reversed
   * Example Playground - https://playground.babylonjs.com/#AV9X17#89
   * @param fov defines the horizontal field of view
   * @param aspect defines the aspect ratio
   * @param znear defines the near clip plane
   * @param zfar not used as infinity is used as far clip
   * @param result defines the target matrix
   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)
   * @returns result input
   */
  static PerspectiveFovReverseLHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0) {
    const t = 1 / Math.tan(fov * 0.5);
    const a = isVerticalFovFixed ? t / aspect : t;
    const b = isVerticalFovFixed ? t : t * aspect;
    const rot = Math.tan(projectionPlaneTilt);
    _Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, 1, 0, 0, 1, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
    return result;
  }
  /**
   * Creates a right-handed perspective projection matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#83
   * @param fov defines the horizontal field of view
   * @param aspect defines the aspect ratio
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane. If 0, assume we are in "infinite zfar" mode
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)
   * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)
   * @returns a new matrix as a right-handed perspective projection matrix
   */
  static PerspectiveFovRH(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
    const matrix = new _Matrix();
    _Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
    return matrix;
  }
  /**
   * Stores a right-handed perspective projection into a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#84
   * @param fov defines the horizontal field of view
   * @param aspect defines the aspect ratio
   * @param znear defines the near clip plane
   * @param zfar defines the far clip plane. If 0, assume we are in "infinite zfar" mode
   * @param result defines the target matrix
   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)
   * @param reverseDepthBufferMode true to indicate that we are in a reverse depth buffer mode (meaning znear and zfar have been inverted when calling the function)
   * @returns result input
   */
  static PerspectiveFovRHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
    const n = znear;
    const f = zfar;
    const t = 1 / Math.tan(fov * 0.5);
    const a = isVerticalFovFixed ? t / aspect : t;
    const b = isVerticalFovFixed ? t : t * aspect;
    const c = reverseDepthBufferMode && n === 0 ? 1 : f !== 0 ? -(f + n) / (f - n) : -1;
    const d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
    const rot = Math.tan(projectionPlaneTilt);
    _Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, -1, 0, 0, d, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
    return result;
  }
  /**
   * Stores a right-handed perspective projection into a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#90
   * @param fov defines the horizontal field of view
   * @param aspect defines the aspect ratio
   * @param znear defines the near clip plane
   * @param zfar not used as infinity is used as far clip
   * @param result defines the target matrix
   * @param isVerticalFovFixed defines it the fov is vertically fixed (default) or horizontally
   * @param halfZRange true to generate NDC coordinates between 0 and 1 instead of -1 and 1 (default: false)
   * @param projectionPlaneTilt optional tilt angle of the projection plane around the X axis (horizontal)
   * @returns result input
   */
  static PerspectiveFovReverseRHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0) {
    const t = 1 / Math.tan(fov * 0.5);
    const a = isVerticalFovFixed ? t / aspect : t;
    const b = isVerticalFovFixed ? t : t * aspect;
    const rot = Math.tan(projectionPlaneTilt);
    _Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, -1, 0, 0, -1, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
    return result;
  }
  /**
   * Computes a complete transformation matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#113
   * @param viewport defines the viewport to use
   * @param world defines the world matrix
   * @param view defines the view matrix
   * @param projection defines the projection matrix
   * @param zmin defines the near clip plane
   * @param zmax defines the far clip plane
   * @returns the transformation matrix
   */
  static GetFinalMatrix(viewport, world, view, projection, zmin, zmax) {
    const cw = viewport.width;
    const ch = viewport.height;
    const cx = viewport.x;
    const cy = viewport.y;
    const viewportMatrix = _Matrix.FromValues(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, zmax - zmin, 0, cx + cw / 2, ch / 2 + cy, zmin, 1);
    const matrix = new world.constructor();
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    return matrix.multiplyToRef(viewportMatrix, matrix);
  }
  /**
   * Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array
   * @param matrix defines the matrix to use
   * @returns a new Float32Array array with 4 elements : the 2x2 matrix extracted from the given matrix
   */
  static GetAsMatrix2x2(matrix) {
    const m = matrix.m;
    const arr = [m[0], m[1], m[4], m[5]];
    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
  }
  /**
   * Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array
   * @param matrix defines the matrix to use
   * @returns a new Float32Array array with 9 elements : the 3x3 matrix extracted from the given matrix
   */
  static GetAsMatrix3x3(matrix) {
    const m = matrix.m;
    const arr = [m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10]];
    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
  }
  /**
   * Compute the transpose of a given matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#111
   * @param matrix defines the matrix to transpose
   * @returns the new matrix
   */
  static Transpose(matrix) {
    const result = new matrix.constructor();
    _Matrix.TransposeToRef(matrix, result);
    return result;
  }
  /**
   * Compute the transpose of a matrix and store it in a target matrix
   * Example Playground - https://playground.babylonjs.com/#AV9X17#112
   * @param matrix defines the matrix to transpose
   * @param result defines the target matrix
   * @returns result input
   */
  static TransposeToRef(matrix, result) {
    const mm = matrix.m;
    const rm0 = mm[0];
    const rm1 = mm[4];
    const rm2 = mm[8];
    const rm3 = mm[12];
    const rm4 = mm[1];
    const rm5 = mm[5];
    const rm6 = mm[9];
    const rm7 = mm[13];
    const rm8 = mm[2];
    const rm9 = mm[6];
    const rm10 = mm[10];
    const rm11 = mm[14];
    const rm12 = mm[3];
    const rm13 = mm[7];
    const rm14 = mm[11];
    const rm15 = mm[15];
    const rm = result._m;
    rm[0] = rm0;
    rm[1] = rm1;
    rm[2] = rm2;
    rm[3] = rm3;
    rm[4] = rm4;
    rm[5] = rm5;
    rm[6] = rm6;
    rm[7] = rm7;
    rm[8] = rm8;
    rm[9] = rm9;
    rm[10] = rm10;
    rm[11] = rm11;
    rm[12] = rm12;
    rm[13] = rm13;
    rm[14] = rm14;
    rm[15] = rm15;
    result.markAsUpdated();
    result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);
    return result;
  }
  /**
   * Computes a reflection matrix from a plane
   * Example Playground - https://playground.babylonjs.com/#AV9X17#87
   * @param plane defines the reflection plane
   * @returns a new matrix
   */
  static Reflection(plane) {
    const matrix = new _Matrix();
    _Matrix.ReflectionToRef(plane, matrix);
    return matrix;
  }
  /**
   * Computes a reflection matrix from a plane
   * Example Playground - https://playground.babylonjs.com/#AV9X17#88
   * @param plane defines the reflection plane
   * @param result defines the target matrix
   * @returns result input
   */
  static ReflectionToRef(plane, result) {
    plane.normalize();
    const x = plane.normal.x;
    const y = plane.normal.y;
    const z = plane.normal.z;
    const temp = -2 * x;
    const temp2 = -2 * y;
    const temp3 = -2 * z;
    _Matrix.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0, temp * y, temp2 * y + 1, temp3 * y, 0, temp * z, temp2 * z, temp3 * z + 1, 0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1, result);
    return result;
  }
  /**
   * Sets the given matrix as a rotation matrix composed from the 3 left handed axes
   * @param xaxis defines the value of the 1st axis
   * @param yaxis defines the value of the 2nd axis
   * @param zaxis defines the value of the 3rd axis
   * @param result defines the target matrix
   * @returns result input
   */
  static FromXYZAxesToRef(xaxis, yaxis, zaxis, result) {
    _Matrix.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0, yaxis._x, yaxis._y, yaxis._z, 0, zaxis._x, zaxis._y, zaxis._z, 0, 0, 0, 0, 1, result);
    return result;
  }
  /**
   * Creates a rotation matrix from a quaternion and stores it in a target matrix
   * @param quat defines the quaternion to use
   * @param result defines the target matrix
   * @returns result input
   */
  static FromQuaternionToRef(quat, result) {
    const xx = quat._x * quat._x;
    const yy = quat._y * quat._y;
    const zz = quat._z * quat._z;
    const xy = quat._x * quat._y;
    const zw = quat._z * quat._w;
    const zx = quat._z * quat._x;
    const yw = quat._y * quat._w;
    const yz = quat._y * quat._z;
    const xw = quat._x * quat._w;
    result._m[0] = 1 - 2 * (yy + zz);
    result._m[1] = 2 * (xy + zw);
    result._m[2] = 2 * (zx - yw);
    result._m[3] = 0;
    result._m[4] = 2 * (xy - zw);
    result._m[5] = 1 - 2 * (zz + xx);
    result._m[6] = 2 * (yz + xw);
    result._m[7] = 0;
    result._m[8] = 2 * (zx + yw);
    result._m[9] = 2 * (yz - xw);
    result._m[10] = 1 - 2 * (yy + xx);
    result._m[11] = 0;
    result._m[12] = 0;
    result._m[13] = 0;
    result._m[14] = 0;
    result._m[15] = 1;
    result.markAsUpdated();
    return result;
  }
};
Matrix._UpdateFlagSeed = 0;
Matrix._IdentityReadOnly = Matrix.Identity();
var MathTmp = class {
};
MathTmp.Vector3 = ArrayTools.BuildTuple(11, Vector3.Zero);
MathTmp.Matrix = ArrayTools.BuildTuple(2, Matrix.Identity);
MathTmp.Quaternion = ArrayTools.BuildTuple(3, Quaternion.Zero);
var TmpVectors = class {
};
TmpVectors.Vector2 = ArrayTools.BuildTuple(3, Vector2.Zero);
TmpVectors.Vector3 = ArrayTools.BuildTuple(13, Vector3.Zero);
TmpVectors.Vector4 = ArrayTools.BuildTuple(3, Vector4.Zero);
TmpVectors.Quaternion = ArrayTools.BuildTuple(2, Quaternion.Zero);
TmpVectors.Matrix = ArrayTools.BuildTuple(8, Matrix.Identity);
RegisterClass("BABYLON.Vector2", Vector2);
RegisterClass("BABYLON.Vector3", Vector3);
RegisterClass("BABYLON.Vector4", Vector4);
RegisterClass("BABYLON.Matrix", Matrix);
var mtxConvertNDCToHalfZRange = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);

// node_modules/@babylonjs/core/Maths/math.color.js
function colorChannelToLinearSpace(color) {
  return Math.pow(color, ToLinearSpace);
}
function colorChannelToLinearSpaceExact(color) {
  if (color <= 0.04045) {
    return 0.0773993808 * color;
  }
  return Math.pow(0.947867299 * (color + 0.055), 2.4);
}
function colorChannelToGammaSpace(color) {
  return Math.pow(color, ToGammaSpace);
}
function colorChannelToGammaSpaceExact(color) {
  if (color <= 31308e-7) {
    return 12.92 * color;
  }
  return 1.055 * Math.pow(color, 0.41666) - 0.055;
}
var Color3 = class _Color3 {
  /**
   * Creates a new Color3 object from red, green, blue values, all between 0 and 1
   * @param r defines the red component (between 0 and 1, default is 0)
   * @param g defines the green component (between 0 and 1, default is 0)
   * @param b defines the blue component (between 0 and 1, default is 0)
   */
  constructor(r = 0, g = 0, b = 0) {
    this.r = r;
    this.g = g;
    this.b = b;
  }
  /**
   * Creates a string with the Color3 current values
   * @returns the string representation of the Color3 object
   */
  toString() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}";
  }
  /**
   * Returns the string "Color3"
   * @returns "Color3"
   */
  getClassName() {
    return "Color3";
  }
  /**
   * Compute the Color3 hash code
   * @returns an unique number that can be used to hash Color3 objects
   */
  getHashCode() {
    let hash = this.r * 255 | 0;
    hash = hash * 397 ^ (this.g * 255 | 0);
    hash = hash * 397 ^ (this.b * 255 | 0);
    return hash;
  }
  // Operators
  /**
   * Stores in the given array from the given starting index the red, green, blue values as successive elements
   * @param array defines the array where to store the r,g,b components
   * @param index defines an optional index in the target array to define where to start storing values
   * @returns the current Color3 object
   */
  toArray(array, index = 0) {
    array[index] = this.r;
    array[index + 1] = this.g;
    array[index + 2] = this.b;
    return this;
  }
  /**
   * Update the current color with values stored in an array from the starting index of the given array
   * @param array defines the source array
   * @param offset defines an offset in the source array
   * @returns the current Color3 object
   */
  fromArray(array, offset = 0) {
    _Color3.FromArrayToRef(array, offset, this);
    return this;
  }
  /**
   * Returns a new Color4 object from the current Color3 and the given alpha
   * @param alpha defines the alpha component on the new Color4 object (default is 1)
   * @returns a new Color4 object
   */
  toColor4(alpha = 1) {
    return new Color4(this.r, this.g, this.b, alpha);
  }
  /**
   * Returns a new array populated with 3 numeric elements : red, green and blue values
   * @returns the new array
   */
  asArray() {
    return [this.r, this.g, this.b];
  }
  /**
   * Returns the luminance value
   * @returns a float value
   */
  toLuminance() {
    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
  }
  /**
   * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object
   * @param otherColor defines the second operand
   * @returns the new Color3 object
   */
  multiply(otherColor) {
    return new _Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);
  }
  /**
   * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object "result"
   * @param otherColor defines the second operand
   * @param result defines the Color3 object where to store the result
   * @returns the current Color3
   */
  multiplyToRef(otherColor, result) {
    result.r = this.r * otherColor.r;
    result.g = this.g * otherColor.g;
    result.b = this.b * otherColor.b;
    return this;
  }
  /**
   * Determines equality between Color3 objects
   * @param otherColor defines the second operand
   * @returns true if the rgb values are equal to the given ones
   */
  equals(otherColor) {
    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;
  }
  /**
   * Determines equality between the current Color3 object and a set of r,b,g values
   * @param r defines the red component to check
   * @param g defines the green component to check
   * @param b defines the blue component to check
   * @returns true if the rgb values are equal to the given ones
   */
  equalsFloats(r, g, b) {
    return this.r === r && this.g === g && this.b === b;
  }
  /**
   * Creates a new Color3 with the current Color3 values multiplied by scale
   * @param scale defines the scaling factor to apply
   * @returns a new Color3 object
   */
  scale(scale) {
    return new _Color3(this.r * scale, this.g * scale, this.b * scale);
  }
  /**
   * Multiplies the Color3 values by the float "scale"
   * @param scale defines the scaling factor to apply
   * @returns the current updated Color3
   */
  scaleInPlace(scale) {
    this.r *= scale;
    this.g *= scale;
    this.b *= scale;
    return this;
  }
  /**
   * Multiplies the rgb values by scale and stores the result into "result"
   * @param scale defines the scaling factor
   * @param result defines the Color3 object where to store the result
   * @returns the unmodified current Color3
   */
  scaleToRef(scale, result) {
    result.r = this.r * scale;
    result.g = this.g * scale;
    result.b = this.b * scale;
    return this;
  }
  /**
   * Scale the current Color3 values by a factor and add the result to a given Color3
   * @param scale defines the scale factor
   * @param result defines color to store the result into
   * @returns the unmodified current Color3
   */
  scaleAndAddToRef(scale, result) {
    result.r += this.r * scale;
    result.g += this.g * scale;
    result.b += this.b * scale;
    return this;
  }
  /**
   * Clamps the rgb values by the min and max values and stores the result into "result"
   * @param min defines minimum clamping value (default is 0)
   * @param max defines maximum clamping value (default is 1)
   * @param result defines color to store the result into
   * @returns the original Color3
   */
  clampToRef(min = 0, max = 1, result) {
    result.r = Scalar.Clamp(this.r, min, max);
    result.g = Scalar.Clamp(this.g, min, max);
    result.b = Scalar.Clamp(this.b, min, max);
    return this;
  }
  /**
   * Creates a new Color3 set with the added values of the current Color3 and of the given one
   * @param otherColor defines the second operand
   * @returns the new Color3
   */
  add(otherColor) {
    return new _Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);
  }
  /**
   * Stores the result of the addition of the current Color3 and given one rgb values into "result"
   * @param otherColor defines the second operand
   * @param result defines Color3 object to store the result into
   * @returns the unmodified current Color3
   */
  addToRef(otherColor, result) {
    result.r = this.r + otherColor.r;
    result.g = this.g + otherColor.g;
    result.b = this.b + otherColor.b;
    return this;
  }
  /**
   * Returns a new Color3 set with the subtracted values of the given one from the current Color3
   * @param otherColor defines the second operand
   * @returns the new Color3
   */
  subtract(otherColor) {
    return new _Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);
  }
  /**
   * Stores the result of the subtraction of given one from the current Color3 rgb values into "result"
   * @param otherColor defines the second operand
   * @param result defines Color3 object to store the result into
   * @returns the unmodified current Color3
   */
  subtractToRef(otherColor, result) {
    result.r = this.r - otherColor.r;
    result.g = this.g - otherColor.g;
    result.b = this.b - otherColor.b;
    return this;
  }
  /**
   * Copy the current object
   * @returns a new Color3 copied the current one
   */
  clone() {
    return new _Color3(this.r, this.g, this.b);
  }
  /**
   * Copies the rgb values from the source in the current Color3
   * @param source defines the source Color3 object
   * @returns the updated Color3 object
   */
  copyFrom(source) {
    this.r = source.r;
    this.g = source.g;
    this.b = source.b;
    return this;
  }
  /**
   * Updates the Color3 rgb values from the given floats
   * @param r defines the red component to read from
   * @param g defines the green component to read from
   * @param b defines the blue component to read from
   * @returns the current Color3 object
   */
  copyFromFloats(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  }
  /**
   * Updates the Color3 rgb values from the given floats
   * @param r defines the red component to read from
   * @param g defines the green component to read from
   * @param b defines the blue component to read from
   * @returns the current Color3 object
   */
  set(r, g, b) {
    return this.copyFromFloats(r, g, b);
  }
  /**
   * Compute the Color3 hexadecimal code as a string
   * @returns a string containing the hexadecimal representation of the Color3 object
   */
  toHexString() {
    const intR = Math.round(this.r * 255);
    const intG = Math.round(this.g * 255);
    const intB = Math.round(this.b * 255);
    return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
  }
  /**
   * Converts current color in rgb space to HSV values
   * @returns a new color3 representing the HSV values
   */
  toHSV() {
    const result = new _Color3();
    this.toHSVToRef(result);
    return result;
  }
  /**
   * Converts current color in rgb space to HSV values
   * @param result defines the Color3 where to store the HSV values
   */
  toHSVToRef(result) {
    const r = this.r;
    const g = this.g;
    const b = this.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let h = 0;
    let s = 0;
    const v = max;
    const dm = max - min;
    if (max !== 0) {
      s = dm / max;
    }
    if (max != min) {
      if (max == r) {
        h = (g - b) / dm;
        if (g < b) {
          h += 6;
        }
      } else if (max == g) {
        h = (b - r) / dm + 2;
      } else if (max == b) {
        h = (r - g) / dm + 4;
      }
      h *= 60;
    }
    result.r = h;
    result.g = s;
    result.b = v;
  }
  /**
   * Computes a new Color3 converted from the current one to linear space
   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)
   * @returns a new Color3 object
   */
  toLinearSpace(exact = false) {
    const convertedColor = new _Color3();
    this.toLinearSpaceToRef(convertedColor, exact);
    return convertedColor;
  }
  /**
   * Converts the Color3 values to linear space and stores the result in "convertedColor"
   * @param convertedColor defines the Color3 object where to store the linear space version
   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)
   * @returns the unmodified Color3
   */
  toLinearSpaceToRef(convertedColor, exact = false) {
    if (exact) {
      convertedColor.r = colorChannelToLinearSpaceExact(this.r);
      convertedColor.g = colorChannelToLinearSpaceExact(this.g);
      convertedColor.b = colorChannelToLinearSpaceExact(this.b);
    } else {
      convertedColor.r = colorChannelToLinearSpace(this.r);
      convertedColor.g = colorChannelToLinearSpace(this.g);
      convertedColor.b = colorChannelToLinearSpace(this.b);
    }
    return this;
  }
  /**
   * Computes a new Color3 converted from the current one to gamma space
   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)
   * @returns a new Color3 object
   */
  toGammaSpace(exact = false) {
    const convertedColor = new _Color3();
    this.toGammaSpaceToRef(convertedColor, exact);
    return convertedColor;
  }
  /**
   * Converts the Color3 values to gamma space and stores the result in "convertedColor"
   * @param convertedColor defines the Color3 object where to store the gamma space version
   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)
   * @returns the unmodified Color3
   */
  toGammaSpaceToRef(convertedColor, exact = false) {
    if (exact) {
      convertedColor.r = colorChannelToGammaSpaceExact(this.r);
      convertedColor.g = colorChannelToGammaSpaceExact(this.g);
      convertedColor.b = colorChannelToGammaSpaceExact(this.b);
    } else {
      convertedColor.r = colorChannelToGammaSpace(this.r);
      convertedColor.g = colorChannelToGammaSpace(this.g);
      convertedColor.b = colorChannelToGammaSpace(this.b);
    }
    return this;
  }
  /**
   * Converts Hue, saturation and value to a Color3 (RGB)
   * @param hue defines the hue (value between 0 and 360)
   * @param saturation defines the saturation (value between 0 and 1)
   * @param value defines the value (value between 0 and 1)
   * @param result defines the Color3 where to store the RGB values
   */
  static HSVtoRGBToRef(hue, saturation, value, result) {
    const chroma = value * saturation;
    const h = hue / 60;
    const x = chroma * (1 - Math.abs(h % 2 - 1));
    let r = 0;
    let g = 0;
    let b = 0;
    if (h >= 0 && h <= 1) {
      r = chroma;
      g = x;
    } else if (h >= 1 && h <= 2) {
      r = x;
      g = chroma;
    } else if (h >= 2 && h <= 3) {
      g = chroma;
      b = x;
    } else if (h >= 3 && h <= 4) {
      g = x;
      b = chroma;
    } else if (h >= 4 && h <= 5) {
      r = x;
      b = chroma;
    } else if (h >= 5 && h <= 6) {
      r = chroma;
      b = x;
    }
    const m = value - chroma;
    result.set(r + m, g + m, b + m);
  }
  /**
   * Converts Hue, saturation and value to a new Color3 (RGB)
   * @param hue defines the hue (value between 0 and 360)
   * @param saturation defines the saturation (value between 0 and 1)
   * @param value defines the value (value between 0 and 1)
   * @returns a new Color3 object
   */
  static FromHSV(hue, saturation, value) {
    const result = new _Color3(0, 0, 0);
    _Color3.HSVtoRGBToRef(hue, saturation, value, result);
    return result;
  }
  /**
   * Creates a new Color3 from the string containing valid hexadecimal values
   * @param hex defines a string containing valid hexadecimal values
   * @returns a new Color3 object
   */
  static FromHexString(hex) {
    if (hex.substring(0, 1) !== "#" || hex.length !== 7) {
      return new _Color3(0, 0, 0);
    }
    const r = parseInt(hex.substring(1, 3), 16);
    const g = parseInt(hex.substring(3, 5), 16);
    const b = parseInt(hex.substring(5, 7), 16);
    return _Color3.FromInts(r, g, b);
  }
  /**
   * Creates a new Color3 from the starting index of the given array
   * @param array defines the source array
   * @param offset defines an offset in the source array
   * @returns a new Color3 object
   */
  static FromArray(array, offset = 0) {
    return new _Color3(array[offset], array[offset + 1], array[offset + 2]);
  }
  /**
   * Creates a new Color3 from the starting index element of the given array
   * @param array defines the source array to read from
   * @param offset defines the offset in the source array
   * @param result defines the target Color3 object
   */
  static FromArrayToRef(array, offset = 0, result) {
    result.r = array[offset];
    result.g = array[offset + 1];
    result.b = array[offset + 2];
  }
  /**
   * Creates a new Color3 from integer values (< 256)
   * @param r defines the red component to read from (value between 0 and 255)
   * @param g defines the green component to read from (value between 0 and 255)
   * @param b defines the blue component to read from (value between 0 and 255)
   * @returns a new Color3 object
   */
  static FromInts(r, g, b) {
    return new _Color3(r / 255, g / 255, b / 255);
  }
  /**
   * Creates a new Color3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
   * @param start defines the start Color3 value
   * @param end defines the end Color3 value
   * @param amount defines the gradient value between start and end
   * @returns a new Color3 object
   */
  static Lerp(start, end, amount) {
    const result = new _Color3(0, 0, 0);
    _Color3.LerpToRef(start, end, amount, result);
    return result;
  }
  /**
   * Creates a new Color3 with values linearly interpolated of "amount" between the start Color3 and the end Color3
   * @param left defines the start value
   * @param right defines the end value
   * @param amount defines the gradient factor
   * @param result defines the Color3 object where to store the result
   */
  static LerpToRef(left, right, amount, result) {
    result.r = left.r + (right.r - left.r) * amount;
    result.g = left.g + (right.g - left.g) * amount;
    result.b = left.b + (right.b - left.b) * amount;
  }
  /**
   * Returns a new Color3 located for "amount" (float) on the Hermite interpolation spline defined by the vectors "value1", "tangent1", "value2", "tangent2"
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent Color3
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent Color3
   * @param amount defines the amount on the interpolation spline (between 0 and 1)
   * @returns the new Color3
   */
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
    const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
    const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
    return new _Color3(r, g, b);
  }
  /**
   * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors "value1", "value2", "tangent1", "tangent2".
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @returns 1st derivative
   */
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const result = _Color3.Black();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  }
  /**
   * Returns a new Color3 which is the 1st derivative of the Hermite spline defined by the colors "value1", "value2", "tangent1", "tangent2".
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @param result define where to store the derivative
   */
  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
    const t2 = time * time;
    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
  }
  /**
   * Returns a Color3 value containing a red color
   * @returns a new Color3 object
   */
  static Red() {
    return new _Color3(1, 0, 0);
  }
  /**
   * Returns a Color3 value containing a green color
   * @returns a new Color3 object
   */
  static Green() {
    return new _Color3(0, 1, 0);
  }
  /**
   * Returns a Color3 value containing a blue color
   * @returns a new Color3 object
   */
  static Blue() {
    return new _Color3(0, 0, 1);
  }
  /**
   * Returns a Color3 value containing a black color
   * @returns a new Color3 object
   */
  static Black() {
    return new _Color3(0, 0, 0);
  }
  /**
   * Gets a Color3 value containing a black color that must not be updated
   */
  static get BlackReadOnly() {
    return _Color3._BlackReadOnly;
  }
  /**
   * Returns a Color3 value containing a white color
   * @returns a new Color3 object
   */
  static White() {
    return new _Color3(1, 1, 1);
  }
  /**
   * Returns a Color3 value containing a purple color
   * @returns a new Color3 object
   */
  static Purple() {
    return new _Color3(0.5, 0, 0.5);
  }
  /**
   * Returns a Color3 value containing a magenta color
   * @returns a new Color3 object
   */
  static Magenta() {
    return new _Color3(1, 0, 1);
  }
  /**
   * Returns a Color3 value containing a yellow color
   * @returns a new Color3 object
   */
  static Yellow() {
    return new _Color3(1, 1, 0);
  }
  /**
   * Returns a Color3 value containing a gray color
   * @returns a new Color3 object
   */
  static Gray() {
    return new _Color3(0.5, 0.5, 0.5);
  }
  /**
   * Returns a Color3 value containing a teal color
   * @returns a new Color3 object
   */
  static Teal() {
    return new _Color3(0, 1, 1);
  }
  /**
   * Returns a Color3 value containing a random color
   * @returns a new Color3 object
   */
  static Random() {
    return new _Color3(Math.random(), Math.random(), Math.random());
  }
};
Color3._BlackReadOnly = Color3.Black();
var Color4 = class _Color4 {
  /**
   * Creates a new Color4 object from red, green, blue values, all between 0 and 1
   * @param r defines the red component (between 0 and 1, default is 0)
   * @param g defines the green component (between 0 and 1, default is 0)
   * @param b defines the blue component (between 0 and 1, default is 0)
   * @param a defines the alpha component (between 0 and 1, default is 1)
   */
  constructor(r = 0, g = 0, b = 0, a = 1) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  // Operators
  /**
   * Adds in place the given Color4 values to the current Color4 object
   * @param right defines the second operand
   * @returns the current updated Color4 object
   */
  addInPlace(right) {
    this.r += right.r;
    this.g += right.g;
    this.b += right.b;
    this.a += right.a;
    return this;
  }
  /**
   * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values
   * @returns the new array
   */
  asArray() {
    return [this.r, this.g, this.b, this.a];
  }
  /**
   * Stores from the starting index in the given array the Color4 successive values
   * @param array defines the array where to store the r,g,b components
   * @param index defines an optional index in the target array to define where to start storing values
   * @returns the current Color4 object
   */
  toArray(array, index = 0) {
    array[index] = this.r;
    array[index + 1] = this.g;
    array[index + 2] = this.b;
    array[index + 3] = this.a;
    return this;
  }
  /**
   * Update the current color with values stored in an array from the starting index of the given array
   * @param array defines the source array
   * @param offset defines an offset in the source array
   * @returns the current Color4 object
   */
  fromArray(array, offset = 0) {
    _Color4.FromArrayToRef(array, offset, this);
    return this;
  }
  /**
   * Determines equality between Color4 objects
   * @param otherColor defines the second operand
   * @returns true if the rgba values are equal to the given ones
   */
  equals(otherColor) {
    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;
  }
  /**
   * Creates a new Color4 set with the added values of the current Color4 and of the given one
   * @param right defines the second operand
   * @returns a new Color4 object
   */
  add(right) {
    return new _Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);
  }
  /**
   * Creates a new Color4 set with the subtracted values of the given one from the current Color4
   * @param right defines the second operand
   * @returns a new Color4 object
   */
  subtract(right) {
    return new _Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);
  }
  /**
   * Subtracts the given ones from the current Color4 values and stores the results in "result"
   * @param right defines the second operand
   * @param result defines the Color4 object where to store the result
   * @returns the current Color4 object
   */
  subtractToRef(right, result) {
    result.r = this.r - right.r;
    result.g = this.g - right.g;
    result.b = this.b - right.b;
    result.a = this.a - right.a;
    return this;
  }
  /**
   * Creates a new Color4 with the current Color4 values multiplied by scale
   * @param scale defines the scaling factor to apply
   * @returns a new Color4 object
   */
  scale(scale) {
    return new _Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);
  }
  /**
   * Multiplies the Color4 values by the float "scale"
   * @param scale defines the scaling factor to apply
   * @returns the current updated Color4
   */
  scaleInPlace(scale) {
    this.r *= scale;
    this.g *= scale;
    this.b *= scale;
    this.a *= scale;
    return this;
  }
  /**
   * Multiplies the current Color4 values by scale and stores the result in "result"
   * @param scale defines the scaling factor to apply
   * @param result defines the Color4 object where to store the result
   * @returns the current unmodified Color4
   */
  scaleToRef(scale, result) {
    result.r = this.r * scale;
    result.g = this.g * scale;
    result.b = this.b * scale;
    result.a = this.a * scale;
    return this;
  }
  /**
   * Scale the current Color4 values by a factor and add the result to a given Color4
   * @param scale defines the scale factor
   * @param result defines the Color4 object where to store the result
   * @returns the unmodified current Color4
   */
  scaleAndAddToRef(scale, result) {
    result.r += this.r * scale;
    result.g += this.g * scale;
    result.b += this.b * scale;
    result.a += this.a * scale;
    return this;
  }
  /**
   * Clamps the rgb values by the min and max values and stores the result into "result"
   * @param min defines minimum clamping value (default is 0)
   * @param max defines maximum clamping value (default is 1)
   * @param result defines color to store the result into.
   * @returns the current Color4
   */
  clampToRef(min = 0, max = 1, result) {
    result.r = Scalar.Clamp(this.r, min, max);
    result.g = Scalar.Clamp(this.g, min, max);
    result.b = Scalar.Clamp(this.b, min, max);
    result.a = Scalar.Clamp(this.a, min, max);
    return this;
  }
  /**
   * Multiply an Color4 value by another and return a new Color4 object
   * @param color defines the Color4 value to multiply by
   * @returns a new Color4 object
   */
  multiply(color) {
    return new _Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);
  }
  /**
   * Multiply a Color4 value by another and push the result in a reference value
   * @param color defines the Color4 value to multiply by
   * @param result defines the Color4 to fill the result in
   * @returns the result Color4
   */
  multiplyToRef(color, result) {
    result.r = this.r * color.r;
    result.g = this.g * color.g;
    result.b = this.b * color.b;
    result.a = this.a * color.a;
    return result;
  }
  /**
   * Creates a string with the Color4 current values
   * @returns the string representation of the Color4 object
   */
  toString() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}";
  }
  /**
   * Returns the string "Color4"
   * @returns "Color4"
   */
  getClassName() {
    return "Color4";
  }
  /**
   * Compute the Color4 hash code
   * @returns an unique number that can be used to hash Color4 objects
   */
  getHashCode() {
    let hash = this.r * 255 | 0;
    hash = hash * 397 ^ (this.g * 255 | 0);
    hash = hash * 397 ^ (this.b * 255 | 0);
    hash = hash * 397 ^ (this.a * 255 | 0);
    return hash;
  }
  /**
   * Creates a new Color4 copied from the current one
   * @returns a new Color4 object
   */
  clone() {
    return new _Color4(this.r, this.g, this.b, this.a);
  }
  /**
   * Copies the given Color4 values into the current one
   * @param source defines the source Color4 object
   * @returns the current updated Color4 object
   */
  copyFrom(source) {
    this.r = source.r;
    this.g = source.g;
    this.b = source.b;
    this.a = source.a;
    return this;
  }
  /**
   * Copies the given float values into the current one
   * @param r defines the red component to read from
   * @param g defines the green component to read from
   * @param b defines the blue component to read from
   * @param a defines the alpha component to read from
   * @returns the current updated Color4 object
   */
  copyFromFloats(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this;
  }
  /**
   * Copies the given float values into the current one
   * @param r defines the red component to read from
   * @param g defines the green component to read from
   * @param b defines the blue component to read from
   * @param a defines the alpha component to read from
   * @returns the current updated Color4 object
   */
  set(r, g, b, a) {
    return this.copyFromFloats(r, g, b, a);
  }
  /**
   * Compute the Color4 hexadecimal code as a string
   * @param returnAsColor3 defines if the string should only contains RGB values (off by default)
   * @returns a string containing the hexadecimal representation of the Color4 object
   */
  toHexString(returnAsColor3 = false) {
    const intR = Math.round(this.r * 255);
    const intG = Math.round(this.g * 255);
    const intB = Math.round(this.b * 255);
    if (returnAsColor3) {
      return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
    }
    const intA = Math.round(this.a * 255);
    return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);
  }
  /**
   * Computes a new Color4 converted from the current one to linear space
   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)
   * @returns a new Color4 object
   */
  toLinearSpace(exact = false) {
    const convertedColor = new _Color4();
    this.toLinearSpaceToRef(convertedColor, exact);
    return convertedColor;
  }
  /**
   * Converts the Color4 values to linear space and stores the result in "convertedColor"
   * @param convertedColor defines the Color4 object where to store the linear space version
   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)
   * @returns the unmodified Color4
   */
  toLinearSpaceToRef(convertedColor, exact = false) {
    if (exact) {
      convertedColor.r = colorChannelToLinearSpaceExact(this.r);
      convertedColor.g = colorChannelToLinearSpaceExact(this.g);
      convertedColor.b = colorChannelToLinearSpaceExact(this.b);
    } else {
      convertedColor.r = colorChannelToLinearSpace(this.r);
      convertedColor.g = colorChannelToLinearSpace(this.g);
      convertedColor.b = colorChannelToLinearSpace(this.b);
    }
    convertedColor.a = this.a;
    return this;
  }
  /**
   * Computes a new Color4 converted from the current one to gamma space
   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)
   * @returns a new Color4 object
   */
  toGammaSpace(exact = false) {
    const convertedColor = new _Color4();
    this.toGammaSpaceToRef(convertedColor, exact);
    return convertedColor;
  }
  /**
   * Converts the Color4 values to gamma space and stores the result in "convertedColor"
   * @param convertedColor defines the Color4 object where to store the gamma space version
   * @param exact defines if the conversion will be done in an exact way which is slower but more accurate (default is false)
   * @returns the unmodified Color4
   */
  toGammaSpaceToRef(convertedColor, exact = false) {
    if (exact) {
      convertedColor.r = colorChannelToGammaSpaceExact(this.r);
      convertedColor.g = colorChannelToGammaSpaceExact(this.g);
      convertedColor.b = colorChannelToGammaSpaceExact(this.b);
    } else {
      convertedColor.r = colorChannelToGammaSpace(this.r);
      convertedColor.g = colorChannelToGammaSpace(this.g);
      convertedColor.b = colorChannelToGammaSpace(this.b);
    }
    convertedColor.a = this.a;
    return this;
  }
  // Statics
  /**
   * Creates a new Color4 from the string containing valid hexadecimal values.
   *
   * A valid hex string is either in the format #RRGGBB or #RRGGBBAA.
   *
   * When a hex string without alpha is passed, the resulting Color4 has
   * its alpha value set to 1.0.
   *
   * An invalid string results in a Color with all its channels set to 0.0,
   * i.e. "transparent black".
   *
   * @param hex defines a string containing valid hexadecimal values
   * @returns a new Color4 object
   */
  static FromHexString(hex) {
    if (hex.substring(0, 1) !== "#" || hex.length !== 9 && hex.length !== 7) {
      return new _Color4(0, 0, 0, 0);
    }
    const r = parseInt(hex.substring(1, 3), 16);
    const g = parseInt(hex.substring(3, 5), 16);
    const b = parseInt(hex.substring(5, 7), 16);
    const a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;
    return _Color4.FromInts(r, g, b, a);
  }
  /**
   * Creates a new Color4 object set with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
   * @param left defines the start value
   * @param right defines the end value
   * @param amount defines the gradient factor
   * @returns a new Color4 object
   */
  static Lerp(left, right, amount) {
    const result = new _Color4(0, 0, 0, 0);
    _Color4.LerpToRef(left, right, amount, result);
    return result;
  }
  /**
   * Set the given "result" with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object
   * @param left defines the start value
   * @param right defines the end value
   * @param amount defines the gradient factor
   * @param result defines the Color4 object where to store data
   */
  static LerpToRef(left, right, amount, result) {
    result.r = left.r + (right.r - left.r) * amount;
    result.g = left.g + (right.g - left.g) * amount;
    result.b = left.b + (right.b - left.b) * amount;
    result.a = left.a + (right.a - left.a) * amount;
  }
  /**
   * Interpolate between two Color4 using Hermite interpolation
   * @param value1 defines first Color4
   * @param tangent1 defines the incoming tangent
   * @param value2 defines second Color4
   * @param tangent2 defines the outgoing tangent
   * @param amount defines the target Color4
   * @returns the new interpolated Color4
   */
  static Hermite(value1, tangent1, value2, tangent2, amount) {
    const squared = amount * amount;
    const cubed = amount * squared;
    const part1 = 2 * cubed - 3 * squared + 1;
    const part2 = -2 * cubed + 3 * squared;
    const part3 = cubed - 2 * squared + amount;
    const part4 = cubed - squared;
    const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
    const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
    const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
    const a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;
    return new _Color4(r, g, b, a);
  }
  /**
   * Returns a new Color4 which is the 1st derivative of the Hermite spline defined by the colors "value1", "value2", "tangent1", "tangent2".
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @returns 1st derivative
   */
  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
    const result = new _Color4();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  }
  /**
   * Update a Color4 with the 1st derivative of the Hermite spline defined by the colors "value1", "value2", "tangent1", "tangent2".
   * @param value1 defines the first control point
   * @param tangent1 defines the first tangent
   * @param value2 defines the second control point
   * @param tangent2 defines the second tangent
   * @param time define where the derivative must be done
   * @param result define where to store the derivative
   */
  static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
    const t2 = time * time;
    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
    result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;
  }
  /**
   * Creates a new Color4 from a Color3 and an alpha value
   * @param color3 defines the source Color3 to read from
   * @param alpha defines the alpha component (1.0 by default)
   * @returns a new Color4 object
   */
  static FromColor3(color3, alpha = 1) {
    return new _Color4(color3.r, color3.g, color3.b, alpha);
  }
  /**
   * Creates a new Color4 from the starting index element of the given array
   * @param array defines the source array to read from
   * @param offset defines the offset in the source array
   * @returns a new Color4 object
   */
  static FromArray(array, offset = 0) {
    return new _Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  }
  /**
   * Creates a new Color4 from the starting index element of the given array
   * @param array defines the source array to read from
   * @param offset defines the offset in the source array
   * @param result defines the target Color4 object
   */
  static FromArrayToRef(array, offset = 0, result) {
    result.r = array[offset];
    result.g = array[offset + 1];
    result.b = array[offset + 2];
    result.a = array[offset + 3];
  }
  /**
   * Creates a new Color3 from integer values (< 256)
   * @param r defines the red component to read from (value between 0 and 255)
   * @param g defines the green component to read from (value between 0 and 255)
   * @param b defines the blue component to read from (value between 0 and 255)
   * @param a defines the alpha component to read from (value between 0 and 255)
   * @returns a new Color3 object
   */
  static FromInts(r, g, b, a) {
    return new _Color4(r / 255, g / 255, b / 255, a / 255);
  }
  /**
   * Check the content of a given array and convert it to an array containing RGBA data
   * If the original array was already containing count * 4 values then it is returned directly
   * @param colors defines the array to check
   * @param count defines the number of RGBA data to expect
   * @returns an array containing count * 4 values (RGBA)
   */
  static CheckColors4(colors, count) {
    if (colors.length === count * 3) {
      const colors4 = [];
      for (let index = 0; index < colors.length; index += 3) {
        const newIndex = index / 3 * 4;
        colors4[newIndex] = colors[index];
        colors4[newIndex + 1] = colors[index + 1];
        colors4[newIndex + 2] = colors[index + 2];
        colors4[newIndex + 3] = 1;
      }
      return colors4;
    }
    return colors;
  }
};
var TmpColors = class {
};
TmpColors.Color3 = ArrayTools.BuildArray(3, Color3.Black);
TmpColors.Color4 = ArrayTools.BuildArray(3, () => new Color4(0, 0, 0, 0));
RegisterClass("BABYLON.Color3", Color3);
RegisterClass("BABYLON.Color4", Color4);

// node_modules/@babylonjs/core/Misc/devTools.js
var warnedMap = {};
function _WarnImport(name, warnOnce = false) {
  if (warnOnce && warnedMap[name]) {
    return;
  }
  warnedMap[name] = true;
  return `${name} needs to be imported before as it contains a side-effect required by your code.`;
}

// node_modules/@babylonjs/core/Misc/decorators.js
var __decoratorInitialStore = {};
var __mergedStore = {};
var _copySource = function(creationFunction, source, instanciate, options = {}) {
  const destination = creationFunction();
  if (Tags && Tags.HasTags(source)) {
    Tags.AddTagsTo(destination, Tags.GetTags(source, true));
  }
  const classStore = getMergedStore(destination);
  const textureMap = {};
  for (const property in classStore) {
    const propertyDescriptor = classStore[property];
    const sourceProperty = source[property];
    const propertyType = propertyDescriptor.type;
    if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
      switch (propertyType) {
        case 0:
        case 6:
        case 11:
          destination[property] = sourceProperty;
          break;
        case 1:
          if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {
            destination[property] = textureMap[sourceProperty.uniqueId];
          } else {
            destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();
            textureMap[sourceProperty.uniqueId] = destination[property];
          }
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 7:
        case 10:
        case 12:
          destination[property] = instanciate ? sourceProperty : sourceProperty.clone();
          break;
      }
    }
  }
  return destination;
};
function getDirectStore(target) {
  const classKey = target.getClassName();
  if (!__decoratorInitialStore[classKey]) {
    __decoratorInitialStore[classKey] = {};
  }
  return __decoratorInitialStore[classKey];
}
function getMergedStore(target) {
  const classKey = target.getClassName();
  if (__mergedStore[classKey]) {
    return __mergedStore[classKey];
  }
  __mergedStore[classKey] = {};
  const store = __mergedStore[classKey];
  let currentTarget = target;
  let currentKey = classKey;
  while (currentKey) {
    const initialStore = __decoratorInitialStore[currentKey];
    for (const property in initialStore) {
      store[property] = initialStore[property];
    }
    let parent;
    let done = false;
    do {
      parent = Object.getPrototypeOf(currentTarget);
      if (!parent.getClassName) {
        done = true;
        break;
      }
      if (parent.getClassName() !== currentKey) {
        break;
      }
      currentTarget = parent;
    } while (parent);
    if (done) {
      break;
    }
    currentKey = parent.getClassName();
    currentTarget = parent;
  }
  return store;
}
function generateSerializableMember(type, sourceName) {
  return (target, propertyKey) => {
    const classStore = getDirectStore(target);
    if (!classStore[propertyKey]) {
      classStore[propertyKey] = { type, sourceName };
    }
  };
}
function generateExpandMember(setCallback, targetKey = null) {
  return (target, propertyKey) => {
    const key = targetKey || "_" + propertyKey;
    Object.defineProperty(target, propertyKey, {
      get: function() {
        return this[key];
      },
      set: function(value) {
        if (typeof this.equals === "function") {
          if (this.equals(value)) {
            return;
          }
        }
        if (this[key] === value) {
          return;
        }
        this[key] = value;
        target[setCallback].apply(this);
      },
      enumerable: true,
      configurable: true
    });
  };
}
function expandToProperty(callback, targetKey = null) {
  return generateExpandMember(callback, targetKey);
}
function serialize(sourceName) {
  return generateSerializableMember(0, sourceName);
}
function serializeAsTexture(sourceName) {
  return generateSerializableMember(1, sourceName);
}
function serializeAsColor3(sourceName) {
  return generateSerializableMember(2, sourceName);
}
function serializeAsFresnelParameters(sourceName) {
  return generateSerializableMember(3, sourceName);
}
function serializeAsVector2(sourceName) {
  return generateSerializableMember(4, sourceName);
}
function serializeAsVector3(sourceName) {
  return generateSerializableMember(5, sourceName);
}
function serializeAsMeshReference(sourceName) {
  return generateSerializableMember(6, sourceName);
}
function serializeAsColorCurves(sourceName) {
  return generateSerializableMember(7, sourceName);
}
function serializeAsColor4(sourceName) {
  return generateSerializableMember(8, sourceName);
}
function serializeAsImageProcessingConfiguration(sourceName) {
  return generateSerializableMember(9, sourceName);
}
function serializeAsQuaternion(sourceName) {
  return generateSerializableMember(10, sourceName);
}
function serializeAsMatrix(sourceName) {
  return generateSerializableMember(12, sourceName);
}
function serializeAsCameraReference(sourceName) {
  return generateSerializableMember(11, sourceName);
}
var SerializationHelper = class _SerializationHelper {
  /**
   * Appends the serialized animations from the source animations
   * @param source Source containing the animations
   * @param destination Target to store the animations
   */
  static AppendSerializedAnimations(source, destination) {
    if (source.animations) {
      destination.animations = [];
      for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {
        const animation = source.animations[animationIndex];
        destination.animations.push(animation.serialize());
      }
    }
  }
  /**
   * Static function used to serialized a specific entity
   * @param entity defines the entity to serialize
   * @param serializationObject defines the optional target object where serialization data will be stored
   * @returns a JSON compatible object representing the serialization of the entity
   */
  static Serialize(entity, serializationObject) {
    if (!serializationObject) {
      serializationObject = {};
    }
    if (Tags) {
      serializationObject.tags = Tags.GetTags(entity);
    }
    const serializedProperties = getMergedStore(entity);
    for (const property in serializedProperties) {
      const propertyDescriptor = serializedProperties[property];
      const targetPropertyName = propertyDescriptor.sourceName || property;
      const propertyType = propertyDescriptor.type;
      const sourceProperty = entity[property];
      if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || _SerializationHelper.AllowLoadingUniqueId)) {
        switch (propertyType) {
          case 0:
            serializationObject[targetPropertyName] = sourceProperty;
            break;
          case 1:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 2:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 3:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 4:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 5:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 6:
            serializationObject[targetPropertyName] = sourceProperty.id;
            break;
          case 7:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 8:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 9:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 10:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 11:
            serializationObject[targetPropertyName] = sourceProperty.id;
            break;
          case 12:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
        }
      }
    }
    return serializationObject;
  }
  /**
   * Given a source json and a destination object in a scene, this function will parse the source and will try to apply its content to the destination object
   * @param source the source json data
   * @param destination the destination object
   * @param scene the scene where the object is
   * @param rootUrl root url to use to load assets
   */
  static ParseProperties(source, destination, scene, rootUrl) {
    if (!rootUrl) {
      rootUrl = "";
    }
    const classStore = getMergedStore(destination);
    for (const property in classStore) {
      const propertyDescriptor = classStore[property];
      const sourceProperty = source[propertyDescriptor.sourceName || property];
      const propertyType = propertyDescriptor.type;
      if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || _SerializationHelper.AllowLoadingUniqueId)) {
        const dest = destination;
        switch (propertyType) {
          case 0:
            dest[property] = sourceProperty;
            break;
          case 1:
            if (scene) {
              dest[property] = _SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);
            }
            break;
          case 2:
            dest[property] = Color3.FromArray(sourceProperty);
            break;
          case 3:
            dest[property] = _SerializationHelper._FresnelParametersParser(sourceProperty);
            break;
          case 4:
            dest[property] = Vector2.FromArray(sourceProperty);
            break;
          case 5:
            dest[property] = Vector3.FromArray(sourceProperty);
            break;
          case 6:
            if (scene) {
              dest[property] = scene.getLastMeshById(sourceProperty);
            }
            break;
          case 7:
            dest[property] = _SerializationHelper._ColorCurvesParser(sourceProperty);
            break;
          case 8:
            dest[property] = Color4.FromArray(sourceProperty);
            break;
          case 9:
            dest[property] = _SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);
            break;
          case 10:
            dest[property] = Quaternion.FromArray(sourceProperty);
            break;
          case 11:
            if (scene) {
              dest[property] = scene.getCameraById(sourceProperty);
            }
            break;
          case 12:
            dest[property] = Matrix.FromArray(sourceProperty);
            break;
        }
      }
    }
  }
  /**
   * Creates a new entity from a serialization data object
   * @param creationFunction defines a function used to instanciated the new entity
   * @param source defines the source serialization data
   * @param scene defines the hosting scene
   * @param rootUrl defines the root url for resources
   * @returns a new entity
   */
  static Parse(creationFunction, source, scene, rootUrl = null) {
    const destination = creationFunction();
    if (Tags) {
      Tags.AddTagsTo(destination, source.tags);
    }
    _SerializationHelper.ParseProperties(source, destination, scene, rootUrl);
    return destination;
  }
  /**
   * Clones an object
   * @param creationFunction defines the function used to instanciate the new object
   * @param source defines the source object
   * @param options defines the options to use
   * @returns the cloned object
   */
  static Clone(creationFunction, source, options = {}) {
    return _copySource(creationFunction, source, false, options);
  }
  /**
   * Instanciates a new object based on a source one (some data will be shared between both object)
   * @param creationFunction defines the function used to instanciate the new object
   * @param source defines the source object
   * @returns the new object
   */
  static Instanciate(creationFunction, source) {
    return _copySource(creationFunction, source, true);
  }
};
SerializationHelper.AllowLoadingUniqueId = false;
SerializationHelper._ImageProcessingConfigurationParser = (sourceProperty) => {
  throw _WarnImport("ImageProcessingConfiguration");
};
SerializationHelper._FresnelParametersParser = (sourceProperty) => {
  throw _WarnImport("FresnelParameters");
};
SerializationHelper._ColorCurvesParser = (sourceProperty) => {
  throw _WarnImport("ColorCurves");
};
SerializationHelper._TextureParser = (sourceProperty, scene, rootUrl) => {
  throw _WarnImport("Texture");
};
function nativeOverride(target, propertyKey, descriptor, predicate) {
  const jsFunc = descriptor.value;
  descriptor.value = (...params) => {
    let func = jsFunc;
    if (typeof _native !== "undefined" && _native[propertyKey]) {
      const nativeFunc = _native[propertyKey];
      if (predicate) {
        func = (...params2) => predicate(...params2) ? nativeFunc(...params2) : jsFunc(...params2);
      } else {
        func = nativeFunc;
      }
    }
    target[propertyKey] = func;
    return func(...params);
  };
}
nativeOverride.filter = function(predicate) {
  return (target, propertyKey, descriptor) => nativeOverride(target, propertyKey, descriptor, predicate);
};

// node_modules/@babylonjs/core/node.js
var _InternalNodeDataInfo = class {
  constructor() {
    this._doNotSerialize = false;
    this._isDisposed = false;
    this._sceneRootNodesIndex = -1;
    this._isEnabled = true;
    this._isParentEnabled = true;
    this._isReady = true;
    this._onEnabledStateChangedObservable = new Observable();
    this._onClonedObservable = new Observable();
  }
};
var Node = class _Node {
  /**
   * Add a new node constructor
   * @param type defines the type name of the node to construct
   * @param constructorFunc defines the constructor function
   */
  static AddNodeConstructor(type, constructorFunc) {
    this._NodeConstructors[type] = constructorFunc;
  }
  /**
   * Returns a node constructor based on type name
   * @param type defines the type name
   * @param name defines the new node name
   * @param scene defines the hosting scene
   * @param options defines optional options to transmit to constructors
   * @returns the new constructor or null
   */
  static Construct(type, name, scene, options) {
    const constructorFunc = this._NodeConstructors[type];
    if (!constructorFunc) {
      return null;
    }
    return constructorFunc(name, scene, options);
  }
  /**
   * Gets or sets the accessibility tag to describe the node for accessibility purpose.
   */
  set accessibilityTag(value) {
    this._accessibilityTag = value;
    this.onAccessibilityTagChangedObservable.notifyObservers(value);
  }
  get accessibilityTag() {
    return this._accessibilityTag;
  }
  /**
   * Gets or sets a boolean used to define if the node must be serialized
   */
  get doNotSerialize() {
    if (this._nodeDataStorage._doNotSerialize) {
      return true;
    }
    if (this._parentNode) {
      return this._parentNode.doNotSerialize;
    }
    return false;
  }
  set doNotSerialize(value) {
    this._nodeDataStorage._doNotSerialize = value;
  }
  /**
   * Gets a boolean indicating if the node has been disposed
   * @returns true if the node was disposed
   */
  isDisposed() {
    return this._nodeDataStorage._isDisposed;
  }
  /**
   * Gets or sets the parent of the node (without keeping the current position in the scene)
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/transforms/parent_pivot/parent
   */
  set parent(parent) {
    if (this._parentNode === parent) {
      return;
    }
    const previousParentNode = this._parentNode;
    if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) {
      const index = this._parentNode._children.indexOf(this);
      if (index !== -1) {
        this._parentNode._children.splice(index, 1);
      }
      if (!parent && !this._nodeDataStorage._isDisposed) {
        this._addToSceneRootNodes();
      }
    }
    this._parentNode = parent;
    if (this._parentNode) {
      if (this._parentNode._children === void 0 || this._parentNode._children === null) {
        this._parentNode._children = new Array();
      }
      this._parentNode._children.push(this);
      if (!previousParentNode) {
        this._removeFromSceneRootNodes();
      }
    }
    this._syncParentEnabledState();
  }
  get parent() {
    return this._parentNode;
  }
  /**
   * @internal
   */
  _serializeAsParent(serializationObject) {
    serializationObject.parentId = this.uniqueId;
  }
  /** @internal */
  _addToSceneRootNodes() {
    if (this._nodeDataStorage._sceneRootNodesIndex === -1) {
      this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length;
      this._scene.rootNodes.push(this);
    }
  }
  /** @internal */
  _removeFromSceneRootNodes() {
    if (this._nodeDataStorage._sceneRootNodesIndex !== -1) {
      const rootNodes = this._scene.rootNodes;
      const lastIdx = rootNodes.length - 1;
      rootNodes[this._nodeDataStorage._sceneRootNodesIndex] = rootNodes[lastIdx];
      rootNodes[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex;
      this._scene.rootNodes.pop();
      this._nodeDataStorage._sceneRootNodesIndex = -1;
    }
  }
  /**
   * Gets or sets the animation properties override
   */
  get animationPropertiesOverride() {
    if (!this._animationPropertiesOverride) {
      return this._scene.animationPropertiesOverride;
    }
    return this._animationPropertiesOverride;
  }
  set animationPropertiesOverride(value) {
    this._animationPropertiesOverride = value;
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "Node" string
   */
  getClassName() {
    return "Node";
  }
  /**
   * Sets a callback that will be raised when the node will be disposed
   */
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  /**
   * An event triggered when the enabled state of the node changes
   */
  get onEnabledStateChangedObservable() {
    return this._nodeDataStorage._onEnabledStateChangedObservable;
  }
  /**
   * An event triggered when the node is cloned
   */
  get onClonedObservable() {
    return this._nodeDataStorage._onClonedObservable;
  }
  /**
   * Creates a new Node
   * @param name the name and id to be given to this node
   * @param scene the scene this node will be added to
   */
  constructor(name, scene = null) {
    this._isDirty = false;
    this._nodeDataStorage = new _InternalNodeDataInfo();
    this.state = "";
    this.metadata = null;
    this.reservedDataStore = null;
    this._accessibilityTag = null;
    this.onAccessibilityTagChangedObservable = new Observable();
    this._parentContainer = null;
    this.animations = [];
    this._ranges = {};
    this.onReady = null;
    this._currentRenderId = -1;
    this._parentUpdateId = -1;
    this._childUpdateId = -1;
    this._waitingParentId = null;
    this._waitingParentInstanceIndex = null;
    this._waitingParsedUniqueId = null;
    this._cache = {};
    this._parentNode = null;
    this._children = null;
    this._worldMatrix = Matrix.Identity();
    this._worldMatrixDeterminant = 0;
    this._worldMatrixDeterminantIsDirty = true;
    this._animationPropertiesOverride = null;
    this._isNode = true;
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._behaviors = new Array();
    this.name = name;
    this.id = name;
    this._scene = scene || EngineStore.LastCreatedScene;
    this.uniqueId = this._scene.getUniqueId();
    this._initCache();
  }
  /**
   * Gets the scene of the node
   * @returns a scene
   */
  getScene() {
    return this._scene;
  }
  /**
   * Gets the engine of the node
   * @returns a Engine
   */
  getEngine() {
    return this._scene.getEngine();
  }
  /**
   * Attach a behavior to the node
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @param behavior defines the behavior to attach
   * @param attachImmediately defines that the behavior must be attached even if the scene is still loading
   * @returns the current Node
   */
  addBehavior(behavior, attachImmediately = false) {
    const index = this._behaviors.indexOf(behavior);
    if (index !== -1) {
      return this;
    }
    behavior.init();
    if (this._scene.isLoading && !attachImmediately) {
      this._scene.onDataLoadedObservable.addOnce(() => {
        behavior.attach(this);
      });
    } else {
      behavior.attach(this);
    }
    this._behaviors.push(behavior);
    return this;
  }
  /**
   * Remove an attached behavior
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @param behavior defines the behavior to attach
   * @returns the current Node
   */
  removeBehavior(behavior) {
    const index = this._behaviors.indexOf(behavior);
    if (index === -1) {
      return this;
    }
    this._behaviors[index].detach();
    this._behaviors.splice(index, 1);
    return this;
  }
  /**
   * Gets the list of attached behaviors
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   */
  get behaviors() {
    return this._behaviors;
  }
  /**
   * Gets an attached behavior by name
   * @param name defines the name of the behavior to look for
   * @see https://doc.babylonjs.com/features/featuresDeepDive/behaviors
   * @returns null if behavior was not found else the requested behavior
   */
  getBehaviorByName(name) {
    for (const behavior of this._behaviors) {
      if (behavior.name === name) {
        return behavior;
      }
    }
    return null;
  }
  /**
   * Returns the latest update of the World matrix
   * @returns a Matrix
   */
  getWorldMatrix() {
    if (this._currentRenderId !== this._scene.getRenderId()) {
      this.computeWorldMatrix();
    }
    return this._worldMatrix;
  }
  /** @internal */
  _getWorldMatrixDeterminant() {
    if (this._worldMatrixDeterminantIsDirty) {
      this._worldMatrixDeterminantIsDirty = false;
      this._worldMatrixDeterminant = this._worldMatrix.determinant();
    }
    return this._worldMatrixDeterminant;
  }
  /**
   * Returns directly the latest state of the mesh World matrix.
   * A Matrix is returned.
   */
  get worldMatrixFromCache() {
    return this._worldMatrix;
  }
  // override it in derived class if you add new variables to the cache
  // and call the parent class method
  /** @internal */
  _initCache() {
    this._cache = {};
    this._cache.parent = void 0;
  }
  /**
   * @internal
   */
  updateCache(force) {
    if (!force && this.isSynchronized()) {
      return;
    }
    this._cache.parent = this.parent;
    this._updateCache();
  }
  /**
   * @internal
   */
  _getActionManagerForTrigger(trigger, _initialCall = true) {
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  }
  // override it in derived class if you add new variables to the cache
  // and call the parent class method if !ignoreParentClass
  /**
   * @internal
   */
  _updateCache(_ignoreParentClass) {
  }
  // override it in derived class if you add new variables to the cache
  /** @internal */
  _isSynchronized() {
    return true;
  }
  /** @internal */
  _markSyncedWithParent() {
    if (this._parentNode) {
      this._parentUpdateId = this._parentNode._childUpdateId;
    }
  }
  /** @internal */
  isSynchronizedWithParent() {
    if (!this._parentNode) {
      return true;
    }
    if (this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId) {
      return false;
    }
    return this._parentNode.isSynchronized();
  }
  /** @internal */
  isSynchronized() {
    if (this._cache.parent !== this._parentNode) {
      this._cache.parent = this._parentNode;
      return false;
    }
    if (this._parentNode && !this.isSynchronizedWithParent()) {
      return false;
    }
    return this._isSynchronized();
  }
  /**
   * Is this node ready to be used/rendered
   * @param _completeCheck defines if a complete check (including materials and lights) has to be done (false by default)
   * @returns true if the node is ready
   */
  isReady(_completeCheck = false) {
    return this._nodeDataStorage._isReady;
  }
  /**
   * Flag the  node as dirty (Forcing it to update everything)
   * @param _property helps children apply precise "dirtyfication"
   * @returns this node
   */
  markAsDirty(_property) {
    this._currentRenderId = Number.MAX_VALUE;
    this._isDirty = true;
    return this;
  }
  /**
   * Is this node enabled?
   * If the node has a parent, all ancestors will be checked and false will be returned if any are false (not enabled), otherwise will return true
   * @param checkAncestors indicates if this method should check the ancestors. The default is to check the ancestors. If set to false, the method will return the value of this node without checking ancestors
   * @returns whether this node (and its parent) is enabled
   */
  isEnabled(checkAncestors = true) {
    if (checkAncestors === false) {
      return this._nodeDataStorage._isEnabled;
    }
    if (!this._nodeDataStorage._isEnabled) {
      return false;
    }
    return this._nodeDataStorage._isParentEnabled;
  }
  /** @internal */
  _syncParentEnabledState() {
    this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : true;
    if (this._children) {
      this._children.forEach((c) => {
        c._syncParentEnabledState();
      });
    }
  }
  /**
   * Set the enabled state of this node
   * @param value defines the new enabled state
   */
  setEnabled(value) {
    if (this._nodeDataStorage._isEnabled === value) {
      return;
    }
    this._nodeDataStorage._isEnabled = value;
    this._syncParentEnabledState();
    this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(value);
  }
  /**
   * Is this node a descendant of the given node?
   * The function will iterate up the hierarchy until the ancestor was found or no more parents defined
   * @param ancestor defines the parent node to inspect
   * @returns a boolean indicating if this node is a descendant of the given node
   */
  isDescendantOf(ancestor) {
    if (this.parent) {
      if (this.parent === ancestor) {
        return true;
      }
      return this.parent.isDescendantOf(ancestor);
    }
    return false;
  }
  /**
   * @internal
   */
  _getDescendants(results, directDescendantsOnly = false, predicate) {
    if (!this._children) {
      return;
    }
    for (let index = 0; index < this._children.length; index++) {
      const item = this._children[index];
      if (!predicate || predicate(item)) {
        results.push(item);
      }
      if (!directDescendantsOnly) {
        item._getDescendants(results, false, predicate);
      }
    }
  }
  /**
   * Will return all nodes that have this node as ascendant
   * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered
   * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
   * @returns all children nodes of all types
   */
  getDescendants(directDescendantsOnly, predicate) {
    const results = [];
    this._getDescendants(results, directDescendantsOnly, predicate);
    return results;
  }
  /**
   * Get all child-meshes of this node
   * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: false)
   * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
   * @returns an array of AbstractMesh
   */
  getChildMeshes(directDescendantsOnly, predicate) {
    const results = [];
    this._getDescendants(results, directDescendantsOnly, (node) => {
      return (!predicate || predicate(node)) && node.cullingStrategy !== void 0;
    });
    return results;
  }
  /**
   * Get all direct children of this node
   * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored
   * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered (Default: true)
   * @returns an array of Node
   */
  getChildren(predicate, directDescendantsOnly = true) {
    return this.getDescendants(directDescendantsOnly, predicate);
  }
  /**
   * @internal
   */
  _setReady(state) {
    if (state === this._nodeDataStorage._isReady) {
      return;
    }
    if (!state) {
      this._nodeDataStorage._isReady = false;
      return;
    }
    if (this.onReady) {
      this.onReady(this);
    }
    this._nodeDataStorage._isReady = true;
  }
  /**
   * Get an animation by name
   * @param name defines the name of the animation to look for
   * @returns null if not found else the requested animation
   */
  getAnimationByName(name) {
    for (let i = 0; i < this.animations.length; i++) {
      const animation = this.animations[i];
      if (animation.name === name) {
        return animation;
      }
    }
    return null;
  }
  /**
   * Creates an animation range for this node
   * @param name defines the name of the range
   * @param from defines the starting key
   * @param to defines the end key
   */
  createAnimationRange(name, from, to) {
    if (!this._ranges[name]) {
      this._ranges[name] = _Node._AnimationRangeFactory(name, from, to);
      for (let i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
        if (this.animations[i]) {
          this.animations[i].createRange(name, from, to);
        }
      }
    }
  }
  /**
   * Delete a specific animation range
   * @param name defines the name of the range to delete
   * @param deleteFrames defines if animation frames from the range must be deleted as well
   */
  deleteAnimationRange(name, deleteFrames = true) {
    for (let i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
      if (this.animations[i]) {
        this.animations[i].deleteRange(name, deleteFrames);
      }
    }
    this._ranges[name] = null;
  }
  /**
   * Get an animation range by name
   * @param name defines the name of the animation range to look for
   * @returns null if not found else the requested animation range
   */
  getAnimationRange(name) {
    return this._ranges[name] || null;
  }
  /**
   * Clone the current node
   * @param name Name of the new clone
   * @param newParent New parent for the clone
   * @param doNotCloneChildren Do not clone children hierarchy
   * @returns the new transform node
   */
  clone(name, newParent, doNotCloneChildren) {
    const result = SerializationHelper.Clone(() => new _Node(name, this.getScene()), this);
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      const directDescendants = this.getDescendants(true);
      for (let index = 0; index < directDescendants.length; index++) {
        const child = directDescendants[index];
        child.clone(name + "." + child.name, result);
      }
    }
    return result;
  }
  /**
   * Gets the list of all animation ranges defined on this node
   * @returns an array
   */
  getAnimationRanges() {
    const animationRanges = [];
    let name;
    for (name in this._ranges) {
      animationRanges.push(this._ranges[name]);
    }
    return animationRanges;
  }
  /**
   * Will start the animation sequence
   * @param name defines the range frames for animation sequence
   * @param loop defines if the animation should loop (false by default)
   * @param speedRatio defines the speed factor in which to run the animation (1 by default)
   * @param onAnimationEnd defines a function to be executed when the animation ended (undefined by default)
   * @returns the object created for this animation. If range does not exist, it will return null
   */
  beginAnimation(name, loop, speedRatio, onAnimationEnd) {
    const range = this.getAnimationRange(name);
    if (!range) {
      return null;
    }
    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
  }
  /**
   * Serialize animation ranges into a JSON compatible object
   * @returns serialization object
   */
  serializeAnimationRanges() {
    const serializationRanges = [];
    for (const name in this._ranges) {
      const localRange = this._ranges[name];
      if (!localRange) {
        continue;
      }
      const range = {};
      range.name = name;
      range.from = localRange.from;
      range.to = localRange.to;
      serializationRanges.push(range);
    }
    return serializationRanges;
  }
  /**
   * Computes the world matrix of the node
   * @param _force defines if the cache version should be invalidated forcing the world matrix to be created from scratch
   * @returns the world matrix
   */
  computeWorldMatrix(_force) {
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    return this._worldMatrix;
  }
  /**
   * Releases resources associated with this node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this._nodeDataStorage._isDisposed = true;
    if (!doNotRecurse) {
      const nodes = this.getDescendants(true);
      for (const node of nodes) {
        node.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
    }
    if (!this.parent) {
      this._removeFromSceneRootNodes();
    } else {
      this.parent = null;
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onEnabledStateChangedObservable.clear();
    this.onClonedObservable.clear();
    for (const behavior of this._behaviors) {
      behavior.detach();
    }
    this._behaviors.length = 0;
    this.metadata = null;
  }
  /**
   * Parse animation range data from a serialization object and store them into a given node
   * @param node defines where to store the animation ranges
   * @param parsedNode defines the serialization object to read data from
   * @param _scene defines the hosting scene
   */
  static ParseAnimationRanges(node, parsedNode, _scene) {
    if (parsedNode.ranges) {
      for (let index = 0; index < parsedNode.ranges.length; index++) {
        const data = parsedNode.ranges[index];
        node.createAnimationRange(data.name, data.from, data.to);
      }
    }
  }
  /**
   * Return the minimum and maximum world vectors of the entire hierarchy under current node
   * @param includeDescendants Include bounding info from descendants as well (true by default)
   * @param predicate defines a callback function that can be customize to filter what meshes should be included in the list used to compute the bounding vectors
   * @returns the new bounding vectors
   */
  getHierarchyBoundingVectors(includeDescendants = true, predicate = null) {
    this.getScene().incrementRenderId();
    this.computeWorldMatrix(true);
    let min;
    let max;
    const thisAbstractMesh = this;
    if (thisAbstractMesh.getBoundingInfo && thisAbstractMesh.subMeshes) {
      const boundingInfo = thisAbstractMesh.getBoundingInfo();
      min = boundingInfo.boundingBox.minimumWorld.clone();
      max = boundingInfo.boundingBox.maximumWorld.clone();
    } else {
      min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    }
    if (includeDescendants) {
      const descendants = this.getDescendants(false);
      for (const descendant of descendants) {
        const childMesh = descendant;
        childMesh.computeWorldMatrix(true);
        if (predicate && !predicate(childMesh)) {
          continue;
        }
        if (!childMesh.getBoundingInfo || childMesh.getTotalVertices() === 0) {
          continue;
        }
        const childBoundingInfo = childMesh.getBoundingInfo();
        const boundingBox = childBoundingInfo.boundingBox;
        const minBox = boundingBox.minimumWorld;
        const maxBox = boundingBox.maximumWorld;
        Vector3.CheckExtends(minBox, min, max);
        Vector3.CheckExtends(maxBox, min, max);
      }
    }
    return {
      min,
      max
    };
  }
};
Node._AnimationRangeFactory = (_name, _from, _to) => {
  throw _WarnImport("AnimationRange");
};
Node._NodeConstructors = {};
__decorate([
  serialize()
], Node.prototype, "name", void 0);
__decorate([
  serialize()
], Node.prototype, "id", void 0);
__decorate([
  serialize()
], Node.prototype, "uniqueId", void 0);
__decorate([
  serialize()
], Node.prototype, "state", void 0);
__decorate([
  serialize()
], Node.prototype, "metadata", void 0);

// node_modules/@babylonjs/core/Misc/logger.js
var Logger = class _Logger {
  static _CheckLimit(message, limit) {
    let entry = _Logger._LogLimitOutputs[message];
    if (!entry) {
      entry = { limit, current: 1 };
      _Logger._LogLimitOutputs[message] = entry;
    } else {
      entry.current++;
    }
    return entry.current <= entry.limit;
  }
  static _GenerateLimitMessage(message, level = 1) {
    const entry = _Logger._LogLimitOutputs[message];
    if (!entry || !_Logger.MessageLimitReached) {
      return;
    }
    const type = this._Levels[level];
    if (entry.current === entry.limit) {
      _Logger[type.name](_Logger.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, type.name ?? ""));
    }
  }
  static _AddLogEntry(entry) {
    _Logger._LogCache = entry + _Logger._LogCache;
    if (_Logger.OnNewCacheEntry) {
      _Logger.OnNewCacheEntry(entry);
    }
  }
  static _FormatMessage(message) {
    const padStr = (i) => i < 10 ? "0" + i : "" + i;
    const date = /* @__PURE__ */ new Date();
    return "[" + padStr(date.getHours()) + ":" + padStr(date.getMinutes()) + ":" + padStr(date.getSeconds()) + "]: " + message;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static _LogDisabled(message, limit) {
  }
  static _LogEnabled(level = 1, message, limit) {
    const msg = Array.isArray(message) ? message[0] : message;
    if (limit !== void 0 && !_Logger._CheckLimit(msg, limit)) {
      return;
    }
    const formattedMessage = _Logger._FormatMessage(msg);
    const type = this._Levels[level];
    const optionals = Array.isArray(message) ? message.slice(1) : [];
    type.logFunc && type.logFunc("BJS - " + formattedMessage, ...optionals);
    const entry = `<div style='color:${type.color}'>${formattedMessage}</div><br>`;
    _Logger._AddLogEntry(entry);
    _Logger._GenerateLimitMessage(msg, level);
  }
  /**
   * Gets current log cache (list of logs)
   */
  static get LogCache() {
    return _Logger._LogCache;
  }
  /**
   * Clears the log cache
   */
  static ClearLogCache() {
    _Logger._LogCache = "";
    _Logger._LogLimitOutputs = {};
    _Logger.errorsCount = 0;
  }
  /**
   * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)
   */
  static set LogLevels(level) {
    _Logger.Log = _Logger._LogDisabled;
    _Logger.Warn = _Logger._LogDisabled;
    _Logger.Error = _Logger._LogDisabled;
    [_Logger.MessageLogLevel, _Logger.WarningLogLevel, _Logger.ErrorLogLevel].forEach((l) => {
      if ((level & l) === l) {
        const type = this._Levels[l];
        _Logger[type.name] = _Logger._LogEnabled.bind(_Logger, l);
      }
    });
  }
};
Logger.NoneLogLevel = 0;
Logger.MessageLogLevel = 1;
Logger.WarningLogLevel = 2;
Logger.ErrorLogLevel = 4;
Logger.AllLogLevel = 7;
Logger.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.";
Logger._LogCache = "";
Logger._LogLimitOutputs = {};
Logger._Levels = [
  {},
  { color: "white", logFunc: console.log, name: "Log" },
  { color: "orange", logFunc: console.warn, name: "Warn" },
  {},
  { color: "red", logFunc: console.error, name: "Error" }
];
Logger.errorsCount = 0;
Logger.Log = Logger._LogEnabled.bind(Logger, Logger.MessageLogLevel);
Logger.Warn = Logger._LogEnabled.bind(Logger, Logger.WarningLogLevel);
Logger.Error = Logger._LogEnabled.bind(Logger, Logger.ErrorLogLevel);

// node_modules/@babylonjs/core/Misc/domManagement.js
function IsWindowObjectExist() {
  return typeof window !== "undefined";
}
function IsNavigatorAvailable() {
  return typeof navigator !== "undefined";
}
function IsDocumentAvailable() {
  return typeof document !== "undefined";
}
function GetDOMTextContent(element) {
  let result = "";
  let child = element.firstChild;
  while (child) {
    if (child.nodeType === 3) {
      result += child.textContent;
    }
    child = child.nextSibling;
  }
  return result;
}
var DomManagement = {
  /**
   * Checks if the window object exists
   * @returns true if the window object exists
   */
  IsWindowObjectExist,
  /**
   * Checks if the navigator object exists
   * @returns true if the navigator object exists
   */
  IsNavigatorAvailable,
  /**
   * Check if the document object exists
   * @returns true if the document object exists
   */
  IsDocumentAvailable,
  /**
   * Extracts text content from a DOM element hierarchy
   * @param element defines the root element
   * @returns a string
   */
  GetDOMTextContent
};

// node_modules/@babylonjs/core/Misc/deepCopier.js
var CloneValue = (source, destinationObject, shallowCopyValues) => {
  if (!source) {
    return null;
  }
  if (source.getClassName && source.getClassName() === "Mesh") {
    return null;
  }
  if (source.getClassName && (source.getClassName() === "SubMesh" || source.getClassName() === "PhysicsBody")) {
    return source.clone(destinationObject);
  } else if (source.clone) {
    return source.clone();
  } else if (Array.isArray(source)) {
    return source.slice();
  } else if (shallowCopyValues && typeof source === "object") {
    return { ...source };
  }
  return null;
};
function GetAllPropertyNames(obj) {
  const props = [];
  do {
    Object.getOwnPropertyNames(obj).forEach(function(prop) {
      if (props.indexOf(prop) === -1) {
        props.push(prop);
      }
    });
  } while (obj = Object.getPrototypeOf(obj));
  return props;
}
var DeepCopier = class {
  /**
   * Tries to copy an object by duplicating every property
   * @param source defines the source object
   * @param destination defines the target object
   * @param doNotCopyList defines a list of properties to avoid
   * @param mustCopyList defines a list of properties to copy (even if they start with _)
   * @param shallowCopyValues defines wether properties referencing objects (none cloneable) must be shallow copied (false by default)
   * @remarks shallowCopyValues will not instantite the copied values which makes it only usable for "JSON objects"
   */
  static DeepCopy(source, destination, doNotCopyList, mustCopyList, shallowCopyValues = false) {
    const properties = GetAllPropertyNames(source);
    for (const prop of properties) {
      if (prop[0] === "_" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {
        continue;
      }
      if (prop.endsWith("Observable")) {
        continue;
      }
      if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {
        continue;
      }
      const sourceValue = source[prop];
      const typeOfSourceValue = typeof sourceValue;
      if (typeOfSourceValue === "function") {
        continue;
      }
      try {
        if (typeOfSourceValue === "object") {
          if (sourceValue instanceof Uint8Array) {
            destination[prop] = Uint8Array.from(sourceValue);
          } else if (sourceValue instanceof Array) {
            destination[prop] = [];
            if (sourceValue.length > 0) {
              if (typeof sourceValue[0] == "object") {
                for (let index = 0; index < sourceValue.length; index++) {
                  const clonedValue = CloneValue(sourceValue[index], destination, shallowCopyValues);
                  if (destination[prop].indexOf(clonedValue) === -1) {
                    destination[prop].push(clonedValue);
                  }
                }
              } else {
                destination[prop] = sourceValue.slice(0);
              }
            }
          } else {
            destination[prop] = CloneValue(sourceValue, destination, shallowCopyValues);
          }
        } else {
          destination[prop] = sourceValue;
        }
      } catch (e) {
        Logger.Warn(e.message);
      }
    }
  }
};

// node_modules/@babylonjs/core/Misc/precisionDate.js
var PrecisionDate = class {
  /**
   * Gets either window.performance.now() if supported or Date.now() else
   */
  static get Now() {
    if (IsWindowObjectExist() && window.performance && window.performance.now) {
      return window.performance.now();
    }
    return Date.now();
  }
};

// node_modules/@babylonjs/core/Misc/webRequest.js
function createXMLHttpRequest() {
  if (typeof _native !== "undefined" && _native.XMLHttpRequest) {
    return new _native.XMLHttpRequest();
  } else {
    return new XMLHttpRequest();
  }
}
var WebRequest = class _WebRequest {
  constructor() {
    this._xhr = createXMLHttpRequest();
    this._requestURL = "";
  }
  /**
   * This function can be called to check if there are request modifiers for network requests
   * @returns true if there are any custom requests available
   */
  static get IsCustomRequestAvailable() {
    return Object.keys(_WebRequest.CustomRequestHeaders).length > 0 || _WebRequest.CustomRequestModifiers.length > 0;
  }
  _injectCustomRequestHeaders() {
    if (this._shouldSkipRequestModifications(this._requestURL)) {
      return;
    }
    for (const key in _WebRequest.CustomRequestHeaders) {
      const val = _WebRequest.CustomRequestHeaders[key];
      if (val) {
        this._xhr.setRequestHeader(key, val);
      }
    }
  }
  _shouldSkipRequestModifications(url) {
    return _WebRequest.SkipRequestModificationForBabylonCDN && (url.includes("preview.babylonjs.com") || url.includes("cdn.babylonjs.com"));
  }
  /**
   * Gets or sets a function to be called when loading progress changes
   */
  get onprogress() {
    return this._xhr.onprogress;
  }
  set onprogress(value) {
    this._xhr.onprogress = value;
  }
  /**
   * Returns client's state
   */
  get readyState() {
    return this._xhr.readyState;
  }
  /**
   * Returns client's status
   */
  get status() {
    return this._xhr.status;
  }
  /**
   * Returns client's status as a text
   */
  get statusText() {
    return this._xhr.statusText;
  }
  /**
   * Returns client's response
   */
  get response() {
    return this._xhr.response;
  }
  /**
   * Returns client's response url
   */
  get responseURL() {
    return this._xhr.responseURL;
  }
  /**
   * Returns client's response as text
   */
  get responseText() {
    return this._xhr.responseText;
  }
  /**
   * Gets or sets the expected response type
   */
  get responseType() {
    return this._xhr.responseType;
  }
  set responseType(value) {
    this._xhr.responseType = value;
  }
  /**
   * Gets or sets the timeout value in milliseconds
   */
  get timeout() {
    return this._xhr.timeout;
  }
  set timeout(value) {
    this._xhr.timeout = value;
  }
  addEventListener(type, listener, options) {
    this._xhr.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    this._xhr.removeEventListener(type, listener, options);
  }
  /**
   * Cancels any network activity
   */
  abort() {
    this._xhr.abort();
  }
  /**
   * Initiates the request. The optional argument provides the request body. The argument is ignored if request method is GET or HEAD
   * @param body defines an optional request body
   */
  send(body) {
    if (_WebRequest.CustomRequestHeaders) {
      this._injectCustomRequestHeaders();
    }
    this._xhr.send(body);
  }
  /**
   * Sets the request method, request URL
   * @param method defines the method to use (GET, POST, etc..)
   * @param url defines the url to connect with
   */
  open(method, url) {
    for (const update of _WebRequest.CustomRequestModifiers) {
      if (this._shouldSkipRequestModifications(url)) {
        return;
      }
      update(this._xhr, url);
    }
    url = url.replace("file:http:", "http:");
    url = url.replace("file:https:", "https:");
    this._requestURL = url;
    this._xhr.open(method, url, true);
  }
  /**
   * Sets the value of a request header.
   * @param name The name of the header whose value is to be set
   * @param value The value to set as the body of the header
   */
  setRequestHeader(name, value) {
    this._xhr.setRequestHeader(name, value);
  }
  /**
   * Get the string containing the text of a particular header's value.
   * @param name The name of the header
   * @returns The string containing the text of the given header name
   */
  getResponseHeader(name) {
    return this._xhr.getResponseHeader(name);
  }
};
WebRequest.CustomRequestHeaders = {};
WebRequest.CustomRequestModifiers = new Array();
WebRequest.SkipRequestModificationForBabylonCDN = true;

// node_modules/@babylonjs/core/Misc/filesInputStore.js
var FilesInputStore = class {
};
FilesInputStore.FilesToLoad = {};

// node_modules/@babylonjs/core/Misc/retryStrategy.js
var RetryStrategy = class {
  /**
   * Function used to defines an exponential back off strategy
   * @param maxRetries defines the maximum number of retries (3 by default)
   * @param baseInterval defines the interval between retries
   * @returns the strategy function to use
   */
  static ExponentialBackoff(maxRetries = 3, baseInterval = 500) {
    return (url, request, retryIndex) => {
      if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf("file:") !== -1) {
        return -1;
      }
      return Math.pow(2, retryIndex) * baseInterval;
    };
  }
};

// node_modules/@babylonjs/core/Misc/error.js
var BaseError = class extends Error {
};
BaseError._setPrototypeOf = Object.setPrototypeOf || ((o, proto) => {
  o.__proto__ = proto;
  return o;
});
var ErrorCodes = {
  // Mesh errors 0-999
  /** Invalid or empty mesh vertex positions. */
  MeshInvalidPositionsError: 0,
  // Texture errors 1000-1999
  /** Unsupported texture found. */
  UnsupportedTextureError: 1e3,
  // GLTFLoader errors 2000-2999
  /** Unexpected magic number found in GLTF file header. */
  GLTFLoaderUnexpectedMagicError: 2e3,
  // SceneLoader errors 3000-3999
  /** SceneLoader generic error code. Ideally wraps the inner exception. */
  SceneLoaderError: 3e3,
  // File related errors 4000-4999
  /** Load file error */
  LoadFileError: 4e3,
  /** Request file error */
  RequestFileError: 4001,
  /** Read file error */
  ReadFileError: 4002
};
var RuntimeError = class _RuntimeError extends BaseError {
  /**
   * Creates a new RuntimeError
   * @param message defines the message of the error
   * @param errorCode the error code
   * @param innerError the error that caused the outer error
   */
  constructor(message, errorCode, innerError) {
    super(message);
    this.errorCode = errorCode;
    this.innerError = innerError;
    this.name = "RuntimeError";
    BaseError._setPrototypeOf(this, _RuntimeError.prototype);
  }
};

// node_modules/@babylonjs/core/Misc/stringTools.js
var EndsWith = (str, suffix) => {
  return str.endsWith(suffix);
};
var StartsWith = (str, suffix) => {
  if (!str) {
    return false;
  }
  return str.startsWith(suffix);
};
var Decode = (buffer) => {
  if (typeof TextDecoder !== "undefined") {
    return new TextDecoder().decode(buffer);
  }
  let result = "";
  for (let i = 0; i < buffer.byteLength; i++) {
    result += String.fromCharCode(buffer[i]);
  }
  return result;
};
var EncodeArrayBufferToBase64 = (buffer) => {
  const keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let output = "";
  let chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  let i = 0;
  const bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);
  while (i < bytes.length) {
    chr1 = bytes[i++];
    chr2 = i < bytes.length ? bytes[i++] : Number.NaN;
    chr3 = i < bytes.length ? bytes[i++] : Number.NaN;
    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    enc4 = chr3 & 63;
    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }
    output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
  }
  return output;
};
var DecodeBase64ToString = (base64Data) => {
  return atob(base64Data);
};
var DecodeBase64ToBinary = (base64Data) => {
  const decodedString = DecodeBase64ToString(base64Data);
  const bufferLength = decodedString.length;
  const bufferView = new Uint8Array(new ArrayBuffer(bufferLength));
  for (let i = 0; i < bufferLength; i++) {
    bufferView[i] = decodedString.charCodeAt(i);
  }
  return bufferView.buffer;
};
var PadNumber = (num, length) => {
  let str = String(num);
  while (str.length < length) {
    str = "0" + str;
  }
  return str;
};
var StringTools = {
  EndsWith,
  StartsWith,
  Decode,
  EncodeArrayBufferToBase64,
  DecodeBase64ToString,
  DecodeBase64ToBinary,
  PadNumber
};

// node_modules/@babylonjs/core/Materials/shaderLanguage.js
var ShaderLanguage;
(function(ShaderLanguage2) {
  ShaderLanguage2[ShaderLanguage2["GLSL"] = 0] = "GLSL";
  ShaderLanguage2[ShaderLanguage2["WGSL"] = 1] = "WGSL";
})(ShaderLanguage || (ShaderLanguage = {}));

// node_modules/@babylonjs/core/Engines/shaderStore.js
var ShaderStore = class _ShaderStore {
  /**
   * Gets the shaders repository path for a given shader language
   * @param shaderLanguage the shader language
   * @returns the path to the shaders repository
   */
  static GetShadersRepository(shaderLanguage = ShaderLanguage.GLSL) {
    return shaderLanguage === ShaderLanguage.GLSL ? _ShaderStore.ShadersRepository : _ShaderStore.ShadersRepositoryWGSL;
  }
  /**
   * Gets the shaders store of a given shader language
   * @param shaderLanguage the shader language
   * @returns the shaders store
   */
  static GetShadersStore(shaderLanguage = ShaderLanguage.GLSL) {
    return shaderLanguage === ShaderLanguage.GLSL ? _ShaderStore.ShadersStore : _ShaderStore.ShadersStoreWGSL;
  }
  /**
   * Gets the include shaders store of a given shader language
   * @param shaderLanguage the shader language
   * @returns the include shaders store
   */
  static GetIncludesShadersStore(shaderLanguage = ShaderLanguage.GLSL) {
    return shaderLanguage === ShaderLanguage.GLSL ? _ShaderStore.IncludesShadersStore : _ShaderStore.IncludesShadersStoreWGSL;
  }
};
ShaderStore.ShadersRepository = "src/Shaders/";
ShaderStore.ShadersStore = {};
ShaderStore.IncludesShadersStore = {};
ShaderStore.ShadersRepositoryWGSL = "src/ShadersWGSL/";
ShaderStore.ShadersStoreWGSL = {};
ShaderStore.IncludesShadersStoreWGSL = {};

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeNode.js
var defaultAttributeKeywordName = "attribute";
var defaultVaryingKeywordName = "varying";
var ShaderCodeNode = class {
  constructor() {
    this.children = [];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isValid(preprocessors) {
    return true;
  }
  process(preprocessors, options) {
    var _a, _b, _c, _d, _e, _f;
    let result = "";
    if (this.line) {
      let value = this.line;
      const processor = options.processor;
      if (processor) {
        if (processor.lineProcessor) {
          value = processor.lineProcessor(value, options.isFragment, options.processingContext);
        }
        const attributeKeyword = ((_a = options.processor) == null ? void 0 : _a.attributeKeywordName) ?? defaultAttributeKeywordName;
        const varyingKeyword = options.isFragment && ((_b = options.processor) == null ? void 0 : _b.varyingFragmentKeywordName) ? (_c = options.processor) == null ? void 0 : _c.varyingFragmentKeywordName : !options.isFragment && ((_d = options.processor) == null ? void 0 : _d.varyingVertexKeywordName) ? (_e = options.processor) == null ? void 0 : _e.varyingVertexKeywordName : defaultVaryingKeywordName;
        if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {
          value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);
        } else if (processor.varyingProcessor && (((_f = processor.varyingCheck) == null ? void 0 : _f.call(processor, this.line, options.isFragment)) || !processor.varyingCheck && this.line.startsWith(varyingKeyword))) {
          value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
        } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {
          if (!options.lookForClosingBracketForUniformBuffer) {
            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
          }
        } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {
          if (!options.lookForClosingBracketForUniformBuffer) {
            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
            options.lookForClosingBracketForUniformBuffer = true;
          }
        } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {
          value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
        } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith("uniform") && !options.lookForClosingBracketForUniformBuffer) {
          const regex = /uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/;
          if (regex.test(this.line)) {
            if (processor.uniformProcessor) {
              value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
            }
          } else {
            if (processor.uniformBufferProcessor) {
              value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
              options.lookForClosingBracketForUniformBuffer = true;
            }
          }
        }
        if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf("}") !== -1) {
          options.lookForClosingBracketForUniformBuffer = false;
          if (processor.endOfUniformBufferProcessor) {
            value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);
          }
        }
      }
      result += value + "\n";
    }
    this.children.forEach((child) => {
      result += child.process(preprocessors, options);
    });
    if (this.additionalDefineKey) {
      preprocessors[this.additionalDefineKey] = this.additionalDefineValue || "true";
    }
    return result;
  }
};

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeCursor.js
var ShaderCodeCursor = class {
  constructor() {
    this._lines = [];
  }
  get currentLine() {
    return this._lines[this.lineIndex];
  }
  get canRead() {
    return this.lineIndex < this._lines.length - 1;
  }
  set lines(value) {
    this._lines.length = 0;
    for (const line of value) {
      if (!line || line === "\r") {
        continue;
      }
      if (line[0] === "#") {
        this._lines.push(line);
        continue;
      }
      const trimmedLine = line.trim();
      if (!trimmedLine) {
        continue;
      }
      if (trimmedLine.startsWith("//")) {
        this._lines.push(line);
        continue;
      }
      const semicolonIndex = trimmedLine.indexOf(";");
      if (semicolonIndex === -1) {
        this._lines.push(trimmedLine);
      } else if (semicolonIndex === trimmedLine.length - 1) {
        if (trimmedLine.length > 1) {
          this._lines.push(trimmedLine);
        }
      } else {
        const split = line.split(";");
        for (let index = 0; index < split.length; index++) {
          let subLine = split[index];
          if (!subLine) {
            continue;
          }
          subLine = subLine.trim();
          if (!subLine) {
            continue;
          }
          this._lines.push(subLine + (index !== split.length - 1 ? ";" : ""));
        }
      }
    }
  }
};

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeConditionNode.js
var ShaderCodeConditionNode = class extends ShaderCodeNode {
  process(preprocessors, options) {
    for (let index = 0; index < this.children.length; index++) {
      const node = this.children[index];
      if (node.isValid(preprocessors)) {
        return node.process(preprocessors, options);
      }
    }
    return "";
  }
};

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeTestNode.js
var ShaderCodeTestNode = class extends ShaderCodeNode {
  isValid(preprocessors) {
    return this.testExpression.isTrue(preprocessors);
  }
};

// node_modules/@babylonjs/core/Engines/Processors/Expressions/shaderDefineExpression.js
var ShaderDefineExpression = class _ShaderDefineExpression {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isTrue(preprocessors) {
    return true;
  }
  static postfixToInfix(postfix) {
    const stack = [];
    for (const c of postfix) {
      if (_ShaderDefineExpression._OperatorPriority[c] === void 0) {
        stack.push(c);
      } else {
        const v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
        stack.length -= 2;
        stack.push(`(${v2}${c}${v1})`);
      }
    }
    return stack[stack.length - 1];
  }
  /**
   * Converts an infix expression to a postfix expression.
   *
   * This method is used to transform infix expressions, which are more human-readable,
   * into postfix expressions, also known as Reverse Polish Notation (RPN), that can be
   * evaluated more efficiently by a computer. The conversion is based on the operator
   * priority defined in _OperatorPriority.
   *
   * The function employs a stack-based algorithm for the conversion and caches the result
   * to improve performance. The cache keeps track of each converted expression's access time
   * to manage the cache size and optimize memory usage. When the cache size exceeds a specified
   * limit, the least recently accessed items in the cache are deleted.
   *
   * The cache mechanism is particularly helpful for shader compilation, where the same infix
   * expressions might be encountered repeatedly, hence the caching can speed up the process.
   *
   * @param infix - The infix expression to be converted.
   * @returns The postfix expression as an array of strings.
   */
  static infixToPostfix(infix) {
    const cacheItem = _ShaderDefineExpression._InfixToPostfixCache.get(infix);
    if (cacheItem) {
      cacheItem.accessTime = Date.now();
      return cacheItem.result;
    }
    if (!infix.includes("&&") && !infix.includes("||") && !infix.includes(")") && !infix.includes("(")) {
      return [infix];
    }
    const result = [];
    let stackIdx = -1;
    const pushOperand = () => {
      operand = operand.trim();
      if (operand !== "") {
        result.push(operand);
        operand = "";
      }
    };
    const push = (s) => {
      if (stackIdx < _ShaderDefineExpression._Stack.length - 1) {
        _ShaderDefineExpression._Stack[++stackIdx] = s;
      }
    };
    const peek = () => _ShaderDefineExpression._Stack[stackIdx];
    const pop = () => stackIdx === -1 ? "!!INVALID EXPRESSION!!" : _ShaderDefineExpression._Stack[stackIdx--];
    let idx = 0, operand = "";
    while (idx < infix.length) {
      const c = infix.charAt(idx), token = idx < infix.length - 1 ? infix.substr(idx, 2) : "";
      if (c === "(") {
        operand = "";
        push(c);
      } else if (c === ")") {
        pushOperand();
        while (stackIdx !== -1 && peek() !== "(") {
          result.push(pop());
        }
        pop();
      } else if (_ShaderDefineExpression._OperatorPriority[token] > 1) {
        pushOperand();
        while (stackIdx !== -1 && _ShaderDefineExpression._OperatorPriority[peek()] >= _ShaderDefineExpression._OperatorPriority[token]) {
          result.push(pop());
        }
        push(token);
        idx++;
      } else {
        operand += c;
      }
      idx++;
    }
    pushOperand();
    while (stackIdx !== -1) {
      if (peek() === "(") {
        pop();
      } else {
        result.push(pop());
      }
    }
    if (_ShaderDefineExpression._InfixToPostfixCache.size >= _ShaderDefineExpression.InfixToPostfixCacheLimitSize) {
      _ShaderDefineExpression.ClearCache();
    }
    _ShaderDefineExpression._InfixToPostfixCache.set(infix, { result, accessTime: Date.now() });
    return result;
  }
  static ClearCache() {
    const sortedCache = Array.from(_ShaderDefineExpression._InfixToPostfixCache.entries()).sort((a, b) => a[1].accessTime - b[1].accessTime);
    for (let i = 0; i < _ShaderDefineExpression.InfixToPostfixCacheCleanupSize; i++) {
      _ShaderDefineExpression._InfixToPostfixCache.delete(sortedCache[i][0]);
    }
  }
};
ShaderDefineExpression.InfixToPostfixCacheLimitSize = 5e4;
ShaderDefineExpression.InfixToPostfixCacheCleanupSize = 25e3;
ShaderDefineExpression._InfixToPostfixCache = /* @__PURE__ */ new Map();
ShaderDefineExpression._OperatorPriority = {
  ")": 0,
  "(": 1,
  "||": 2,
  "&&": 3
};
ShaderDefineExpression._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineIsDefinedOperator.js
var ShaderDefineIsDefinedOperator = class extends ShaderDefineExpression {
  constructor(define, not = false) {
    super();
    this.define = define;
    this.not = not;
  }
  isTrue(preprocessors) {
    let condition = preprocessors[this.define] !== void 0;
    if (this.not) {
      condition = !condition;
    }
    return condition;
  }
};

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineOrOperator.js
var ShaderDefineOrOperator = class extends ShaderDefineExpression {
  isTrue(preprocessors) {
    return this.leftOperand.isTrue(preprocessors) || this.rightOperand.isTrue(preprocessors);
  }
};

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineAndOperator.js
var ShaderDefineAndOperator = class extends ShaderDefineExpression {
  isTrue(preprocessors) {
    return this.leftOperand.isTrue(preprocessors) && this.rightOperand.isTrue(preprocessors);
  }
};

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineArithmeticOperator.js
var ShaderDefineArithmeticOperator = class extends ShaderDefineExpression {
  constructor(define, operand, testValue) {
    super();
    this.define = define;
    this.operand = operand;
    this.testValue = testValue;
  }
  isTrue(preprocessors) {
    let value = preprocessors[this.define];
    if (value === void 0) {
      value = this.define;
    }
    let condition = false;
    const left = parseInt(value);
    const right = parseInt(this.testValue);
    switch (this.operand) {
      case ">":
        condition = left > right;
        break;
      case "<":
        condition = left < right;
        break;
      case "<=":
        condition = left <= right;
        break;
      case ">=":
        condition = left >= right;
        break;
      case "==":
        condition = left === right;
        break;
      case "!=":
        condition = left !== right;
        break;
    }
    return condition;
  }
};

// node_modules/@babylonjs/core/Engines/Processors/shaderProcessor.js
var regexSE = /defined\s*?\((.+?)\)/g;
var regexSERevert = /defined\s*?\[(.+?)\]/g;
var regexShaderInclude = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g;
var regexShaderDecl = /__decl__/;
var regexLightX = /light\{X\}.(\w*)/g;
var regexX = /\{X\}/g;
var reusableMatches = [];
var ShaderProcessor = class _ShaderProcessor {
  static Initialize(options) {
    if (options.processor && options.processor.initializeShaders) {
      options.processor.initializeShaders(options.processingContext);
    }
  }
  static Process(sourceCode, options, callback, engine) {
    var _a;
    if ((_a = options.processor) == null ? void 0 : _a.preProcessShaderCode) {
      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
    }
    this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {
      if (options.processCodeAfterIncludes) {
        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
      }
      const migratedCode = this._ProcessShaderConversion(codeWithIncludes, options, engine);
      callback(migratedCode, codeWithIncludes);
    });
  }
  static PreProcess(sourceCode, options, callback, engine) {
    var _a;
    if ((_a = options.processor) == null ? void 0 : _a.preProcessShaderCode) {
      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
    }
    this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {
      if (options.processCodeAfterIncludes) {
        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
      }
      const migratedCode = this._ApplyPreProcessing(codeWithIncludes, options, engine);
      callback(migratedCode, codeWithIncludes);
    });
  }
  static Finalize(vertexCode, fragmentCode, options) {
    if (!options.processor || !options.processor.finalizeShaders) {
      return { vertexCode, fragmentCode };
    }
    return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);
  }
  static _ProcessPrecision(source, options) {
    var _a;
    if ((_a = options.processor) == null ? void 0 : _a.noPrecision) {
      return source;
    }
    const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;
    if (source.indexOf("precision highp float") === -1) {
      if (!shouldUseHighPrecisionShader) {
        source = "precision mediump float;\n" + source;
      } else {
        source = "precision highp float;\n" + source;
      }
    } else {
      if (!shouldUseHighPrecisionShader) {
        source = source.replace("precision highp float", "precision mediump float");
      }
    }
    return source;
  }
  static _ExtractOperation(expression) {
    const regex = /defined\((.+)\)/;
    const match = regex.exec(expression);
    if (match && match.length) {
      return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === "!");
    }
    const operators = ["==", "!=", ">=", "<=", "<", ">"];
    let operator = "";
    let indexOperator = 0;
    for (operator of operators) {
      indexOperator = expression.indexOf(operator);
      if (indexOperator > -1) {
        break;
      }
    }
    if (indexOperator === -1) {
      return new ShaderDefineIsDefinedOperator(expression);
    }
    const define = expression.substring(0, indexOperator).trim();
    const value = expression.substring(indexOperator + operator.length).trim();
    return new ShaderDefineArithmeticOperator(define, operator, value);
  }
  static _BuildSubExpression(expression) {
    expression = expression.replace(regexSE, "defined[$1]");
    const postfix = ShaderDefineExpression.infixToPostfix(expression);
    const stack = [];
    for (const c of postfix) {
      if (c !== "||" && c !== "&&") {
        stack.push(c);
      } else if (stack.length >= 2) {
        let v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
        stack.length -= 2;
        const operator = c == "&&" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();
        if (typeof v1 === "string") {
          v1 = v1.replace(regexSERevert, "defined($1)");
        }
        if (typeof v2 === "string") {
          v2 = v2.replace(regexSERevert, "defined($1)");
        }
        operator.leftOperand = typeof v2 === "string" ? this._ExtractOperation(v2) : v2;
        operator.rightOperand = typeof v1 === "string" ? this._ExtractOperation(v1) : v1;
        stack.push(operator);
      }
    }
    let result = stack[stack.length - 1];
    if (typeof result === "string") {
      result = result.replace(regexSERevert, "defined($1)");
    }
    return typeof result === "string" ? this._ExtractOperation(result) : result;
  }
  static _BuildExpression(line, start) {
    const node = new ShaderCodeTestNode();
    const command = line.substring(0, start);
    let expression = line.substring(start);
    expression = expression.substring(0, (expression.indexOf("//") + 1 || expression.length + 1) - 1).trim();
    if (command === "#ifdef") {
      node.testExpression = new ShaderDefineIsDefinedOperator(expression);
    } else if (command === "#ifndef") {
      node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);
    } else {
      node.testExpression = this._BuildSubExpression(expression);
    }
    return node;
  }
  static _MoveCursorWithinIf(cursor, rootNode, ifNode) {
    let line = cursor.currentLine;
    while (this._MoveCursor(cursor, ifNode)) {
      line = cursor.currentLine;
      const first5 = line.substring(0, 5).toLowerCase();
      if (first5 === "#else") {
        const elseNode = new ShaderCodeNode();
        rootNode.children.push(elseNode);
        this._MoveCursor(cursor, elseNode);
        return;
      } else if (first5 === "#elif") {
        const elifNode = this._BuildExpression(line, 5);
        rootNode.children.push(elifNode);
        ifNode = elifNode;
      }
    }
  }
  static _MoveCursor(cursor, rootNode) {
    while (cursor.canRead) {
      cursor.lineIndex++;
      const line = cursor.currentLine;
      if (line.indexOf("#") >= 0) {
        const matches = _ShaderProcessor._MoveCursorRegex.exec(line);
        if (matches && matches.length) {
          const keyword = matches[0];
          switch (keyword) {
            case "#ifdef": {
              const newRootNode = new ShaderCodeConditionNode();
              rootNode.children.push(newRootNode);
              const ifNode = this._BuildExpression(line, 6);
              newRootNode.children.push(ifNode);
              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
              break;
            }
            case "#else":
            case "#elif":
              return true;
            case "#endif":
              return false;
            case "#ifndef": {
              const newRootNode = new ShaderCodeConditionNode();
              rootNode.children.push(newRootNode);
              const ifNode = this._BuildExpression(line, 7);
              newRootNode.children.push(ifNode);
              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
              break;
            }
            case "#if": {
              const newRootNode = new ShaderCodeConditionNode();
              const ifNode = this._BuildExpression(line, 3);
              rootNode.children.push(newRootNode);
              newRootNode.children.push(ifNode);
              this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
              break;
            }
          }
          continue;
        }
      }
      const newNode = new ShaderCodeNode();
      newNode.line = line;
      rootNode.children.push(newNode);
      if (line[0] === "#" && line[1] === "d") {
        const split = line.replace(";", "").split(" ");
        newNode.additionalDefineKey = split[1];
        if (split.length === 3) {
          newNode.additionalDefineValue = split[2];
        }
      }
    }
    return false;
  }
  static _EvaluatePreProcessors(sourceCode, preprocessors, options) {
    const rootNode = new ShaderCodeNode();
    const cursor = new ShaderCodeCursor();
    cursor.lineIndex = -1;
    cursor.lines = sourceCode.split("\n");
    this._MoveCursor(cursor, rootNode);
    return rootNode.process(preprocessors, options);
  }
  static _PreparePreProcessors(options, engine) {
    var _a;
    const defines = options.defines;
    const preprocessors = {};
    for (const define of defines) {
      const keyValue = define.replace("#define", "").replace(";", "").trim();
      const split = keyValue.split(" ");
      preprocessors[split[0]] = split.length > 1 ? split[1] : "";
    }
    if (((_a = options.processor) == null ? void 0 : _a.shaderLanguage) === ShaderLanguage.GLSL) {
      preprocessors["GL_ES"] = "true";
    }
    preprocessors["__VERSION__"] = options.version;
    preprocessors[options.platformName] = "true";
    engine._getGlobalDefines(preprocessors);
    return preprocessors;
  }
  static _ProcessShaderConversion(sourceCode, options, engine) {
    let preparedSourceCode = this._ProcessPrecision(sourceCode, options);
    if (!options.processor) {
      return preparedSourceCode;
    }
    if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf("#version 3") !== -1) {
      preparedSourceCode = preparedSourceCode.replace("#version 300 es", "");
      if (!options.processor.parseGLES3) {
        return preparedSourceCode;
      }
    }
    const defines = options.defines;
    const preprocessors = this._PreparePreProcessors(options, engine);
    if (options.processor.preProcessor) {
      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
    }
    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
    if (options.processor.postProcessor) {
      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
    }
    if (engine._features.needShaderCodeInlining) {
      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
    }
    return preparedSourceCode;
  }
  static _ApplyPreProcessing(sourceCode, options, engine) {
    var _a, _b;
    let preparedSourceCode = sourceCode;
    const defines = options.defines;
    const preprocessors = this._PreparePreProcessors(options, engine);
    if ((_a = options.processor) == null ? void 0 : _a.preProcessor) {
      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
    }
    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
    if ((_b = options.processor) == null ? void 0 : _b.postProcessor) {
      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
    }
    if (engine._features.needShaderCodeInlining) {
      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
    }
    return preparedSourceCode;
  }
  /** @internal */
  static _ProcessIncludes(sourceCode, options, callback) {
    reusableMatches.length = 0;
    let match;
    while ((match = regexShaderInclude.exec(sourceCode)) !== null) {
      reusableMatches.push(match);
    }
    let returnValue = String(sourceCode);
    let parts = [sourceCode];
    let keepProcessing = false;
    for (const match2 of reusableMatches) {
      let includeFile = match2[1];
      if (includeFile.indexOf("__decl__") !== -1) {
        includeFile = includeFile.replace(regexShaderDecl, "");
        if (options.supportsUniformBuffers) {
          includeFile = includeFile.replace("Vertex", "Ubo").replace("Fragment", "Ubo");
        }
        includeFile = includeFile + "Declaration";
      }
      if (options.includesShadersStore[includeFile]) {
        let includeContent = options.includesShadersStore[includeFile];
        if (match2[2]) {
          const splits = match2[3].split(",");
          for (let index = 0; index < splits.length; index += 2) {
            const source = new RegExp(splits[index], "g");
            const dest = splits[index + 1];
            includeContent = includeContent.replace(source, dest);
          }
        }
        if (match2[4]) {
          const indexString = match2[5];
          if (indexString.indexOf("..") !== -1) {
            const indexSplits = indexString.split("..");
            const minIndex = parseInt(indexSplits[0]);
            let maxIndex = parseInt(indexSplits[1]);
            let sourceIncludeContent = includeContent.slice(0);
            includeContent = "";
            if (isNaN(maxIndex)) {
              maxIndex = options.indexParameters[indexSplits[1]];
            }
            for (let i = minIndex; i < maxIndex; i++) {
              if (!options.supportsUniformBuffers) {
                sourceIncludeContent = sourceIncludeContent.replace(regexLightX, (str, p1) => {
                  return p1 + "{X}";
                });
              }
              includeContent += sourceIncludeContent.replace(regexX, i.toString()) + "\n";
            }
          } else {
            if (!options.supportsUniformBuffers) {
              includeContent = includeContent.replace(regexLightX, (str, p1) => {
                return p1 + "{X}";
              });
            }
            includeContent = includeContent.replace(regexX, indexString);
          }
        }
        const newParts = [];
        for (const part of parts) {
          const splitPart = part.split(match2[0]);
          for (let i = 0; i < splitPart.length - 1; i++) {
            newParts.push(splitPart[i]);
            newParts.push(includeContent);
          }
          newParts.push(splitPart[splitPart.length - 1]);
        }
        parts = newParts;
        keepProcessing = keepProcessing || includeContent.indexOf("#include<") >= 0 || includeContent.indexOf("#include <") >= 0;
      } else {
        const includeShaderUrl = options.shadersRepository + "ShadersInclude/" + includeFile + ".fx";
        _ShaderProcessor._FileToolsLoadFile(includeShaderUrl, (fileContent) => {
          options.includesShadersStore[includeFile] = fileContent;
          this._ProcessIncludes(parts.join(""), options, callback);
        });
        return;
      }
    }
    reusableMatches.length = 0;
    returnValue = parts.join("");
    if (keepProcessing) {
      this._ProcessIncludes(returnValue.toString(), options, callback);
    } else {
      callback(returnValue);
    }
  }
  /**
   * Loads a file from a url
   * @param url url to load
   * @param onSuccess callback called when the file successfully loads
   * @param onProgress callback called while file is loading (if the server supports this mode)
   * @param offlineProvider defines the offline provider for caching
   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
   * @param onError callback called when the file fails to load
   * @returns a file request object
   * @internal
   */
  static _FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    throw _WarnImport("FileTools");
  }
};
ShaderProcessor._MoveCursorRegex = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;

// node_modules/@babylonjs/core/Materials/effect.js
var Effect = class _Effect {
  /**
   * Gets or sets the relative url used to load shaders if using the engine in non-minified mode
   */
  static get ShadersRepository() {
    return ShaderStore.ShadersRepository;
  }
  static set ShadersRepository(repo) {
    ShaderStore.ShadersRepository = repo;
  }
  /**
   * Observable that will be called when effect is bound.
   */
  get onBindObservable() {
    if (!this._onBindObservable) {
      this._onBindObservable = new Observable();
    }
    return this._onBindObservable;
  }
  /**
   * Gets the shader language type used to write vertex and fragment source code.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  /**
   * Instantiates an effect.
   * An effect can be used to create/manage/execute vertex and fragment shaders.
   * @param baseName Name of the effect.
   * @param attributesNamesOrOptions List of attribute names that will be passed to the shader or set of all options to create the effect.
   * @param uniformsNamesOrEngine List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.
   * @param samplers List of sampler variables that will be passed to the shader.
   * @param engine Engine to be used to render the effect
   * @param defines Define statements to be added to the shader.
   * @param fallbacks Possible fallbacks for this effect to improve performance when needed.
   * @param onCompiled Callback that will be called when the shader is compiled.
   * @param onError Callback that will be called if an error occurs during shader compilation.
   * @param indexParameters Parameters to be used with Babylons include syntax to iterate over an array (eg. \{lights: 10\})
   * @param key Effect Key identifying uniquely compiled shader variants
   * @param shaderLanguage the language the shader is written in (default: GLSL)
   */
  constructor(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers = null, engine, defines = null, fallbacks = null, onCompiled = null, onError = null, indexParameters, key = "", shaderLanguage = ShaderLanguage.GLSL) {
    this.name = null;
    this.defines = "";
    this.onCompiled = null;
    this.onError = null;
    this.onBind = null;
    this.uniqueId = 0;
    this.onCompileObservable = new Observable();
    this.onErrorObservable = new Observable();
    this._onBindObservable = null;
    this._isDisposed = false;
    this._bonesComputationForcedToCPU = false;
    this._uniformBuffersNames = {};
    this._multiTarget = false;
    this._samplers = {};
    this._isReady = false;
    this._compilationError = "";
    this._allFallbacksProcessed = false;
    this._uniforms = {};
    this._key = "";
    this._fallbacks = null;
    this._vertexSourceCodeOverride = "";
    this._fragmentSourceCodeOverride = "";
    this._transformFeedbackVaryings = null;
    this._pipelineContext = null;
    this._vertexSourceCode = "";
    this._fragmentSourceCode = "";
    this._vertexSourceCodeBeforeMigration = "";
    this._fragmentSourceCodeBeforeMigration = "";
    this._rawVertexSourceCode = "";
    this._rawFragmentSourceCode = "";
    this._processCodeAfterIncludes = void 0;
    this._processFinalCode = null;
    this.name = baseName;
    this._key = key;
    if (attributesNamesOrOptions.attributes) {
      const options = attributesNamesOrOptions;
      this._engine = uniformsNamesOrEngine;
      this._attributesNames = options.attributes;
      this._uniformsNames = options.uniformsNames.concat(options.samplers);
      this._samplerList = options.samplers.slice();
      this.defines = options.defines;
      this.onError = options.onError;
      this.onCompiled = options.onCompiled;
      this._fallbacks = options.fallbacks;
      this._indexParameters = options.indexParameters;
      this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;
      this._multiTarget = !!options.multiTarget;
      this._shaderLanguage = options.shaderLanguage ?? ShaderLanguage.GLSL;
      if (options.uniformBuffersNames) {
        this._uniformBuffersNamesList = options.uniformBuffersNames.slice();
        for (let i = 0; i < options.uniformBuffersNames.length; i++) {
          this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;
        }
      }
      this._processFinalCode = options.processFinalCode ?? null;
      this._processCodeAfterIncludes = options.processCodeAfterIncludes ?? void 0;
    } else {
      this._engine = engine;
      this.defines = defines == null ? "" : defines;
      this._uniformsNames = uniformsNamesOrEngine.concat(samplers);
      this._samplerList = samplers ? samplers.slice() : [];
      this._attributesNames = attributesNamesOrOptions;
      this._uniformBuffersNamesList = [];
      this._shaderLanguage = shaderLanguage;
      this.onError = onError;
      this.onCompiled = onCompiled;
      this._indexParameters = indexParameters;
      this._fallbacks = fallbacks;
    }
    this._attributeLocationByName = {};
    this.uniqueId = _Effect._UniqueIdSeed++;
    this._processShaderCode();
  }
  /** @internal */
  _processShaderCode(shaderProcessor = null, keepExistingPipelineContext = false) {
    let vertexSource;
    let fragmentSource;
    const baseName = this.name;
    const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;
    if (baseName.vertexSource) {
      vertexSource = "source:" + baseName.vertexSource;
    } else if (baseName.vertexElement) {
      vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;
      if (!vertexSource) {
        vertexSource = baseName.vertexElement;
      }
    } else {
      vertexSource = baseName.vertex || baseName;
    }
    if (baseName.fragmentSource) {
      fragmentSource = "source:" + baseName.fragmentSource;
    } else if (baseName.fragmentElement) {
      fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;
      if (!fragmentSource) {
        fragmentSource = baseName.fragmentElement;
      }
    } else {
      fragmentSource = baseName.fragment || baseName;
    }
    this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);
    let processorOptions = {
      defines: this.defines.split("\n"),
      indexParameters: this._indexParameters,
      isFragment: false,
      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
      processor: shaderProcessor ?? this._engine._getShaderProcessor(this._shaderLanguage),
      supportsUniformBuffers: this._engine.supportsUniformBuffers,
      shadersRepository: ShaderStore.GetShadersRepository(this._shaderLanguage),
      includesShadersStore: ShaderStore.GetIncludesShadersStore(this._shaderLanguage),
      version: (this._engine.version * 100).toString(),
      platformName: this._engine.shaderPlatformName,
      processingContext: this._processingContext,
      isNDCHalfZRange: this._engine.isNDCHalfZRange,
      useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
      processCodeAfterIncludes: this._processCodeAfterIncludes
    };
    const shaderCodes = [void 0, void 0];
    const shadersLoaded = () => {
      if (shaderCodes[0] && shaderCodes[1]) {
        processorOptions.isFragment = true;
        const [migratedVertexCode, fragmentCode] = shaderCodes;
        ShaderProcessor.Process(fragmentCode, processorOptions, (migratedFragmentCode, codeBeforeMigration) => {
          this._fragmentSourceCodeBeforeMigration = codeBeforeMigration;
          if (this._processFinalCode) {
            migratedFragmentCode = this._processFinalCode("fragment", migratedFragmentCode);
          }
          const finalShaders = ShaderProcessor.Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);
          processorOptions = null;
          this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName, keepExistingPipelineContext);
        }, this._engine);
      }
    };
    this._loadShader(vertexSource, "Vertex", "", (vertexCode) => {
      ShaderProcessor.Initialize(processorOptions);
      ShaderProcessor.Process(vertexCode, processorOptions, (migratedVertexCode, codeBeforeMigration) => {
        this._rawVertexSourceCode = vertexCode;
        this._vertexSourceCodeBeforeMigration = codeBeforeMigration;
        if (this._processFinalCode) {
          migratedVertexCode = this._processFinalCode("vertex", migratedVertexCode);
        }
        shaderCodes[0] = migratedVertexCode;
        shadersLoaded();
      }, this._engine);
    });
    this._loadShader(fragmentSource, "Fragment", "Pixel", (fragmentCode) => {
      this._rawFragmentSourceCode = fragmentCode;
      shaderCodes[1] = fragmentCode;
      shadersLoaded();
    });
  }
  _useFinalCode(migratedVertexCode, migratedFragmentCode, baseName, keepExistingPipelineContext = false) {
    if (baseName) {
      const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;
      const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;
      this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME vertex:" + vertex + "\n" + migratedVertexCode;
      this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME fragment:" + fragment + "\n" + migratedFragmentCode;
    } else {
      this._vertexSourceCode = migratedVertexCode;
      this._fragmentSourceCode = migratedFragmentCode;
    }
    this._prepareEffect(keepExistingPipelineContext);
  }
  /**
   * Unique key for this effect
   */
  get key() {
    return this._key;
  }
  /**
   * If the effect has been compiled and prepared.
   * @returns if the effect is compiled and prepared.
   */
  isReady() {
    try {
      return this._isReadyInternal();
    } catch {
      return false;
    }
  }
  _isReadyInternal() {
    if (this._isReady) {
      return true;
    }
    if (this._pipelineContext) {
      return this._pipelineContext.isReady;
    }
    return false;
  }
  /**
   * The engine the effect was initialized with.
   * @returns the engine.
   */
  getEngine() {
    return this._engine;
  }
  /**
   * The pipeline context for this effect
   * @returns the associated pipeline context
   */
  getPipelineContext() {
    return this._pipelineContext;
  }
  /**
   * The set of names of attribute variables for the shader.
   * @returns An array of attribute names.
   */
  getAttributesNames() {
    return this._attributesNames;
  }
  /**
   * Returns the attribute at the given index.
   * @param index The index of the attribute.
   * @returns The location of the attribute.
   */
  getAttributeLocation(index) {
    return this._attributes[index];
  }
  /**
   * Returns the attribute based on the name of the variable.
   * @param name of the attribute to look up.
   * @returns the attribute location.
   */
  getAttributeLocationByName(name) {
    return this._attributeLocationByName[name];
  }
  /**
   * The number of attributes.
   * @returns the number of attributes.
   */
  getAttributesCount() {
    return this._attributes.length;
  }
  /**
   * Gets the index of a uniform variable.
   * @param uniformName of the uniform to look up.
   * @returns the index.
   */
  getUniformIndex(uniformName) {
    return this._uniformsNames.indexOf(uniformName);
  }
  /**
   * Returns the attribute based on the name of the variable.
   * @param uniformName of the uniform to look up.
   * @returns the location of the uniform.
   */
  getUniform(uniformName) {
    return this._uniforms[uniformName];
  }
  /**
   * Returns an array of sampler variable names
   * @returns The array of sampler variable names.
   */
  getSamplers() {
    return this._samplerList;
  }
  /**
   * Returns an array of uniform variable names
   * @returns The array of uniform variable names.
   */
  getUniformNames() {
    return this._uniformsNames;
  }
  /**
   * Returns an array of uniform buffer variable names
   * @returns The array of uniform buffer variable names.
   */
  getUniformBuffersNames() {
    return this._uniformBuffersNamesList;
  }
  /**
   * Returns the index parameters used to create the effect
   * @returns The index parameters object
   */
  getIndexParameters() {
    return this._indexParameters;
  }
  /**
   * The error from the last compilation.
   * @returns the error string.
   */
  getCompilationError() {
    return this._compilationError;
  }
  /**
   * Gets a boolean indicating that all fallbacks were used during compilation
   * @returns true if all fallbacks were used
   */
  allFallbacksProcessed() {
    return this._allFallbacksProcessed;
  }
  /**
   * Adds a callback to the onCompiled observable and call the callback immediately if already ready.
   * @param func The callback to be used.
   */
  executeWhenCompiled(func) {
    if (this.isReady()) {
      func(this);
      return;
    }
    this.onCompileObservable.add((effect) => {
      func(effect);
    });
    if (!this._pipelineContext || this._pipelineContext.isAsync) {
      setTimeout(() => {
        this._checkIsReady(null);
      }, 16);
    }
  }
  _checkIsReady(previousPipelineContext) {
    try {
      if (this._isReadyInternal()) {
        return;
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
      return;
    }
    if (this._isDisposed) {
      return;
    }
    setTimeout(() => {
      this._checkIsReady(previousPipelineContext);
    }, 16);
  }
  _loadShader(shader, key, optionalKey, callback) {
    if (typeof HTMLElement !== "undefined") {
      if (shader instanceof HTMLElement) {
        const shaderCode = GetDOMTextContent(shader);
        callback(shaderCode);
        return;
      }
    }
    if (shader.substr(0, 7) === "source:") {
      callback(shader.substr(7));
      return;
    }
    if (shader.substr(0, 7) === "base64:") {
      const shaderBinary = window.atob(shader.substr(7));
      callback(shaderBinary);
      return;
    }
    const shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);
    if (shaderStore[shader + key + "Shader"]) {
      callback(shaderStore[shader + key + "Shader"]);
      return;
    }
    if (optionalKey && shaderStore[shader + optionalKey + "Shader"]) {
      callback(shaderStore[shader + optionalKey + "Shader"]);
      return;
    }
    let shaderUrl;
    if (shader[0] === "." || shader[0] === "/" || shader.indexOf("http") > -1) {
      shaderUrl = shader;
    } else {
      shaderUrl = ShaderStore.GetShadersRepository(this._shaderLanguage) + shader;
    }
    this._engine._loadFile(shaderUrl + "." + key.toLowerCase() + ".fx", callback);
  }
  /**
   * Gets the vertex shader source code of this effect
   * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)
   */
  get vertexSourceCode() {
    var _a;
    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : ((_a = this._pipelineContext) == null ? void 0 : _a._getVertexShaderCode()) ?? this._vertexSourceCode;
  }
  /**
   * Gets the fragment shader source code of this effect
   * This is the final source code that will be compiled, after all the processing has been done (pre-processing applied, code injection/replacement, etc)
   */
  get fragmentSourceCode() {
    var _a;
    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : ((_a = this._pipelineContext) == null ? void 0 : _a._getFragmentShaderCode()) ?? this._fragmentSourceCode;
  }
  /**
   * Gets the vertex shader source code before migration.
   * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.
   * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).
   */
  get vertexSourceCodeBeforeMigration() {
    return this._vertexSourceCodeBeforeMigration;
  }
  /**
   * Gets the fragment shader source code before migration.
   * This is the source code after the include directives have been replaced by their contents but before the code is migrated, i.e. before ShaderProcess._ProcessShaderConversion is executed.
   * This method is, among other things, responsible for parsing #if/#define directives as well as converting GLES2 syntax to GLES3 (in the case of WebGL).
   */
  get fragmentSourceCodeBeforeMigration() {
    return this._fragmentSourceCodeBeforeMigration;
  }
  /**
   * Gets the vertex shader source code before it has been modified by any processing
   */
  get rawVertexSourceCode() {
    return this._rawVertexSourceCode;
  }
  /**
   * Gets the fragment shader source code before it has been modified by any processing
   */
  get rawFragmentSourceCode() {
    return this._rawFragmentSourceCode;
  }
  /**
   * Recompiles the webGL program
   * @param vertexSourceCode The source code for the vertex shader.
   * @param fragmentSourceCode The source code for the fragment shader.
   * @param onCompiled Callback called when completed.
   * @param onError Callback called on error.
   * @internal
   */
  _rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {
    this._isReady = false;
    this._vertexSourceCodeOverride = vertexSourceCode;
    this._fragmentSourceCodeOverride = fragmentSourceCode;
    this.onError = (effect, error) => {
      if (onError) {
        onError(error);
      }
    };
    this.onCompiled = () => {
      var _a, _b;
      const scenes = this.getEngine().scenes;
      if (scenes) {
        for (let i = 0; i < scenes.length; i++) {
          scenes[i].markAllMaterialsAsDirty(63);
        }
      }
      (_b = (_a = this._pipelineContext)._handlesSpectorRebuildCallback) == null ? void 0 : _b.call(_a, onCompiled);
    };
    this._fallbacks = null;
    this._prepareEffect();
  }
  /**
   * Prepares the effect
   * @internal
   */
  _prepareEffect(keepExistingPipelineContext = false) {
    const attributesNames = this._attributesNames;
    const defines = this.defines;
    const previousPipelineContext = this._pipelineContext;
    this._isReady = false;
    try {
      const engine = this._engine;
      this._pipelineContext = (keepExistingPipelineContext ? previousPipelineContext : void 0) ?? engine.createPipelineContext(this._processingContext);
      this._pipelineContext._name = this._key.replace(/\r/g, "").replace(/\n/g, "|");
      const rebuildRebind = (vertexSourceCode, fragmentSourceCode, onCompiled, onError) => this._rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError);
      if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {
        engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, null, this._transformFeedbackVaryings, this._key);
      } else {
        engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, defines, this._transformFeedbackVaryings, this._key);
      }
      engine._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => {
        this._attributes = [];
        this._pipelineContext._fillEffectInformation(this, this._uniformBuffersNames, this._uniformsNames, this._uniforms, this._samplerList, this._samplers, attributesNames, this._attributes);
        if (attributesNames) {
          for (let i = 0; i < attributesNames.length; i++) {
            const name = attributesNames[i];
            this._attributeLocationByName[name] = this._attributes[i];
          }
        }
        engine.bindSamplers(this);
        this._compilationError = "";
        this._isReady = true;
        if (this.onCompiled) {
          this.onCompiled(this);
        }
        this.onCompileObservable.notifyObservers(this);
        this.onCompileObservable.clear();
        if (this._fallbacks) {
          this._fallbacks.unBindMesh();
        }
        if (previousPipelineContext && !keepExistingPipelineContext) {
          this.getEngine()._deletePipelineContext(previousPipelineContext);
        }
      });
      if (this._pipelineContext.isAsync) {
        this._checkIsReady(previousPipelineContext);
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
    }
  }
  _getShaderCodeAndErrorLine(code, error, isFragment) {
    const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/;
    let errorLine = null;
    if (error && code) {
      const res = error.match(regexp);
      if (res && res.length === 2) {
        const lineNumber = parseInt(res[1]);
        const lines = code.split("\n", -1);
        if (lines.length >= lineNumber) {
          errorLine = `Offending line [${lineNumber}] in ${isFragment ? "fragment" : "vertex"} code: ${lines[lineNumber - 1]}`;
        }
      }
    }
    return [code, errorLine];
  }
  _processCompilationErrors(e, previousPipelineContext = null) {
    var _a, _b, _c;
    this._compilationError = e.message;
    const attributesNames = this._attributesNames;
    const fallbacks = this._fallbacks;
    Logger.Error("Unable to compile effect:");
    Logger.Error("Uniforms: " + this._uniformsNames.map(function(uniform) {
      return " " + uniform;
    }));
    Logger.Error("Attributes: " + attributesNames.map(function(attribute) {
      return " " + attribute;
    }));
    Logger.Error("Defines:\n" + this.defines);
    if (_Effect.LogShaderCodeOnCompilationError) {
      let lineErrorVertex = null, lineErrorFragment = null, code = null;
      if ((_a = this._pipelineContext) == null ? void 0 : _a._getVertexShaderCode()) {
        [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);
        if (code) {
          Logger.Error("Vertex code:");
          Logger.Error(code);
        }
      }
      if ((_b = this._pipelineContext) == null ? void 0 : _b._getFragmentShaderCode()) {
        [code, lineErrorFragment] = this._getShaderCodeAndErrorLine((_c = this._pipelineContext) == null ? void 0 : _c._getFragmentShaderCode(), this._compilationError, true);
        if (code) {
          Logger.Error("Fragment code:");
          Logger.Error(code);
        }
      }
      if (lineErrorVertex) {
        Logger.Error(lineErrorVertex);
      }
      if (lineErrorFragment) {
        Logger.Error(lineErrorFragment);
      }
    }
    Logger.Error("Error: " + this._compilationError);
    const notifyErrors = () => {
      if (this.onError) {
        this.onError(this, this._compilationError);
      }
      this.onErrorObservable.notifyObservers(this);
    };
    if (previousPipelineContext) {
      this._pipelineContext = previousPipelineContext;
      this._isReady = true;
      notifyErrors();
    }
    if (fallbacks) {
      this._pipelineContext = null;
      if (fallbacks.hasMoreFallbacks) {
        this._allFallbacksProcessed = false;
        Logger.Error("Trying next fallback.");
        this.defines = fallbacks.reduce(this.defines, this);
        this._prepareEffect();
      } else {
        this._allFallbacksProcessed = true;
        notifyErrors();
        this.onErrorObservable.clear();
        if (this._fallbacks) {
          this._fallbacks.unBindMesh();
        }
      }
    } else {
      this._allFallbacksProcessed = true;
      if (!previousPipelineContext) {
        notifyErrors();
      }
    }
  }
  /**
   * Checks if the effect is supported. (Must be called after compilation)
   */
  get isSupported() {
    return this._compilationError === "";
  }
  /**
   * Binds a texture to the engine to be used as output of the shader.
   * @param channel Name of the output variable.
   * @param texture Texture to bind.
   * @internal
   */
  _bindTexture(channel, texture) {
    this._engine._bindTexture(this._samplers[channel], texture, channel);
  }
  /**
   * Sets a texture on the engine to be used in the shader.
   * @param channel Name of the sampler variable.
   * @param texture Texture to set.
   */
  setTexture(channel, texture) {
    this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
  }
  /**
   * Sets a depth stencil texture from a render target on the engine to be used in the shader.
   * @param channel Name of the sampler variable.
   * @param texture Texture to set.
   */
  setDepthStencilTexture(channel, texture) {
    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
  }
  /**
   * Sets an array of textures on the engine to be used in the shader.
   * @param channel Name of the variable.
   * @param textures Textures to set.
   */
  setTextureArray(channel, textures) {
    const exName = channel + "Ex";
    if (this._samplerList.indexOf(exName + "0") === -1) {
      const initialPos = this._samplerList.indexOf(channel);
      for (let index = 1; index < textures.length; index++) {
        const currentExName = exName + (index - 1).toString();
        this._samplerList.splice(initialPos + index, 0, currentExName);
      }
      let channelIndex = 0;
      for (const key of this._samplerList) {
        this._samplers[key] = channelIndex;
        channelIndex += 1;
      }
    }
    this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);
  }
  /**
   * Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)
   * @param channel Name of the sampler variable.
   * @param postProcess Post process to get the input texture from.
   */
  setTextureFromPostProcess(channel, postProcess) {
    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);
  }
  /**
   * (Warning! setTextureFromPostProcessOutput may be desired instead)
   * Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)
   * @param channel Name of the sampler variable.
   * @param postProcess Post process to get the output texture from.
   */
  setTextureFromPostProcessOutput(channel, postProcess) {
    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);
  }
  /**
   * Binds a buffer to a uniform.
   * @param buffer Buffer to bind.
   * @param name Name of the uniform variable to bind to.
   */
  bindUniformBuffer(buffer, name) {
    const bufferName = this._uniformBuffersNames[name];
    if (bufferName === void 0 || _Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache) {
      return;
    }
    _Effect._BaseCache[bufferName] = buffer;
    this._engine.bindUniformBufferBase(buffer, bufferName, name);
  }
  /**
   * Binds block to a uniform.
   * @param blockName Name of the block to bind.
   * @param index Index to bind.
   */
  bindUniformBlock(blockName, index) {
    this._engine.bindUniformBlock(this._pipelineContext, blockName, index);
  }
  /**
   * Sets an integer value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param value Value to be set.
   * @returns this effect.
   */
  setInt(uniformName, value) {
    this._pipelineContext.setInt(uniformName, value);
    return this;
  }
  /**
   * Sets an int2 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First int in int2.
   * @param y Second int in int2.
   * @returns this effect.
   */
  setInt2(uniformName, x, y) {
    this._pipelineContext.setInt2(uniformName, x, y);
    return this;
  }
  /**
   * Sets an int3 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First int in int3.
   * @param y Second int in int3.
   * @param z Third int in int3.
   * @returns this effect.
   */
  setInt3(uniformName, x, y, z) {
    this._pipelineContext.setInt3(uniformName, x, y, z);
    return this;
  }
  /**
   * Sets an int4 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First int in int4.
   * @param y Second int in int4.
   * @param z Third int in int4.
   * @param w Fourth int in int4.
   * @returns this effect.
   */
  setInt4(uniformName, x, y, z, w) {
    this._pipelineContext.setInt4(uniformName, x, y, z, w);
    return this;
  }
  /**
   * Sets an int array on a uniform variable.
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setIntArray(uniformName, array) {
    this._pipelineContext.setIntArray(uniformName, array);
    return this;
  }
  /**
   * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setIntArray2(uniformName, array) {
    this._pipelineContext.setIntArray2(uniformName, array);
    return this;
  }
  /**
   * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setIntArray3(uniformName, array) {
    this._pipelineContext.setIntArray3(uniformName, array);
    return this;
  }
  /**
   * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setIntArray4(uniformName, array) {
    this._pipelineContext.setIntArray4(uniformName, array);
    return this;
  }
  /**
   * Sets an unsigned integer value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param value Value to be set.
   * @returns this effect.
   */
  setUInt(uniformName, value) {
    this._pipelineContext.setUInt(uniformName, value);
    return this;
  }
  /**
   * Sets an unsigned int2 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First unsigned int in uint2.
   * @param y Second unsigned int in uint2.
   * @returns this effect.
   */
  setUInt2(uniformName, x, y) {
    this._pipelineContext.setUInt2(uniformName, x, y);
    return this;
  }
  /**
   * Sets an unsigned int3 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First unsigned int in uint3.
   * @param y Second unsigned int in uint3.
   * @param z Third unsigned int in uint3.
   * @returns this effect.
   */
  setUInt3(uniformName, x, y, z) {
    this._pipelineContext.setUInt3(uniformName, x, y, z);
    return this;
  }
  /**
   * Sets an unsigned int4 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First unsigned int in uint4.
   * @param y Second unsigned int in uint4.
   * @param z Third unsigned int in uint4.
   * @param w Fourth unsigned int in uint4.
   * @returns this effect.
   */
  setUInt4(uniformName, x, y, z, w) {
    this._pipelineContext.setUInt4(uniformName, x, y, z, w);
    return this;
  }
  /**
   * Sets an unsigned int array on a uniform variable.
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setUIntArray(uniformName, array) {
    this._pipelineContext.setUIntArray(uniformName, array);
    return this;
  }
  /**
   * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setUIntArray2(uniformName, array) {
    this._pipelineContext.setUIntArray2(uniformName, array);
    return this;
  }
  /**
   * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setUIntArray3(uniformName, array) {
    this._pipelineContext.setUIntArray3(uniformName, array);
    return this;
  }
  /**
   * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setUIntArray4(uniformName, array) {
    this._pipelineContext.setUIntArray4(uniformName, array);
    return this;
  }
  /**
   * Sets an float array on a uniform variable.
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setFloatArray(uniformName, array) {
    this._pipelineContext.setArray(uniformName, array);
    return this;
  }
  /**
   * Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setFloatArray2(uniformName, array) {
    this._pipelineContext.setArray2(uniformName, array);
    return this;
  }
  /**
   * Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setFloatArray3(uniformName, array) {
    this._pipelineContext.setArray3(uniformName, array);
    return this;
  }
  /**
   * Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setFloatArray4(uniformName, array) {
    this._pipelineContext.setArray4(uniformName, array);
    return this;
  }
  /**
   * Sets an array on a uniform variable.
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setArray(uniformName, array) {
    this._pipelineContext.setArray(uniformName, array);
    return this;
  }
  /**
   * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setArray2(uniformName, array) {
    this._pipelineContext.setArray2(uniformName, array);
    return this;
  }
  /**
   * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setArray3(uniformName, array) {
    this._pipelineContext.setArray3(uniformName, array);
    return this;
  }
  /**
   * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   * @returns this effect.
   */
  setArray4(uniformName, array) {
    this._pipelineContext.setArray4(uniformName, array);
    return this;
  }
  /**
   * Sets matrices on a uniform variable.
   * @param uniformName Name of the variable.
   * @param matrices matrices to be set.
   * @returns this effect.
   */
  setMatrices(uniformName, matrices) {
    this._pipelineContext.setMatrices(uniformName, matrices);
    return this;
  }
  /**
   * Sets matrix on a uniform variable.
   * @param uniformName Name of the variable.
   * @param matrix matrix to be set.
   * @returns this effect.
   */
  setMatrix(uniformName, matrix) {
    this._pipelineContext.setMatrix(uniformName, matrix);
    return this;
  }
  /**
   * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)
   * @param uniformName Name of the variable.
   * @param matrix matrix to be set.
   * @returns this effect.
   */
  setMatrix3x3(uniformName, matrix) {
    this._pipelineContext.setMatrix3x3(uniformName, matrix);
    return this;
  }
  /**
   * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)
   * @param uniformName Name of the variable.
   * @param matrix matrix to be set.
   * @returns this effect.
   */
  setMatrix2x2(uniformName, matrix) {
    this._pipelineContext.setMatrix2x2(uniformName, matrix);
    return this;
  }
  /**
   * Sets a float on a uniform variable.
   * @param uniformName Name of the variable.
   * @param value value to be set.
   * @returns this effect.
   */
  setFloat(uniformName, value) {
    this._pipelineContext.setFloat(uniformName, value);
    return this;
  }
  /**
   * Sets a boolean on a uniform variable.
   * @param uniformName Name of the variable.
   * @param bool value to be set.
   * @returns this effect.
   */
  setBool(uniformName, bool) {
    this._pipelineContext.setInt(uniformName, bool ? 1 : 0);
    return this;
  }
  /**
   * Sets a Vector2 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param vector2 vector2 to be set.
   * @returns this effect.
   */
  setVector2(uniformName, vector2) {
    this._pipelineContext.setVector2(uniformName, vector2);
    return this;
  }
  /**
   * Sets a float2 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First float in float2.
   * @param y Second float in float2.
   * @returns this effect.
   */
  setFloat2(uniformName, x, y) {
    this._pipelineContext.setFloat2(uniformName, x, y);
    return this;
  }
  /**
   * Sets a Vector3 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param vector3 Value to be set.
   * @returns this effect.
   */
  setVector3(uniformName, vector3) {
    this._pipelineContext.setVector3(uniformName, vector3);
    return this;
  }
  /**
   * Sets a float3 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First float in float3.
   * @param y Second float in float3.
   * @param z Third float in float3.
   * @returns this effect.
   */
  setFloat3(uniformName, x, y, z) {
    this._pipelineContext.setFloat3(uniformName, x, y, z);
    return this;
  }
  /**
   * Sets a Vector4 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param vector4 Value to be set.
   * @returns this effect.
   */
  setVector4(uniformName, vector4) {
    this._pipelineContext.setVector4(uniformName, vector4);
    return this;
  }
  /**
   * Sets a Quaternion on a uniform variable.
   * @param uniformName Name of the variable.
   * @param quaternion Value to be set.
   * @returns this effect.
   */
  setQuaternion(uniformName, quaternion) {
    this._pipelineContext.setQuaternion(uniformName, quaternion);
    return this;
  }
  /**
   * Sets a float4 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First float in float4.
   * @param y Second float in float4.
   * @param z Third float in float4.
   * @param w Fourth float in float4.
   * @returns this effect.
   */
  setFloat4(uniformName, x, y, z, w) {
    this._pipelineContext.setFloat4(uniformName, x, y, z, w);
    return this;
  }
  /**
   * Sets a Color3 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param color3 Value to be set.
   * @returns this effect.
   */
  setColor3(uniformName, color3) {
    this._pipelineContext.setColor3(uniformName, color3);
    return this;
  }
  /**
   * Sets a Color4 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param color3 Value to be set.
   * @param alpha Alpha value to be set.
   * @returns this effect.
   */
  setColor4(uniformName, color3, alpha) {
    this._pipelineContext.setColor4(uniformName, color3, alpha);
    return this;
  }
  /**
   * Sets a Color4 on a uniform variable
   * @param uniformName defines the name of the variable
   * @param color4 defines the value to be set
   * @returns this effect.
   */
  setDirectColor4(uniformName, color4) {
    this._pipelineContext.setDirectColor4(uniformName, color4);
    return this;
  }
  /**
   * Release all associated resources.
   **/
  dispose() {
    if (this._pipelineContext) {
      this._pipelineContext.dispose();
    }
    this._engine._releaseEffect(this);
    this._isDisposed = true;
  }
  /**
   * This function will add a new shader to the shader store
   * @param name the name of the shader
   * @param pixelShader optional pixel shader content
   * @param vertexShader optional vertex shader content
   * @param shaderLanguage the language the shader is written in (default: GLSL)
   */
  static RegisterShader(name, pixelShader, vertexShader, shaderLanguage = ShaderLanguage.GLSL) {
    if (pixelShader) {
      ShaderStore.GetShadersStore(shaderLanguage)[`${name}PixelShader`] = pixelShader;
    }
    if (vertexShader) {
      ShaderStore.GetShadersStore(shaderLanguage)[`${name}VertexShader`] = vertexShader;
    }
  }
  /**
   * Resets the cache of effects.
   */
  static ResetCache() {
    _Effect._BaseCache = {};
  }
};
Effect.LogShaderCodeOnCompilationError = true;
Effect._UniqueIdSeed = 0;
Effect._BaseCache = {};
Effect.ShadersStore = ShaderStore.ShadersStore;
Effect.IncludesShadersStore = ShaderStore.IncludesShadersStore;

// node_modules/@babylonjs/core/States/depthCullingState.js
var DepthCullingState = class {
  /**
   * Initializes the state.
   * @param reset
   */
  constructor(reset = true) {
    this._isDepthTestDirty = false;
    this._isDepthMaskDirty = false;
    this._isDepthFuncDirty = false;
    this._isCullFaceDirty = false;
    this._isCullDirty = false;
    this._isZOffsetDirty = false;
    this._isFrontFaceDirty = false;
    if (reset) {
      this.reset();
    }
  }
  get isDirty() {
    return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty;
  }
  get zOffset() {
    return this._zOffset;
  }
  set zOffset(value) {
    if (this._zOffset === value) {
      return;
    }
    this._zOffset = value;
    this._isZOffsetDirty = true;
  }
  get zOffsetUnits() {
    return this._zOffsetUnits;
  }
  set zOffsetUnits(value) {
    if (this._zOffsetUnits === value) {
      return;
    }
    this._zOffsetUnits = value;
    this._isZOffsetDirty = true;
  }
  get cullFace() {
    return this._cullFace;
  }
  set cullFace(value) {
    if (this._cullFace === value) {
      return;
    }
    this._cullFace = value;
    this._isCullFaceDirty = true;
  }
  get cull() {
    return this._cull;
  }
  set cull(value) {
    if (this._cull === value) {
      return;
    }
    this._cull = value;
    this._isCullDirty = true;
  }
  get depthFunc() {
    return this._depthFunc;
  }
  set depthFunc(value) {
    if (this._depthFunc === value) {
      return;
    }
    this._depthFunc = value;
    this._isDepthFuncDirty = true;
  }
  get depthMask() {
    return this._depthMask;
  }
  set depthMask(value) {
    if (this._depthMask === value) {
      return;
    }
    this._depthMask = value;
    this._isDepthMaskDirty = true;
  }
  get depthTest() {
    return this._depthTest;
  }
  set depthTest(value) {
    if (this._depthTest === value) {
      return;
    }
    this._depthTest = value;
    this._isDepthTestDirty = true;
  }
  get frontFace() {
    return this._frontFace;
  }
  set frontFace(value) {
    if (this._frontFace === value) {
      return;
    }
    this._frontFace = value;
    this._isFrontFaceDirty = true;
  }
  reset() {
    this._depthMask = true;
    this._depthTest = true;
    this._depthFunc = null;
    this._cullFace = null;
    this._cull = null;
    this._zOffset = 0;
    this._zOffsetUnits = 0;
    this._frontFace = null;
    this._isDepthTestDirty = true;
    this._isDepthMaskDirty = true;
    this._isDepthFuncDirty = false;
    this._isCullFaceDirty = false;
    this._isCullDirty = false;
    this._isZOffsetDirty = true;
    this._isFrontFaceDirty = false;
  }
  apply(gl) {
    if (!this.isDirty) {
      return;
    }
    if (this._isCullDirty) {
      if (this.cull) {
        gl.enable(gl.CULL_FACE);
      } else {
        gl.disable(gl.CULL_FACE);
      }
      this._isCullDirty = false;
    }
    if (this._isCullFaceDirty) {
      gl.cullFace(this.cullFace);
      this._isCullFaceDirty = false;
    }
    if (this._isDepthMaskDirty) {
      gl.depthMask(this.depthMask);
      this._isDepthMaskDirty = false;
    }
    if (this._isDepthTestDirty) {
      if (this.depthTest) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
      this._isDepthTestDirty = false;
    }
    if (this._isDepthFuncDirty) {
      gl.depthFunc(this.depthFunc);
      this._isDepthFuncDirty = false;
    }
    if (this._isZOffsetDirty) {
      if (this.zOffset || this.zOffsetUnits) {
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(this.zOffset, this.zOffsetUnits);
      } else {
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }
      this._isZOffsetDirty = false;
    }
    if (this._isFrontFaceDirty) {
      gl.frontFace(this.frontFace);
      this._isFrontFaceDirty = false;
    }
  }
};

// node_modules/@babylonjs/core/States/stencilState.js
var StencilState = class _StencilState {
  constructor() {
    this.reset();
  }
  reset() {
    this.enabled = false;
    this.mask = 255;
    this.func = _StencilState.ALWAYS;
    this.funcRef = 1;
    this.funcMask = 255;
    this.opStencilFail = _StencilState.KEEP;
    this.opDepthFail = _StencilState.KEEP;
    this.opStencilDepthPass = _StencilState.REPLACE;
  }
  get stencilFunc() {
    return this.func;
  }
  set stencilFunc(value) {
    this.func = value;
  }
  get stencilFuncRef() {
    return this.funcRef;
  }
  set stencilFuncRef(value) {
    this.funcRef = value;
  }
  get stencilFuncMask() {
    return this.funcMask;
  }
  set stencilFuncMask(value) {
    this.funcMask = value;
  }
  get stencilOpStencilFail() {
    return this.opStencilFail;
  }
  set stencilOpStencilFail(value) {
    this.opStencilFail = value;
  }
  get stencilOpDepthFail() {
    return this.opDepthFail;
  }
  set stencilOpDepthFail(value) {
    this.opDepthFail = value;
  }
  get stencilOpStencilDepthPass() {
    return this.opStencilDepthPass;
  }
  set stencilOpStencilDepthPass(value) {
    this.opStencilDepthPass = value;
  }
  get stencilMask() {
    return this.mask;
  }
  set stencilMask(value) {
    this.mask = value;
  }
  get stencilTest() {
    return this.enabled;
  }
  set stencilTest(value) {
    this.enabled = value;
  }
};
StencilState.ALWAYS = 519;
StencilState.KEEP = 7680;
StencilState.REPLACE = 7681;

// node_modules/@babylonjs/core/States/alphaCullingState.js
var AlphaState = class {
  /**
   * Initializes the state.
   */
  constructor() {
    this._blendFunctionParameters = new Array(4);
    this._blendEquationParameters = new Array(2);
    this._blendConstants = new Array(4);
    this._isBlendConstantsDirty = false;
    this._alphaBlend = false;
    this._isAlphaBlendDirty = false;
    this._isBlendFunctionParametersDirty = false;
    this._isBlendEquationParametersDirty = false;
    this.reset();
  }
  get isDirty() {
    return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;
  }
  get alphaBlend() {
    return this._alphaBlend;
  }
  set alphaBlend(value) {
    if (this._alphaBlend === value) {
      return;
    }
    this._alphaBlend = value;
    this._isAlphaBlendDirty = true;
  }
  setAlphaBlendConstants(r, g, b, a) {
    if (this._blendConstants[0] === r && this._blendConstants[1] === g && this._blendConstants[2] === b && this._blendConstants[3] === a) {
      return;
    }
    this._blendConstants[0] = r;
    this._blendConstants[1] = g;
    this._blendConstants[2] = b;
    this._blendConstants[3] = a;
    this._isBlendConstantsDirty = true;
  }
  setAlphaBlendFunctionParameters(value0, value1, value2, value3) {
    if (this._blendFunctionParameters[0] === value0 && this._blendFunctionParameters[1] === value1 && this._blendFunctionParameters[2] === value2 && this._blendFunctionParameters[3] === value3) {
      return;
    }
    this._blendFunctionParameters[0] = value0;
    this._blendFunctionParameters[1] = value1;
    this._blendFunctionParameters[2] = value2;
    this._blendFunctionParameters[3] = value3;
    this._isBlendFunctionParametersDirty = true;
  }
  setAlphaEquationParameters(rgb, alpha) {
    if (this._blendEquationParameters[0] === rgb && this._blendEquationParameters[1] === alpha) {
      return;
    }
    this._blendEquationParameters[0] = rgb;
    this._blendEquationParameters[1] = alpha;
    this._isBlendEquationParametersDirty = true;
  }
  reset() {
    this._alphaBlend = false;
    this._blendFunctionParameters[0] = null;
    this._blendFunctionParameters[1] = null;
    this._blendFunctionParameters[2] = null;
    this._blendFunctionParameters[3] = null;
    this._blendEquationParameters[0] = null;
    this._blendEquationParameters[1] = null;
    this._blendConstants[0] = null;
    this._blendConstants[1] = null;
    this._blendConstants[2] = null;
    this._blendConstants[3] = null;
    this._isAlphaBlendDirty = true;
    this._isBlendFunctionParametersDirty = false;
    this._isBlendEquationParametersDirty = false;
    this._isBlendConstantsDirty = false;
  }
  apply(gl) {
    if (!this.isDirty) {
      return;
    }
    if (this._isAlphaBlendDirty) {
      if (this._alphaBlend) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      this._isAlphaBlendDirty = false;
    }
    if (this._isBlendFunctionParametersDirty) {
      gl.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]);
      this._isBlendFunctionParametersDirty = false;
    }
    if (this._isBlendEquationParametersDirty) {
      gl.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]);
      this._isBlendEquationParametersDirty = false;
    }
    if (this._isBlendConstantsDirty) {
      gl.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]);
      this._isBlendConstantsDirty = false;
    }
  }
};

// node_modules/@babylonjs/core/Materials/Textures/textureSampler.js
var TextureSampler = class {
  /**
   * | Value | Type               | Description |
   * | ----- | ------------------ | ----------- |
   * | 0     | CLAMP_ADDRESSMODE  |             |
   * | 1     | WRAP_ADDRESSMODE   |             |
   * | 2     | MIRROR_ADDRESSMODE |             |
   */
  get wrapU() {
    return this._cachedWrapU;
  }
  set wrapU(value) {
    this._cachedWrapU = value;
  }
  /**
   * | Value | Type               | Description |
   * | ----- | ------------------ | ----------- |
   * | 0     | CLAMP_ADDRESSMODE  |             |
   * | 1     | WRAP_ADDRESSMODE   |             |
   * | 2     | MIRROR_ADDRESSMODE |             |
   */
  get wrapV() {
    return this._cachedWrapV;
  }
  set wrapV(value) {
    this._cachedWrapV = value;
  }
  /**
   * | Value | Type               | Description |
   * | ----- | ------------------ | ----------- |
   * | 0     | CLAMP_ADDRESSMODE  |             |
   * | 1     | WRAP_ADDRESSMODE   |             |
   * | 2     | MIRROR_ADDRESSMODE |             |
   */
  get wrapR() {
    return this._cachedWrapR;
  }
  set wrapR(value) {
    this._cachedWrapR = value;
  }
  /**
   * With compliant hardware and browser (supporting anisotropic filtering)
   * this defines the level of anisotropic filtering in the texture.
   * The higher the better but the slower.
   */
  get anisotropicFilteringLevel() {
    return this._cachedAnisotropicFilteringLevel;
  }
  set anisotropicFilteringLevel(value) {
    this._cachedAnisotropicFilteringLevel = value;
  }
  /**
   * Gets or sets the comparison function (513, 514, etc). Set 0 to not use a comparison function
   */
  get comparisonFunction() {
    return this._comparisonFunction;
  }
  set comparisonFunction(value) {
    this._comparisonFunction = value;
  }
  /**
   * Indicates to use the mip maps (if available on the texture).
   * Thanks to this flag, you can instruct the sampler to not sample the mipmaps even if they exist (and if the sampling mode is set to a value that normally samples the mipmaps!)
   */
  get useMipMaps() {
    return this._useMipMaps;
  }
  set useMipMaps(value) {
    this._useMipMaps = value;
  }
  /**
   * Creates a Sampler instance
   */
  constructor() {
    this.samplingMode = -1;
    this._useMipMaps = true;
    this._cachedWrapU = null;
    this._cachedWrapV = null;
    this._cachedWrapR = null;
    this._cachedAnisotropicFilteringLevel = null;
    this._comparisonFunction = 0;
  }
  /**
   * Sets all the parameters of the sampler
   * @param wrapU u address mode (default: TEXTURE_WRAP_ADDRESSMODE)
   * @param wrapV v address mode (default: TEXTURE_WRAP_ADDRESSMODE)
   * @param wrapR r address mode (default: TEXTURE_WRAP_ADDRESSMODE)
   * @param anisotropicFilteringLevel anisotropic level (default: 1)
   * @param samplingMode sampling mode (default: 2)
   * @param comparisonFunction comparison function (default: 0 - no comparison function)
   * @returns the current sampler instance
   */
  setParameters(wrapU = 1, wrapV = 1, wrapR = 1, anisotropicFilteringLevel = 1, samplingMode = 2, comparisonFunction = 0) {
    this._cachedWrapU = wrapU;
    this._cachedWrapV = wrapV;
    this._cachedWrapR = wrapR;
    this._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
    this.samplingMode = samplingMode;
    this._comparisonFunction = comparisonFunction;
    return this;
  }
  /**
   * Compares this sampler with another one
   * @param other sampler to compare with
   * @returns true if the samplers have the same parametres, else false
   */
  compareSampler(other) {
    return this._cachedWrapU === other._cachedWrapU && this._cachedWrapV === other._cachedWrapV && this._cachedWrapR === other._cachedWrapR && this._cachedAnisotropicFilteringLevel === other._cachedAnisotropicFilteringLevel && this.samplingMode === other.samplingMode && this._comparisonFunction === other._comparisonFunction && this._useMipMaps === other._useMipMaps;
  }
};

// node_modules/@babylonjs/core/Materials/Textures/internalTexture.js
var InternalTextureSource;
(function(InternalTextureSource2) {
  InternalTextureSource2[InternalTextureSource2["Unknown"] = 0] = "Unknown";
  InternalTextureSource2[InternalTextureSource2["Url"] = 1] = "Url";
  InternalTextureSource2[InternalTextureSource2["Temp"] = 2] = "Temp";
  InternalTextureSource2[InternalTextureSource2["Raw"] = 3] = "Raw";
  InternalTextureSource2[InternalTextureSource2["Dynamic"] = 4] = "Dynamic";
  InternalTextureSource2[InternalTextureSource2["RenderTarget"] = 5] = "RenderTarget";
  InternalTextureSource2[InternalTextureSource2["MultiRenderTarget"] = 6] = "MultiRenderTarget";
  InternalTextureSource2[InternalTextureSource2["Cube"] = 7] = "Cube";
  InternalTextureSource2[InternalTextureSource2["CubeRaw"] = 8] = "CubeRaw";
  InternalTextureSource2[InternalTextureSource2["CubePrefiltered"] = 9] = "CubePrefiltered";
  InternalTextureSource2[InternalTextureSource2["Raw3D"] = 10] = "Raw3D";
  InternalTextureSource2[InternalTextureSource2["Raw2DArray"] = 11] = "Raw2DArray";
  InternalTextureSource2[InternalTextureSource2["DepthStencil"] = 12] = "DepthStencil";
  InternalTextureSource2[InternalTextureSource2["CubeRawRGBD"] = 13] = "CubeRawRGBD";
  InternalTextureSource2[InternalTextureSource2["Depth"] = 14] = "Depth";
})(InternalTextureSource || (InternalTextureSource = {}));
var InternalTexture = class _InternalTexture extends TextureSampler {
  /**
   * Gets a boolean indicating if the texture uses mipmaps
   * TODO implements useMipMaps as a separate setting from generateMipMaps
   */
  get useMipMaps() {
    return this.generateMipMaps;
  }
  set useMipMaps(value) {
    this.generateMipMaps = value;
  }
  /** Gets the unique id of the internal texture */
  get uniqueId() {
    return this._uniqueId;
  }
  /** @internal */
  _setUniqueId(id) {
    this._uniqueId = id;
  }
  /**
   * Gets the Engine the texture belongs to.
   * @returns The babylon engine
   */
  getEngine() {
    return this._engine;
  }
  /**
   * Gets the data source type of the texture
   */
  get source() {
    return this._source;
  }
  /**
   * Creates a new InternalTexture
   * @param engine defines the engine to use
   * @param source defines the type of data that will be used
   * @param delayAllocation if the texture allocation should be delayed (default: false)
   */
  constructor(engine, source, delayAllocation = false) {
    super();
    this.isReady = false;
    this.isCube = false;
    this.is3D = false;
    this.is2DArray = false;
    this.isMultiview = false;
    this.url = "";
    this.generateMipMaps = false;
    this.samples = 0;
    this.type = -1;
    this.format = -1;
    this.onLoadedObservable = new Observable();
    this.onErrorObservable = new Observable();
    this.onRebuildCallback = null;
    this.width = 0;
    this.height = 0;
    this.depth = 0;
    this.baseWidth = 0;
    this.baseHeight = 0;
    this.baseDepth = 0;
    this.invertY = false;
    this._invertVScale = false;
    this._associatedChannel = -1;
    this._source = InternalTextureSource.Unknown;
    this._buffer = null;
    this._bufferView = null;
    this._bufferViewArray = null;
    this._bufferViewArrayArray = null;
    this._size = 0;
    this._extension = "";
    this._files = null;
    this._workingCanvas = null;
    this._workingContext = null;
    this._cachedCoordinatesMode = null;
    this._isDisabled = false;
    this._compression = null;
    this._sphericalPolynomial = null;
    this._sphericalPolynomialPromise = null;
    this._sphericalPolynomialComputed = false;
    this._lodGenerationScale = 0;
    this._lodGenerationOffset = 0;
    this._useSRGBBuffer = false;
    this._creationFlags = 0;
    this._lodTextureHigh = null;
    this._lodTextureMid = null;
    this._lodTextureLow = null;
    this._isRGBD = false;
    this._linearSpecularLOD = false;
    this._irradianceTexture = null;
    this._hardwareTexture = null;
    this._maxLodLevel = null;
    this._references = 1;
    this._gammaSpace = null;
    this._premulAlpha = false;
    this._dynamicTextureSource = null;
    this._engine = engine;
    this._source = source;
    this._uniqueId = _InternalTexture._Counter++;
    if (!delayAllocation) {
      this._hardwareTexture = engine._createHardwareTexture();
    }
  }
  /**
   * Increments the number of references (ie. the number of Texture that point to it)
   */
  incrementReferences() {
    this._references++;
  }
  /**
   * Change the size of the texture (not the size of the content)
   * @param width defines the new width
   * @param height defines the new height
   * @param depth defines the new depth (1 by default)
   */
  updateSize(width, height, depth = 1) {
    this._engine.updateTextureDimensions(this, width, height, depth);
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.baseWidth = width;
    this.baseHeight = height;
    this.baseDepth = depth;
    this._size = width * height * depth;
  }
  /** @internal */
  _rebuild() {
    this.isReady = false;
    this._cachedCoordinatesMode = null;
    this._cachedWrapU = null;
    this._cachedWrapV = null;
    this._cachedWrapR = null;
    this._cachedAnisotropicFilteringLevel = null;
    if (this.onRebuildCallback) {
      const data = this.onRebuildCallback(this);
      const swapAndSetIsReady = (proxyInternalTexture) => {
        proxyInternalTexture._swapAndDie(this, false);
        this.isReady = data.isReady;
      };
      if (data.isAsync) {
        data.proxy.then(swapAndSetIsReady);
      } else {
        swapAndSetIsReady(data.proxy);
      }
      return;
    }
    let proxy;
    switch (this.source) {
      case InternalTextureSource.Temp:
        break;
      case InternalTextureSource.Url:
        proxy = this._engine.createTexture(
          this._originalUrl ?? this.url,
          !this.generateMipMaps,
          this.invertY,
          null,
          this.samplingMode,
          // Do not use Proxy here as it could be fully synchronous
          // and proxy would be undefined.
          (temp) => {
            temp._swapAndDie(this, false);
            this.isReady = true;
          },
          null,
          this._buffer,
          void 0,
          this.format,
          this._extension,
          void 0,
          void 0,
          void 0,
          this._useSRGBBuffer
        );
        return;
      case InternalTextureSource.Raw:
        proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, this._creationFlags, this._useSRGBBuffer);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Raw3D:
        proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Raw2DArray:
        proxy = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Dynamic:
        proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);
        proxy._swapAndDie(this, false);
        if (this._dynamicTextureSource) {
          this._engine.updateDynamicTexture(this, this._dynamicTextureSource, this.invertY, this._premulAlpha, this.format, true);
        }
        break;
      case InternalTextureSource.Cube:
        proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, () => {
          proxy._swapAndDie(this, false);
          this.isReady = true;
        }, null, this.format, this._extension, false, 0, 0, null, void 0, this._useSRGBBuffer);
        return;
      case InternalTextureSource.CubeRaw:
        proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this._originalFormat ?? this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.CubeRawRGBD:
        return;
      case InternalTextureSource.CubePrefiltered:
        proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, (proxy2) => {
          if (proxy2) {
            proxy2._swapAndDie(this, false);
          }
          this.isReady = true;
        }, null, this.format, this._extension);
        proxy._sphericalPolynomial = this._sphericalPolynomial;
        return;
      case InternalTextureSource.DepthStencil:
      case InternalTextureSource.Depth: {
        break;
      }
    }
  }
  /**
   * @internal
   */
  _swapAndDie(target, swapAll = true) {
    var _a;
    (_a = this._hardwareTexture) == null ? void 0 : _a.setUsage(target._source, this.generateMipMaps, this.is2DArray, this.isCube, this.is3D, this.width, this.height, this.depth);
    target._hardwareTexture = this._hardwareTexture;
    if (swapAll) {
      target._isRGBD = this._isRGBD;
    }
    if (this._lodTextureHigh) {
      if (target._lodTextureHigh) {
        target._lodTextureHigh.dispose();
      }
      target._lodTextureHigh = this._lodTextureHigh;
    }
    if (this._lodTextureMid) {
      if (target._lodTextureMid) {
        target._lodTextureMid.dispose();
      }
      target._lodTextureMid = this._lodTextureMid;
    }
    if (this._lodTextureLow) {
      if (target._lodTextureLow) {
        target._lodTextureLow.dispose();
      }
      target._lodTextureLow = this._lodTextureLow;
    }
    if (this._irradianceTexture) {
      if (target._irradianceTexture) {
        target._irradianceTexture.dispose();
      }
      target._irradianceTexture = this._irradianceTexture;
    }
    const cache = this._engine.getLoadedTexturesCache();
    let index = cache.indexOf(this);
    if (index !== -1) {
      cache.splice(index, 1);
    }
    index = cache.indexOf(target);
    if (index === -1) {
      cache.push(target);
    }
  }
  /**
   * Dispose the current allocated resources
   */
  dispose() {
    this._references--;
    this.onLoadedObservable.clear();
    this.onErrorObservable.clear();
    if (this._references === 0) {
      this._engine._releaseTexture(this);
      this._hardwareTexture = null;
      this._dynamicTextureSource = null;
    }
  }
};
InternalTexture._Counter = 0;

// node_modules/@babylonjs/core/Engines/WebGL/webGL2ShaderProcessors.js
var varyingRegex = /(flat\s)?\s*varying\s*.*/;
var WebGL2ShaderProcessor = class {
  constructor() {
    this.shaderLanguage = ShaderLanguage.GLSL;
  }
  attributeProcessor(attribute) {
    return attribute.replace("attribute", "in");
  }
  varyingCheck(varying, _isFragment) {
    return varyingRegex.test(varying);
  }
  varyingProcessor(varying, isFragment) {
    return varying.replace("varying", isFragment ? "in" : "out");
  }
  postProcessor(code, defines, isFragment) {
    const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;
    const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
    code = code.replace(regex, "");
    code = code.replace(/texture2D\s*\(/g, "texture(");
    if (isFragment) {
      const hasOutput = code.search(/layout *\(location *= *0\) *out/g) !== -1;
      code = code.replace(/texture2DLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCubeLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCube\s*\(/g, "texture(");
      code = code.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
      code = code.replace(/gl_FragColor/g, "glFragColor");
      code = code.replace(/gl_FragData/g, "glFragData");
      code = code.replace(/void\s+?main\s*\(/g, (hasDrawBuffersExtension || hasOutput ? "" : "layout(location = 0) out vec4 glFragColor;\n") + "void main(");
    } else {
      const hasMultiviewExtension = defines.indexOf("#define MULTIVIEW") !== -1;
      if (hasMultiviewExtension) {
        return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + code;
      }
    }
    return code;
  }
};

// node_modules/@babylonjs/core/Buffers/dataBuffer.js
var DataBuffer = class _DataBuffer {
  /**
   * Gets the underlying buffer
   */
  get underlyingResource() {
    return null;
  }
  /**
   * Constructs the buffer
   */
  constructor() {
    this.references = 0;
    this.capacity = 0;
    this.is32Bits = false;
    this.uniqueId = _DataBuffer._Counter++;
  }
};
DataBuffer._Counter = 0;

// node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js
var WebGLDataBuffer = class extends DataBuffer {
  constructor(resource) {
    super();
    this._buffer = resource;
  }
  get underlyingResource() {
    return this._buffer;
  }
};

// node_modules/@babylonjs/core/Engines/WebGL/webGLPipelineContext.js
var WebGLPipelineContext = class {
  constructor() {
    this._valueCache = {};
    this.vertexCompilationError = null;
    this.fragmentCompilationError = null;
    this.programLinkError = null;
    this.programValidationError = null;
    this._isDisposed = false;
  }
  get isAsync() {
    return this.isParallelCompiled;
  }
  get isReady() {
    if (this.program) {
      if (this.isParallelCompiled) {
        return this.engine._isRenderingStateCompiled(this);
      }
      return true;
    }
    return false;
  }
  _handlesSpectorRebuildCallback(onCompiled) {
    if (onCompiled && this.program) {
      onCompiled(this.program);
    }
  }
  _fillEffectInformation(effect, uniformBuffersNames, uniformsNames, uniforms, samplerList, samplers, attributesNames, attributes) {
    const engine = this.engine;
    if (engine.supportsUniformBuffers) {
      for (const name in uniformBuffersNames) {
        effect.bindUniformBlock(name, uniformBuffersNames[name]);
      }
    }
    const effectAvailableUniforms = this.engine.getUniforms(this, uniformsNames);
    effectAvailableUniforms.forEach((uniform, index2) => {
      uniforms[uniformsNames[index2]] = uniform;
    });
    this._uniforms = uniforms;
    let index;
    for (index = 0; index < samplerList.length; index++) {
      const sampler = effect.getUniform(samplerList[index]);
      if (sampler == null) {
        samplerList.splice(index, 1);
        index--;
      }
    }
    samplerList.forEach((name, index2) => {
      samplers[name] = index2;
    });
    for (const attr of engine.getAttributes(this, attributesNames)) {
      attributes.push(attr);
    }
  }
  /**
   * Release all associated resources.
   **/
  dispose() {
    this._uniforms = {};
    this._isDisposed = true;
  }
  /**
   * @internal
   */
  _cacheMatrix(uniformName, matrix) {
    const cache = this._valueCache[uniformName];
    const flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[uniformName] = flag;
    return true;
  }
  /**
   * @internal
   */
  _cacheFloat2(uniformName, x, y) {
    let cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 2) {
      cache = [x, y];
      this._valueCache[uniformName] = cache;
      return true;
    }
    let changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    return changed;
  }
  /**
   * @internal
   */
  _cacheFloat3(uniformName, x, y, z) {
    let cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 3) {
      cache = [x, y, z];
      this._valueCache[uniformName] = cache;
      return true;
    }
    let changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    if (cache[2] !== z) {
      cache[2] = z;
      changed = true;
    }
    return changed;
  }
  /**
   * @internal
   */
  _cacheFloat4(uniformName, x, y, z, w) {
    let cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 4) {
      cache = [x, y, z, w];
      this._valueCache[uniformName] = cache;
      return true;
    }
    let changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    if (cache[2] !== z) {
      cache[2] = z;
      changed = true;
    }
    if (cache[3] !== w) {
      cache[3] = w;
      changed = true;
    }
    return changed;
  }
  /**
   * Sets an integer value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param value Value to be set.
   */
  setInt(uniformName, value) {
    const cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === value) {
      return;
    }
    if (this.engine.setInt(this._uniforms[uniformName], value)) {
      this._valueCache[uniformName] = value;
    }
  }
  /**
   * Sets a int2 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First int in int2.
   * @param y Second int in int2.
   */
  setInt2(uniformName, x, y) {
    if (this._cacheFloat2(uniformName, x, y)) {
      if (!this.engine.setInt2(this._uniforms[uniformName], x, y)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a int3 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First int in int3.
   * @param y Second int in int3.
   * @param z Third int in int3.
   */
  setInt3(uniformName, x, y, z) {
    if (this._cacheFloat3(uniformName, x, y, z)) {
      if (!this.engine.setInt3(this._uniforms[uniformName], x, y, z)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a int4 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First int in int4.
   * @param y Second int in int4.
   * @param z Third int in int4.
   * @param w Fourth int in int4.
   */
  setInt4(uniformName, x, y, z, w) {
    if (this._cacheFloat4(uniformName, x, y, z, w)) {
      if (!this.engine.setInt4(this._uniforms[uniformName], x, y, z, w)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets an int array on a uniform variable.
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setIntArray(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray(this._uniforms[uniformName], array);
  }
  /**
   * Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setIntArray2(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray2(this._uniforms[uniformName], array);
  }
  /**
   * Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setIntArray3(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray3(this._uniforms[uniformName], array);
  }
  /**
   * Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setIntArray4(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray4(this._uniforms[uniformName], array);
  }
  /**
   * Sets an unsigned integer value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param value Value to be set.
   */
  setUInt(uniformName, value) {
    const cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === value) {
      return;
    }
    if (this.engine.setUInt(this._uniforms[uniformName], value)) {
      this._valueCache[uniformName] = value;
    }
  }
  /**
   * Sets an unsigned int2 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First unsigned int in uint2.
   * @param y Second unsigned int in uint2.
   */
  setUInt2(uniformName, x, y) {
    if (this._cacheFloat2(uniformName, x, y)) {
      if (!this.engine.setUInt2(this._uniforms[uniformName], x, y)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets an unsigned int3 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First unsigned int in uint3.
   * @param y Second unsigned int in uint3.
   * @param z Third unsigned int in uint3.
   */
  setUInt3(uniformName, x, y, z) {
    if (this._cacheFloat3(uniformName, x, y, z)) {
      if (!this.engine.setUInt3(this._uniforms[uniformName], x, y, z)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets an unsigned int4 value on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First unsigned int in uint4.
   * @param y Second unsigned int in uint4.
   * @param z Third unsigned int in uint4.
   * @param w Fourth unsigned int in uint4.
   */
  setUInt4(uniformName, x, y, z, w) {
    if (this._cacheFloat4(uniformName, x, y, z, w)) {
      if (!this.engine.setUInt4(this._uniforms[uniformName], x, y, z, w)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets an unsigned int array on a uniform variable.
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setUIntArray(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setUIntArray(this._uniforms[uniformName], array);
  }
  /**
   * Sets an unsigned int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setUIntArray2(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setUIntArray2(this._uniforms[uniformName], array);
  }
  /**
   * Sets an unsigned int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setUIntArray3(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setUIntArray3(this._uniforms[uniformName], array);
  }
  /**
   * Sets an unsigned int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setUIntArray4(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setUIntArray4(this._uniforms[uniformName], array);
  }
  /**
   * Sets an array on a uniform variable.
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setArray(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray(this._uniforms[uniformName], array);
  }
  /**
   * Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setArray2(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray2(this._uniforms[uniformName], array);
  }
  /**
   * Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setArray3(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray3(this._uniforms[uniformName], array);
  }
  /**
   * Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)
   * @param uniformName Name of the variable.
   * @param array array to be set.
   */
  setArray4(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray4(this._uniforms[uniformName], array);
  }
  /**
   * Sets matrices on a uniform variable.
   * @param uniformName Name of the variable.
   * @param matrices matrices to be set.
   */
  setMatrices(uniformName, matrices) {
    if (!matrices) {
      return;
    }
    this._valueCache[uniformName] = null;
    this.engine.setMatrices(this._uniforms[uniformName], matrices);
  }
  /**
   * Sets matrix on a uniform variable.
   * @param uniformName Name of the variable.
   * @param matrix matrix to be set.
   */
  setMatrix(uniformName, matrix) {
    if (this._cacheMatrix(uniformName, matrix)) {
      if (!this.engine.setMatrices(this._uniforms[uniformName], matrix.toArray())) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a 3x3 matrix on a uniform variable. (Specified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)
   * @param uniformName Name of the variable.
   * @param matrix matrix to be set.
   */
  setMatrix3x3(uniformName, matrix) {
    this._valueCache[uniformName] = null;
    this.engine.setMatrix3x3(this._uniforms[uniformName], matrix);
  }
  /**
   * Sets a 2x2 matrix on a uniform variable. (Specified as [1,2,3,4] will result in [1,2][3,4] matrix)
   * @param uniformName Name of the variable.
   * @param matrix matrix to be set.
   */
  setMatrix2x2(uniformName, matrix) {
    this._valueCache[uniformName] = null;
    this.engine.setMatrix2x2(this._uniforms[uniformName], matrix);
  }
  /**
   * Sets a float on a uniform variable.
   * @param uniformName Name of the variable.
   * @param value value to be set.
   */
  setFloat(uniformName, value) {
    const cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === value) {
      return;
    }
    if (this.engine.setFloat(this._uniforms[uniformName], value)) {
      this._valueCache[uniformName] = value;
    }
  }
  /**
   * Sets a Vector2 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param vector2 vector2 to be set.
   */
  setVector2(uniformName, vector2) {
    if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {
      if (!this.engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a float2 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First float in float2.
   * @param y Second float in float2.
   */
  setFloat2(uniformName, x, y) {
    if (this._cacheFloat2(uniformName, x, y)) {
      if (!this.engine.setFloat2(this._uniforms[uniformName], x, y)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a Vector3 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param vector3 Value to be set.
   */
  setVector3(uniformName, vector3) {
    if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {
      if (!this.engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a float3 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First float in float3.
   * @param y Second float in float3.
   * @param z Third float in float3.
   */
  setFloat3(uniformName, x, y, z) {
    if (this._cacheFloat3(uniformName, x, y, z)) {
      if (!this.engine.setFloat3(this._uniforms[uniformName], x, y, z)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a Vector4 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param vector4 Value to be set.
   */
  setVector4(uniformName, vector4) {
    if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a Quaternion on a uniform variable.
   * @param uniformName Name of the variable.
   * @param quaternion Value to be set.
   */
  setQuaternion(uniformName, quaternion) {
    if (this._cacheFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a float4 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param x First float in float4.
   * @param y Second float in float4.
   * @param z Third float in float4.
   * @param w Fourth float in float4.
   */
  setFloat4(uniformName, x, y, z, w) {
    if (this._cacheFloat4(uniformName, x, y, z, w)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a Color3 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param color3 Value to be set.
   */
  setColor3(uniformName, color3) {
    if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {
      if (!this.engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a Color4 on a uniform variable.
   * @param uniformName Name of the variable.
   * @param color3 Value to be set.
   * @param alpha Alpha value to be set.
   */
  setColor4(uniformName, color3, alpha) {
    if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  /**
   * Sets a Color4 on a uniform variable
   * @param uniformName defines the name of the variable
   * @param color4 defines the value to be set
   */
  setDirectColor4(uniformName, color4) {
    if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {
        this._valueCache[uniformName] = null;
      }
    }
  }
  _getVertexShaderCode() {
    return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;
  }
  _getFragmentShaderCode() {
    return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;
  }
};

// node_modules/@babylonjs/core/Engines/WebGL/webGLHardwareTexture.js
var WebGLHardwareTexture = class {
  get underlyingResource() {
    return this._webGLTexture;
  }
  constructor(existingTexture = null, context) {
    this._MSAARenderBuffers = null;
    this._context = context;
    if (!existingTexture) {
      existingTexture = context.createTexture();
      if (!existingTexture) {
        throw new Error("Unable to create webGL texture");
      }
    }
    this.set(existingTexture);
  }
  setUsage() {
  }
  set(hardwareTexture) {
    this._webGLTexture = hardwareTexture;
  }
  reset() {
    this._webGLTexture = null;
    this._MSAARenderBuffers = null;
  }
  addMSAARenderBuffer(buffer) {
    if (!this._MSAARenderBuffers) {
      this._MSAARenderBuffers = [];
    }
    this._MSAARenderBuffers.push(buffer);
  }
  releaseMSAARenderBuffers() {
    if (this._MSAARenderBuffers) {
      for (const buffer of this._MSAARenderBuffers) {
        this._context.deleteRenderbuffer(buffer);
      }
      this._MSAARenderBuffers = null;
    }
  }
  getMSAARenderBuffer(index = 0) {
    var _a;
    return ((_a = this._MSAARenderBuffers) == null ? void 0 : _a[index]) ?? null;
  }
  release() {
    this.releaseMSAARenderBuffers();
    if (this._webGLTexture) {
      this._context.deleteTexture(this._webGLTexture);
    }
    this.reset();
  }
};

// node_modules/@babylonjs/core/Materials/drawWrapper.js
var DrawWrapper = class {
  static IsWrapper(effect) {
    return effect.getPipelineContext === void 0;
  }
  static GetEffect(effect) {
    return effect.getPipelineContext === void 0 ? effect.effect : effect;
  }
  constructor(engine, createMaterialContext = true) {
    this._wasPreviouslyReady = false;
    this._forceRebindOnNextCall = true;
    this._wasPreviouslyUsingInstances = null;
    this.effect = null;
    this.defines = null;
    this.drawContext = engine.createDrawContext();
    if (createMaterialContext) {
      this.materialContext = engine.createMaterialContext();
    }
  }
  setEffect(effect, defines, resetContext = true) {
    var _a;
    this.effect = effect;
    if (defines !== void 0) {
      this.defines = defines;
    }
    if (resetContext) {
      (_a = this.drawContext) == null ? void 0 : _a.reset();
    }
  }
  dispose() {
    var _a;
    (_a = this.drawContext) == null ? void 0 : _a.dispose();
  }
};

// node_modules/@babylonjs/core/States/stencilStateComposer.js
var StencilStateComposer = class {
  get isDirty() {
    return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;
  }
  get func() {
    return this._func;
  }
  set func(value) {
    if (this._func === value) {
      return;
    }
    this._func = value;
    this._isStencilFuncDirty = true;
  }
  get funcRef() {
    return this._funcRef;
  }
  set funcRef(value) {
    if (this._funcRef === value) {
      return;
    }
    this._funcRef = value;
    this._isStencilFuncDirty = true;
  }
  get funcMask() {
    return this._funcMask;
  }
  set funcMask(value) {
    if (this._funcMask === value) {
      return;
    }
    this._funcMask = value;
    this._isStencilFuncDirty = true;
  }
  get opStencilFail() {
    return this._opStencilFail;
  }
  set opStencilFail(value) {
    if (this._opStencilFail === value) {
      return;
    }
    this._opStencilFail = value;
    this._isStencilOpDirty = true;
  }
  get opDepthFail() {
    return this._opDepthFail;
  }
  set opDepthFail(value) {
    if (this._opDepthFail === value) {
      return;
    }
    this._opDepthFail = value;
    this._isStencilOpDirty = true;
  }
  get opStencilDepthPass() {
    return this._opStencilDepthPass;
  }
  set opStencilDepthPass(value) {
    if (this._opStencilDepthPass === value) {
      return;
    }
    this._opStencilDepthPass = value;
    this._isStencilOpDirty = true;
  }
  get mask() {
    return this._mask;
  }
  set mask(value) {
    if (this._mask === value) {
      return;
    }
    this._mask = value;
    this._isStencilMaskDirty = true;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled === value) {
      return;
    }
    this._enabled = value;
    this._isStencilTestDirty = true;
  }
  constructor(reset = true) {
    this._isStencilTestDirty = false;
    this._isStencilMaskDirty = false;
    this._isStencilFuncDirty = false;
    this._isStencilOpDirty = false;
    this.useStencilGlobalOnly = false;
    if (reset) {
      this.reset();
    }
  }
  reset() {
    var _a;
    this.stencilMaterial = void 0;
    (_a = this.stencilGlobal) == null ? void 0 : _a.reset();
    this._isStencilTestDirty = true;
    this._isStencilMaskDirty = true;
    this._isStencilFuncDirty = true;
    this._isStencilOpDirty = true;
  }
  apply(gl) {
    var _a;
    if (!gl) {
      return;
    }
    const stencilMaterialEnabled = !this.useStencilGlobalOnly && !!((_a = this.stencilMaterial) == null ? void 0 : _a.enabled);
    this.enabled = stencilMaterialEnabled ? this.stencilMaterial.enabled : this.stencilGlobal.enabled;
    this.func = stencilMaterialEnabled ? this.stencilMaterial.func : this.stencilGlobal.func;
    this.funcRef = stencilMaterialEnabled ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef;
    this.funcMask = stencilMaterialEnabled ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask;
    this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail;
    this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail;
    this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;
    this.mask = stencilMaterialEnabled ? this.stencilMaterial.mask : this.stencilGlobal.mask;
    if (!this.isDirty) {
      return;
    }
    if (this._isStencilTestDirty) {
      if (this.enabled) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }
      this._isStencilTestDirty = false;
    }
    if (this._isStencilMaskDirty) {
      gl.stencilMask(this.mask);
      this._isStencilMaskDirty = false;
    }
    if (this._isStencilFuncDirty) {
      gl.stencilFunc(this.func, this.funcRef, this.funcMask);
      this._isStencilFuncDirty = false;
    }
    if (this._isStencilOpDirty) {
      gl.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass);
      this._isStencilOpDirty = false;
    }
  }
};

// node_modules/@babylonjs/core/Engines/WebGL/webGLShaderProcessors.js
var WebGLShaderProcessor = class {
  constructor() {
    this.shaderLanguage = ShaderLanguage.GLSL;
  }
  postProcessor(code, defines, isFragment, processingContext, engine) {
    if (!engine.getCaps().drawBuffersExtension) {
      const regex = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
      code = code.replace(regex, "");
    }
    return code;
  }
};

// node_modules/@babylonjs/core/Engines/thinEngine.js
var BufferPointer = class {
};
var ThinEngine = class _ThinEngine {
  /**
   * Returns the current npm package of the sdk
   */
  // Not mixed with Version for tooling purpose.
  static get NpmPackage() {
    return "babylonjs@6.44.0";
  }
  /**
   * Returns the current version of the framework
   */
  static get Version() {
    return "6.44.0";
  }
  /**
   * Returns a string describing the current engine
   */
  get description() {
    let description = this.name + this.webGLVersion;
    if (this._caps.parallelShaderCompile) {
      description += " - Parallel shader compilation";
    }
    return description;
  }
  /**
   * Gets or sets the name of the engine
   */
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  /**
   * Returns the version of the engine
   */
  get version() {
    return this._webGLVersion;
  }
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Gets or sets the relative url used to load shaders if using the engine in non-minified mode
   */
  static get ShadersRepository() {
    return Effect.ShadersRepository;
  }
  static set ShadersRepository(value) {
    Effect.ShadersRepository = value;
  }
  /**
   * @internal
   */
  _getShaderProcessor(shaderLanguage) {
    return this._shaderProcessor;
  }
  /**
   * Gets or sets a boolean indicating if depth buffer should be reverse, going from far to near.
   * This can provide greater z depth for distant objects.
   */
  get useReverseDepthBuffer() {
    return this._useReverseDepthBuffer;
  }
  set useReverseDepthBuffer(useReverse) {
    if (useReverse === this._useReverseDepthBuffer) {
      return;
    }
    this._useReverseDepthBuffer = useReverse;
    if (useReverse) {
      this._depthCullingState.depthFunc = 518;
    } else {
      this._depthCullingState.depthFunc = 515;
    }
  }
  /**
   * Gets the current frame id
   */
  get frameId() {
    return this._frameId;
  }
  /**
   * Gets a boolean indicating that the engine supports uniform buffers
   * @see https://doc.babylonjs.com/setup/support/webGL2#uniform-buffer-objets
   */
  get supportsUniformBuffers() {
    return this.webGLVersion > 1 && !this.disableUniformBuffers;
  }
  /**
   * Gets the options used for engine creation
   * @returns EngineOptions object
   */
  getCreationOptions() {
    return this._creationOptions;
  }
  /** @internal */
  get _shouldUseHighPrecisionShader() {
    return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);
  }
  /**
   * Gets a boolean indicating that only power of 2 textures are supported
   * Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them
   */
  get needPOTTextures() {
    return this._webGLVersion < 2 || this.forcePOTTextures;
  }
  /**
   * Gets the list of current active render loop functions
   * @returns an array with the current render loop functions
   */
  get activeRenderLoops() {
    return this._activeRenderLoops;
  }
  /**
   * Gets or sets a boolean indicating if resources should be retained to be able to handle context lost events
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#handling-webgl-context-lost
   */
  get doNotHandleContextLost() {
    return this._doNotHandleContextLost;
  }
  set doNotHandleContextLost(value) {
    this._doNotHandleContextLost = value;
  }
  get _supportsHardwareTextureRescaling() {
    return false;
  }
  /**
   * sets the object from which width and height will be taken from when getting render width and height
   * Will fallback to the gl object
   * @param dimensions the framebuffer width and height that will be used.
   */
  set framebufferDimensionsObject(dimensions) {
    this._framebufferDimensionsObject = dimensions;
  }
  /**
   * Gets the current viewport
   */
  get currentViewport() {
    return this._cachedViewport;
  }
  /**
   * Gets the default empty texture
   */
  get emptyTexture() {
    if (!this._emptyTexture) {
      this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, false, false, 1);
    }
    return this._emptyTexture;
  }
  /**
   * Gets the default empty 3D texture
   */
  get emptyTexture3D() {
    if (!this._emptyTexture3D) {
      this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
    }
    return this._emptyTexture3D;
  }
  /**
   * Gets the default empty 2D array texture
   */
  get emptyTexture2DArray() {
    if (!this._emptyTexture2DArray) {
      this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
    }
    return this._emptyTexture2DArray;
  }
  /**
   * Gets the default empty cube texture
   */
  get emptyCubeTexture() {
    if (!this._emptyCubeTexture) {
      const faceData = new Uint8Array(4);
      const cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];
      this._emptyCubeTexture = this.createRawCubeTexture(cubeData, 1, 5, 0, false, false, 1);
    }
    return this._emptyCubeTexture;
  }
  /**
   * Gets a boolean indicating if the engine runs in WebGPU or not.
   */
  get isWebGPU() {
    return this._isWebGPU;
  }
  /**
   * Gets the shader platform name used by the effects.
   */
  get shaderPlatformName() {
    return this._shaderPlatformName;
  }
  /**
   * Enables or disables the snapshot rendering mode
   * Note that the WebGL engine does not support snapshot rendering so setting the value won't have any effect for this engine
   */
  get snapshotRendering() {
    return false;
  }
  set snapshotRendering(activate) {
  }
  /**
   * Gets or sets the snapshot rendering mode
   */
  get snapshotRenderingMode() {
    return this._snapshotRenderingMode;
  }
  set snapshotRenderingMode(mode) {
    this._snapshotRenderingMode = mode;
  }
  /**
   * Creates a new snapshot at the next frame using the current snapshotRenderingMode
   */
  snapshotRenderingReset() {
    this.snapshotRendering = false;
  }
  static _CreateCanvas(width, height) {
    if (typeof document === "undefined") {
      return new OffscreenCanvas(width, height);
    }
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
  /**
   * Create a canvas. This method is overridden by other engines
   * @param width width
   * @param height height
   * @returns ICanvas interface
   */
  createCanvas(width, height) {
    return _ThinEngine._CreateCanvas(width, height);
  }
  /**
   * Create an image to use with canvas
   * @returns IImage interface
   */
  createCanvasImage() {
    return document.createElement("img");
  }
  /**
   * Creates a new engine
   * @param canvasOrContext defines the canvas or WebGL context to use for rendering. If you provide a WebGL context, Babylon.js will not hook events on the canvas (like pointers, keyboards, etc...) so no event observables will be available. This is mostly used when Babylon.js is used as a plugin on a system which already used the WebGL context
   * @param antialias defines enable antialiasing (default: false)
   * @param options defines further options to be sent to the getContext() function
   * @param adaptToDeviceRatio defines whether to adapt to the device's viewport characteristics (default: false)
   */
  constructor(canvasOrContext, antialias, options, adaptToDeviceRatio) {
    var _a, _b;
    this._name = "WebGL";
    this._isDisposed = false;
    this.forcePOTTextures = false;
    this.isFullscreen = false;
    this.cullBackFaces = null;
    this.renderEvenInBackground = true;
    this.preventCacheWipeBetweenFrames = false;
    this.validateShaderPrograms = false;
    this._useReverseDepthBuffer = false;
    this.isNDCHalfZRange = false;
    this.hasOriginBottomLeft = true;
    this.disableUniformBuffers = false;
    this.onDisposeObservable = new Observable();
    this._frameId = 0;
    this._uniformBuffers = new Array();
    this._storageBuffers = new Array();
    this._webGLVersion = 1;
    this._windowIsBackground = false;
    this._highPrecisionShadersAllowed = true;
    this._badOS = false;
    this._badDesktopOS = false;
    this._renderingQueueLaunched = false;
    this._activeRenderLoops = new Array();
    this.onContextLostObservable = new Observable();
    this.onContextRestoredObservable = new Observable();
    this._contextWasLost = false;
    this._doNotHandleContextLost = false;
    this.disableVertexArrayObjects = false;
    this._colorWrite = true;
    this._colorWriteChanged = true;
    this._depthCullingState = new DepthCullingState();
    this._stencilStateComposer = new StencilStateComposer();
    this._stencilState = new StencilState();
    this._alphaState = new AlphaState();
    this._alphaMode = 1;
    this._alphaEquation = 0;
    this._internalTexturesCache = new Array();
    this._renderTargetWrapperCache = new Array();
    this._activeChannel = 0;
    this._currentTextureChannel = -1;
    this._boundTexturesCache = {};
    this._compiledEffects = {};
    this._vertexAttribArraysEnabled = [];
    this._currentRenderTarget = null;
    this._uintIndicesCurrentlySet = false;
    this._currentBoundBuffer = new Array();
    this._currentFramebuffer = null;
    this._dummyFramebuffer = null;
    this._currentBufferPointers = new Array();
    this._currentInstanceLocations = new Array();
    this._currentInstanceBuffers = new Array();
    this._vaoRecordInProgress = false;
    this._mustWipeVertexAttributes = false;
    this._nextFreeTextureSlots = new Array();
    this._maxSimultaneousTextures = 0;
    this._maxMSAASamplesOverride = null;
    this._activeRequests = new Array();
    this.adaptToDeviceRatio = false;
    this._lastDevicePixelRatio = 1;
    this._transformTextureUrl = null;
    this.hostInformation = {
      isMobile: false
    };
    this.premultipliedAlpha = true;
    this.onBeforeTextureInitObservable = new Observable();
    this._isWebGPU = false;
    this._snapshotRenderingMode = 0;
    this._viewportCached = { x: 0, y: 0, z: 0, w: 0 };
    this._unpackFlipYCached = null;
    this.enableUnpackFlipYCached = true;
    this._boundUniforms = {};
    this.startTime = PrecisionDate.Now;
    let canvas = null;
    options = options || {};
    this._creationOptions = options;
    this.adaptToDeviceRatio = adaptToDeviceRatio ?? false;
    this._stencilStateComposer.stencilGlobal = this._stencilState;
    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);
    options.antialias = antialias ?? options.antialias;
    options.deterministicLockstep = options.deterministicLockstep ?? false;
    options.lockstepMaxSteps = options.lockstepMaxSteps ?? 4;
    options.timeStep = options.timeStep ?? 1 / 60;
    options.audioEngine = options.audioEngine ?? true;
    options.stencil = options.stencil ?? true;
    this._audioContext = ((_a = options.audioEngineOptions) == null ? void 0 : _a.audioContext) ?? null;
    this._audioDestination = ((_b = options.audioEngineOptions) == null ? void 0 : _b.audioDestination) ?? null;
    this.premultipliedAlpha = options.premultipliedAlpha ?? true;
    this.useExactSrgbConversions = options.useExactSrgbConversions ?? false;
    this._doNotHandleContextLost = !!options.doNotHandleContextLost;
    this._isStencilEnable = options.stencil ? true : false;
    adaptToDeviceRatio = adaptToDeviceRatio || options.adaptToDeviceRatio || false;
    const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
    const limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;
    this._hardwareScalingLevel = adaptToDeviceRatio ? 1 / Math.min(limitDeviceRatio, devicePixelRatio) : 1;
    this._lastDevicePixelRatio = devicePixelRatio;
    if (!canvasOrContext) {
      return;
    }
    if (canvasOrContext.getContext) {
      canvas = canvasOrContext;
      this._renderingCanvas = canvas;
      if (options.preserveDrawingBuffer === void 0) {
        options.preserveDrawingBuffer = false;
      }
      if (options.xrCompatible === void 0) {
        options.xrCompatible = true;
      }
      if (navigator && navigator.userAgent) {
        this._setupMobileChecks();
        const ua = navigator.userAgent;
        for (const exception of _ThinEngine.ExceptionList) {
          const key = exception.key;
          const targets = exception.targets;
          const check = new RegExp(key);
          if (check.test(ua)) {
            if (exception.capture && exception.captureConstraint) {
              const capture = exception.capture;
              const constraint = exception.captureConstraint;
              const regex = new RegExp(capture);
              const matches = regex.exec(ua);
              if (matches && matches.length > 0) {
                const capturedValue = parseInt(matches[matches.length - 1]);
                if (capturedValue >= constraint) {
                  continue;
                }
              }
            }
            for (const target of targets) {
              switch (target) {
                case "uniformBuffer":
                  this.disableUniformBuffers = true;
                  break;
                case "vao":
                  this.disableVertexArrayObjects = true;
                  break;
                case "antialias":
                  options.antialias = false;
                  break;
                case "maxMSAASamples":
                  this._maxMSAASamplesOverride = 1;
                  break;
              }
            }
          }
        }
      }
      if (!this._doNotHandleContextLost) {
        this._onContextLost = (evt) => {
          evt.preventDefault();
          this._contextWasLost = true;
          Logger.Warn("WebGL context lost.");
          this.onContextLostObservable.notifyObservers(this);
        };
        this._onContextRestored = () => {
          this._restoreEngineAfterContextLost(() => this._initGLContext());
        };
        canvas.addEventListener("webglcontextlost", this._onContextLost, false);
        canvas.addEventListener("webglcontextrestored", this._onContextRestored, false);
        options.powerPreference = options.powerPreference || "high-performance";
      }
      this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (this._badDesktopOS) {
        options.xrCompatible = false;
      }
      if (!options.disableWebGL2Support) {
        try {
          this._gl = canvas.getContext("webgl2", options) || canvas.getContext("experimental-webgl2", options);
          if (this._gl) {
            this._webGLVersion = 2;
            this._shaderPlatformName = "WEBGL2";
            if (!this._gl.deleteQuery) {
              this._webGLVersion = 1;
              this._shaderPlatformName = "WEBGL1";
            }
          }
        } catch (e) {
        }
      }
      if (!this._gl) {
        if (!canvas) {
          throw new Error("The provided canvas is null or undefined.");
        }
        try {
          this._gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        } catch (e) {
          throw new Error("WebGL not supported");
        }
      }
      if (!this._gl) {
        throw new Error("WebGL not supported");
      }
    } else {
      this._gl = canvasOrContext;
      this._renderingCanvas = this._gl.canvas;
      if (this._gl.renderbufferStorageMultisample) {
        this._webGLVersion = 2;
        this._shaderPlatformName = "WEBGL2";
      } else {
        this._shaderPlatformName = "WEBGL1";
      }
      const attributes = this._gl.getContextAttributes();
      if (attributes) {
        options.stencil = attributes.stencil;
      }
    }
    this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
    if (options.useHighPrecisionFloats !== void 0) {
      this._highPrecisionShadersAllowed = options.useHighPrecisionFloats;
    }
    this.resize();
    this._initGLContext();
    this._initFeatures();
    for (let i = 0; i < this._caps.maxVertexAttribs; i++) {
      this._currentBufferPointers[i] = new BufferPointer();
    }
    this._shaderProcessor = this.webGLVersion > 1 ? new WebGL2ShaderProcessor() : new WebGLShaderProcessor();
    this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);
    const versionToLog = `Babylon.js v${_ThinEngine.Version}`;
    Logger.Log(versionToLog + ` - ${this.description}`);
    if (this._renderingCanvas && this._renderingCanvas.setAttribute) {
      this._renderingCanvas.setAttribute("data-engine", versionToLog);
    }
  }
  _setupMobileChecks() {
    if (!(navigator && navigator.userAgent)) {
      return;
    }
    this._checkForMobile = () => {
      const currentUA = navigator.userAgent;
      this.hostInformation.isMobile = currentUA.indexOf("Mobile") !== -1 || // Needed for iOS 13+ detection on iPad (inspired by solution from https://stackoverflow.com/questions/9038625/detect-if-device-is-ios)
      currentUA.indexOf("Mac") !== -1 && IsDocumentAvailable() && "ontouchend" in document;
    };
    this._checkForMobile();
    if (IsWindowObjectExist()) {
      window.addEventListener("resize", this._checkForMobile);
    }
  }
  _restoreEngineAfterContextLost(initEngine) {
    setTimeout(async () => {
      var _a;
      this._dummyFramebuffer = null;
      this._emptyTexture = null;
      this._emptyCubeTexture = null;
      this._emptyTexture3D = null;
      this._emptyTexture2DArray = null;
      const depthTest = this._depthCullingState.depthTest;
      const depthFunc = this._depthCullingState.depthFunc;
      const depthMask = this._depthCullingState.depthMask;
      const stencilTest = this._stencilState.stencilTest;
      await initEngine();
      this.wipeCaches(true);
      this._rebuildEffects();
      (_a = this._rebuildComputeEffects) == null ? void 0 : _a.call(this);
      this._rebuildBuffers();
      this._rebuildInternalTextures();
      this._rebuildTextures();
      this._rebuildRenderTargetWrappers();
      this.wipeCaches(true);
      this._depthCullingState.depthTest = depthTest;
      this._depthCullingState.depthFunc = depthFunc;
      this._depthCullingState.depthMask = depthMask;
      this._stencilState.stencilTest = stencilTest;
      Logger.Warn(this.name + " context successfully restored.");
      this.onContextRestoredObservable.notifyObservers(this);
      this._contextWasLost = false;
    }, 0);
  }
  /**
   * Shared initialization across engines types.
   * @param canvas The canvas associated with this instance of the engine.
   */
  _sharedInit(canvas) {
    this._renderingCanvas = canvas;
  }
  /**
   * @internal
   */
  _getShaderProcessingContext(shaderLanguage) {
    return null;
  }
  _rebuildInternalTextures() {
    const currentState = this._internalTexturesCache.slice();
    for (const internalTexture of currentState) {
      internalTexture._rebuild();
    }
  }
  _rebuildRenderTargetWrappers() {
    const currentState = this._renderTargetWrapperCache.slice();
    for (const renderTargetWrapper of currentState) {
      renderTargetWrapper._rebuild();
    }
  }
  _rebuildEffects() {
    for (const key in this._compiledEffects) {
      const effect = this._compiledEffects[key];
      effect._pipelineContext = null;
      effect._prepareEffect();
    }
    Effect.ResetCache();
  }
  /**
   * Gets a boolean indicating if all created effects are ready
   * @returns true if all effects are ready
   */
  areAllEffectsReady() {
    for (const key in this._compiledEffects) {
      const effect = this._compiledEffects[key];
      if (!effect.isReady()) {
        return false;
      }
    }
    return true;
  }
  _rebuildBuffers() {
    for (const uniformBuffer of this._uniformBuffers) {
      uniformBuffer._rebuildAfterContextLost();
    }
  }
  _rebuildTextures() {
  }
  _initGLContext() {
    this._caps = {
      maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
      maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
      maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
      maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
      maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
      maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
      maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
      maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
      maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
      parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0,
      standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null,
      maxAnisotropy: 1,
      astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
      bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
      s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
      // eslint-disable-next-line @typescript-eslint/naming-convention
      s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
      pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
      etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
      textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
      uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null,
      fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null,
      highPrecisionShaderSupported: false,
      timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
      supportOcclusionQuery: this._webGLVersion > 1,
      canUseTimestampForTimerQuery: false,
      drawBuffersExtension: false,
      maxMSAASamples: 1,
      colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
      supportFloatTexturesResolve: false,
      rg11b10ufColorRenderable: false,
      colorBufferHalfFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_half_float")),
      textureFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float") ? true : false,
      textureHalfFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float") ? true : false,
      textureHalfFloatRender: false,
      textureFloatLinearFiltering: false,
      textureFloatRender: false,
      textureHalfFloatLinearFiltering: false,
      vertexArrayObject: false,
      instancedArrays: false,
      textureLOD: this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod") ? true : false,
      texelFetch: this._webGLVersion !== 1,
      blendMinMax: false,
      multiview: this._gl.getExtension("OVR_multiview2"),
      oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
      depthTextureExtension: false,
      canUseGLInstanceID: this._webGLVersion > 1,
      canUseGLVertexID: this._webGLVersion > 1,
      supportComputeShaders: false,
      supportSRGBBuffers: false,
      supportTransformFeedbacks: this._webGLVersion > 1,
      textureMaxLevel: this._webGLVersion > 1,
      texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_ARRAY_TEXTURE_LAYERS) : 128,
      disableMorphTargetTexture: false
    };
    this._caps.supportFloatTexturesResolve = this._caps.colorBufferFloat;
    this._caps.rg11b10ufColorRenderable = this._caps.colorBufferFloat;
    this._glVersion = this._gl.getParameter(this._gl.VERSION);
    const rendererInfo = this._gl.getExtension("WEBGL_debug_renderer_info");
    if (rendererInfo != null) {
      this._glRenderer = this._gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);
      this._glVendor = this._gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);
    }
    if (!this._glVendor) {
      this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor";
    }
    if (!this._glRenderer) {
      this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer";
    }
    if (this._gl.HALF_FLOAT_OES !== 36193) {
      this._gl.HALF_FLOAT_OES = 36193;
    }
    if (this._gl.RGBA16F !== 34842) {
      this._gl.RGBA16F = 34842;
    }
    if (this._gl.RGBA32F !== 34836) {
      this._gl.RGBA32F = 34836;
    }
    if (this._gl.DEPTH24_STENCIL8 !== 35056) {
      this._gl.DEPTH24_STENCIL8 = 35056;
    }
    if (this._caps.timerQuery) {
      if (this._webGLVersion === 1) {
        this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery);
      }
      this._caps.canUseTimestampForTimerQuery = (this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT) ?? 0) > 0;
    }
    this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
    this._caps.textureFloatLinearFiltering = this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear") ? true : false;
    this._caps.textureFloatRender = this._caps.textureFloat && this._canRenderToFloatFramebuffer() ? true : false;
    this._caps.textureHalfFloatLinearFiltering = this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear") ? true : false;
    if (this._caps.astc) {
      this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
    }
    if (this._caps.bptc) {
      this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
    }
    if (this._caps.s3tc_srgb) {
      this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT;
      this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
      this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    }
    if (this._caps.etc2) {
      this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2;
      this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
    }
    if (this._webGLVersion > 1) {
      if (this._gl.HALF_FLOAT_OES !== 5131) {
        this._gl.HALF_FLOAT_OES = 5131;
      }
    }
    this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer();
    if (this._webGLVersion > 1) {
      this._caps.drawBuffersExtension = true;
      this._caps.maxMSAASamples = this._maxMSAASamplesOverride !== null ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES);
    } else {
      const drawBuffersExtension = this._gl.getExtension("WEBGL_draw_buffers");
      if (drawBuffersExtension !== null) {
        this._caps.drawBuffersExtension = true;
        this._gl.drawBuffers = drawBuffersExtension.drawBuffersWEBGL.bind(drawBuffersExtension);
        this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
        for (let i = 0; i < 16; i++) {
          this._gl["COLOR_ATTACHMENT" + i + "_WEBGL"] = drawBuffersExtension["COLOR_ATTACHMENT" + i + "_WEBGL"];
        }
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.depthTextureExtension = true;
    } else {
      const depthTextureExtension = this._gl.getExtension("WEBGL_depth_texture");
      if (depthTextureExtension != null) {
        this._caps.depthTextureExtension = true;
        this._gl.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
      }
    }
    if (this.disableVertexArrayObjects) {
      this._caps.vertexArrayObject = false;
    } else if (this._webGLVersion > 1) {
      this._caps.vertexArrayObject = true;
    } else {
      const vertexArrayObjectExtension = this._gl.getExtension("OES_vertex_array_object");
      if (vertexArrayObjectExtension != null) {
        this._caps.vertexArrayObject = true;
        this._gl.createVertexArray = vertexArrayObjectExtension.createVertexArrayOES.bind(vertexArrayObjectExtension);
        this._gl.bindVertexArray = vertexArrayObjectExtension.bindVertexArrayOES.bind(vertexArrayObjectExtension);
        this._gl.deleteVertexArray = vertexArrayObjectExtension.deleteVertexArrayOES.bind(vertexArrayObjectExtension);
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.instancedArrays = true;
    } else {
      const instanceExtension = this._gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExtension != null) {
        this._caps.instancedArrays = true;
        this._gl.drawArraysInstanced = instanceExtension.drawArraysInstancedANGLE.bind(instanceExtension);
        this._gl.drawElementsInstanced = instanceExtension.drawElementsInstancedANGLE.bind(instanceExtension);
        this._gl.vertexAttribDivisor = instanceExtension.vertexAttribDivisorANGLE.bind(instanceExtension);
      } else {
        this._caps.instancedArrays = false;
      }
    }
    if (this._gl.getShaderPrecisionFormat) {
      const vertexhighp = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT);
      const fragmenthighp = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
      if (vertexhighp && fragmenthighp) {
        this._caps.highPrecisionShaderSupported = vertexhighp.precision !== 0 && fragmenthighp.precision !== 0;
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.blendMinMax = true;
    } else {
      const blendMinMaxExtension = this._gl.getExtension("EXT_blend_minmax");
      if (blendMinMaxExtension != null) {
        this._caps.blendMinMax = true;
        this._gl.MAX = blendMinMaxExtension.MAX_EXT;
        this._gl.MIN = blendMinMaxExtension.MIN_EXT;
      }
    }
    if (!this._caps.supportSRGBBuffers) {
      if (this._webGLVersion > 1) {
        this._caps.supportSRGBBuffers = true;
        this._glSRGBExtensionValues = {
          SRGB: WebGL2RenderingContext.SRGB,
          SRGB8: WebGL2RenderingContext.SRGB8,
          SRGB8_ALPHA8: WebGL2RenderingContext.SRGB8_ALPHA8
        };
      } else {
        const sRGBExtension = this._gl.getExtension("EXT_sRGB");
        if (sRGBExtension != null) {
          this._caps.supportSRGBBuffers = true;
          this._glSRGBExtensionValues = {
            SRGB: sRGBExtension.SRGB_EXT,
            SRGB8: sRGBExtension.SRGB_ALPHA_EXT,
            SRGB8_ALPHA8: sRGBExtension.SRGB_ALPHA_EXT
          };
        }
      }
      this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !!(this._creationOptions && this._creationOptions.forceSRGBBufferSupportState);
    }
    this._depthCullingState.depthTest = true;
    this._depthCullingState.depthFunc = this._gl.LEQUAL;
    this._depthCullingState.depthMask = true;
    this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
    for (let slot = 0; slot < this._maxSimultaneousTextures; slot++) {
      this._nextFreeTextureSlots.push(slot);
    }
    if (this._glRenderer === "Mali-G72") {
      this._caps.disableMorphTargetTexture = true;
    }
  }
  _initFeatures() {
    this._features = {
      forceBitmapOverHTMLImageElement: typeof HTMLImageElement === "undefined",
      supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1,
      supportDepthStencilTexture: this._webGLVersion !== 1,
      supportShadowSamplers: this._webGLVersion !== 1,
      uniformBufferHardCheckMatrix: false,
      allowTexturePrefiltering: this._webGLVersion !== 1,
      trackUbosInFrame: false,
      checkUbosContentBeforeUpload: false,
      supportCSM: this._webGLVersion !== 1,
      basisNeedsPOT: this._webGLVersion === 1,
      support3DTextures: this._webGLVersion !== 1,
      needTypeSuffixInShaderConstants: this._webGLVersion !== 1,
      supportMSAA: this._webGLVersion !== 1,
      supportSSAO2: this._webGLVersion !== 1,
      supportExtendedTextureFormats: this._webGLVersion !== 1,
      supportSwitchCaseInShader: this._webGLVersion !== 1,
      supportSyncTextureRead: true,
      needsInvertingBitmap: true,
      useUBOBindingCache: true,
      needShaderCodeInlining: false,
      needToAlwaysBindUniformBuffers: false,
      supportRenderPasses: false,
      supportSpriteInstancing: true,
      forceVertexBufferStrideMultiple4Bytes: false,
      _collectUbosUpdatedInFrame: false
    };
  }
  /**
   * Gets version of the current webGL context
   * Keep it for back compat - use version instead
   */
  get webGLVersion() {
    return this._webGLVersion;
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "Engine" string
   */
  getClassName() {
    return "ThinEngine";
  }
  /**
   * Returns true if the stencil buffer has been enabled through the creation option of the context.
   */
  get isStencilEnable() {
    return this._isStencilEnable;
  }
  /** @internal */
  _prepareWorkingCanvas() {
    if (this._workingCanvas) {
      return;
    }
    this._workingCanvas = this.createCanvas(1, 1);
    const context = this._workingCanvas.getContext("2d");
    if (context) {
      this._workingContext = context;
    }
  }
  /**
   * Reset the texture cache to empty state
   */
  resetTextureCache() {
    for (const key in this._boundTexturesCache) {
      if (!Object.prototype.hasOwnProperty.call(this._boundTexturesCache, key)) {
        continue;
      }
      this._boundTexturesCache[key] = null;
    }
    this._currentTextureChannel = -1;
  }
  /**
   * Gets an object containing information about the current engine context
   * @returns an object containing the vendor, the renderer and the version of the current engine context
   */
  getInfo() {
    return this.getGlInfo();
  }
  /**
   * Gets an object containing information about the current webGL context
   * @returns an object containing the vendor, the renderer and the version of the current webGL context
   */
  getGlInfo() {
    return {
      vendor: this._glVendor,
      renderer: this._glRenderer,
      version: this._glVersion
    };
  }
  /**
   * Defines the hardware scaling level.
   * By default the hardware scaling level is computed from the window device ratio.
   * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
   * @param level defines the level to use
   */
  setHardwareScalingLevel(level) {
    this._hardwareScalingLevel = level;
    this.resize();
  }
  /**
   * Gets the current hardware scaling level.
   * By default the hardware scaling level is computed from the window device ratio.
   * if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
   * @returns a number indicating the current hardware scaling level
   */
  getHardwareScalingLevel() {
    return this._hardwareScalingLevel;
  }
  /**
   * Gets the list of loaded textures
   * @returns an array containing all loaded textures
   */
  getLoadedTexturesCache() {
    return this._internalTexturesCache;
  }
  /**
   * Gets the object containing all engine capabilities
   * @returns the EngineCapabilities object
   */
  getCaps() {
    return this._caps;
  }
  /**
   * stop executing a render loop function and remove it from the execution array
   * @param renderFunction defines the function to be removed. If not provided all functions will be removed.
   */
  stopRenderLoop(renderFunction) {
    if (!renderFunction) {
      this._activeRenderLoops.length = 0;
      this._cancelFrame();
      return;
    }
    const index = this._activeRenderLoops.indexOf(renderFunction);
    if (index >= 0) {
      this._activeRenderLoops.splice(index, 1);
      if (this._activeRenderLoops.length == 0) {
        this._cancelFrame();
      }
    }
  }
  _cancelFrame() {
    if (this._renderingQueueLaunched && this._frameHandler) {
      this._renderingQueueLaunched = false;
      if (!IsWindowObjectExist()) {
        if (typeof cancelAnimationFrame === "function") {
          return cancelAnimationFrame(this._frameHandler);
        }
      } else {
        const { cancelAnimationFrame: cancelAnimationFrame2 } = this.getHostWindow() || window;
        if (typeof cancelAnimationFrame2 === "function") {
          return cancelAnimationFrame2(this._frameHandler);
        }
      }
      return clearTimeout(this._frameHandler);
    }
  }
  /** @internal */
  _renderLoop() {
    if (!this._contextWasLost) {
      let shouldRender = true;
      if (this._isDisposed || !this.renderEvenInBackground && this._windowIsBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this.beginFrame();
        for (let index = 0; index < this._activeRenderLoops.length; index++) {
          const renderFunction = this._activeRenderLoops[index];
          renderFunction();
        }
        this.endFrame();
      }
    }
    if (this._activeRenderLoops.length > 0) {
      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
    } else {
      this._renderingQueueLaunched = false;
    }
  }
  /**
   * Gets the HTML canvas attached with the current webGL context
   * @returns a HTML canvas
   */
  getRenderingCanvas() {
    return this._renderingCanvas;
  }
  /**
   * Gets the audio context specified in engine initialization options
   * @returns an Audio Context
   */
  getAudioContext() {
    return this._audioContext;
  }
  /**
   * Gets the audio destination specified in engine initialization options
   * @returns an audio destination node
   */
  getAudioDestination() {
    return this._audioDestination;
  }
  /**
   * Gets host window
   * @returns the host window object
   */
  getHostWindow() {
    if (!IsWindowObjectExist()) {
      return null;
    }
    if (this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView) {
      return this._renderingCanvas.ownerDocument.defaultView;
    }
    return window;
  }
  /**
   * Gets the current render width
   * @param useScreen defines if screen size must be used (or the current render target if any)
   * @returns a number defining the current render width
   */
  getRenderWidth(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;
  }
  /**
   * Gets the current render height
   * @param useScreen defines if screen size must be used (or the current render target if any)
   * @returns a number defining the current render height
   */
  getRenderHeight(useScreen = false) {
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;
  }
  /**
   * Can be used to override the current requestAnimationFrame requester.
   * @internal
   */
  _queueNewFrame(bindedRenderFunction, requester) {
    return _ThinEngine.QueueNewFrame(bindedRenderFunction, requester);
  }
  /**
   * Register and execute a render loop. The engine can have more than one render function
   * @param renderFunction defines the function to continuously execute
   */
  runRenderLoop(renderFunction) {
    if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {
      return;
    }
    this._activeRenderLoops.push(renderFunction);
    if (!this._renderingQueueLaunched) {
      this._renderingQueueLaunched = true;
      this._boundRenderFunction = () => this._renderLoop();
      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
    }
  }
  /**
   * Clear the current render buffer or the current render target (if any is set up)
   * @param color defines the color to use
   * @param backBuffer defines if the back buffer must be cleared
   * @param depth defines if the depth buffer must be cleared
   * @param stencil defines if the stencil buffer must be cleared
   */
  clear(color, backBuffer, depth, stencil = false) {
    var _a, _b;
    const useStencilGlobalOnly = this.stencilStateComposer.useStencilGlobalOnly;
    this.stencilStateComposer.useStencilGlobalOnly = true;
    this.applyStates();
    this.stencilStateComposer.useStencilGlobalOnly = useStencilGlobalOnly;
    let mode = 0;
    if (backBuffer && color) {
      let setBackBufferColor = true;
      if (this._currentRenderTarget) {
        const textureFormat = (_a = this._currentRenderTarget.texture) == null ? void 0 : _a.format;
        if (textureFormat === 8 || textureFormat === 9 || textureFormat === 10 || textureFormat === 11) {
          const textureType = (_b = this._currentRenderTarget.texture) == null ? void 0 : _b.type;
          if (textureType === 7 || textureType === 5) {
            _ThinEngine._TempClearColorUint32[0] = color.r * 255;
            _ThinEngine._TempClearColorUint32[1] = color.g * 255;
            _ThinEngine._TempClearColorUint32[2] = color.b * 255;
            _ThinEngine._TempClearColorUint32[3] = color.a * 255;
            this._gl.clearBufferuiv(this._gl.COLOR, 0, _ThinEngine._TempClearColorUint32);
            setBackBufferColor = false;
          } else {
            _ThinEngine._TempClearColorInt32[0] = color.r * 255;
            _ThinEngine._TempClearColorInt32[1] = color.g * 255;
            _ThinEngine._TempClearColorInt32[2] = color.b * 255;
            _ThinEngine._TempClearColorInt32[3] = color.a * 255;
            this._gl.clearBufferiv(this._gl.COLOR, 0, _ThinEngine._TempClearColorInt32);
            setBackBufferColor = false;
          }
        }
      }
      if (setBackBufferColor) {
        this._gl.clearColor(color.r, color.g, color.b, color.a !== void 0 ? color.a : 1);
        mode |= this._gl.COLOR_BUFFER_BIT;
      }
    }
    if (depth) {
      if (this.useReverseDepthBuffer) {
        this._depthCullingState.depthFunc = this._gl.GEQUAL;
        this._gl.clearDepth(0);
      } else {
        this._gl.clearDepth(1);
      }
      mode |= this._gl.DEPTH_BUFFER_BIT;
    }
    if (stencil) {
      this._gl.clearStencil(0);
      mode |= this._gl.STENCIL_BUFFER_BIT;
    }
    this._gl.clear(mode);
  }
  /**
   * @internal
   */
  _viewport(x, y, width, height) {
    if (x !== this._viewportCached.x || y !== this._viewportCached.y || width !== this._viewportCached.z || height !== this._viewportCached.w) {
      this._viewportCached.x = x;
      this._viewportCached.y = y;
      this._viewportCached.z = width;
      this._viewportCached.w = height;
      this._gl.viewport(x, y, width, height);
    }
  }
  /**
   * Set the WebGL's viewport
   * @param viewport defines the viewport element to be used
   * @param requiredWidth defines the width required for rendering. If not provided the rendering canvas' width is used
   * @param requiredHeight defines the height required for rendering. If not provided the rendering canvas' height is used
   */
  setViewport(viewport, requiredWidth, requiredHeight) {
    const width = requiredWidth || this.getRenderWidth();
    const height = requiredHeight || this.getRenderHeight();
    const x = viewport.x || 0;
    const y = viewport.y || 0;
    this._cachedViewport = viewport;
    this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);
  }
  /**
   * Begin a new frame
   */
  beginFrame() {
  }
  /**
   * Enf the current frame
   */
  endFrame() {
    if (this._badOS) {
      this.flushFramebuffer();
    }
    this._frameId++;
  }
  /**
   * Resize the view according to the canvas' size
   * @param forceSetSize true to force setting the sizes of the underlying canvas
   */
  resize(forceSetSize = false) {
    let width;
    let height;
    if (this.adaptToDeviceRatio) {
      const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
      const changeRatio = this._lastDevicePixelRatio / devicePixelRatio;
      this._lastDevicePixelRatio = devicePixelRatio;
      this._hardwareScalingLevel *= changeRatio;
    }
    if (IsWindowObjectExist() && IsDocumentAvailable()) {
      if (this._renderingCanvas) {
        const boundingRect = this._renderingCanvas.getBoundingClientRect ? this._renderingCanvas.getBoundingClientRect() : {
          // fallback to last solution in case the function doesn't exist
          width: this._renderingCanvas.width * this._hardwareScalingLevel,
          height: this._renderingCanvas.height * this._hardwareScalingLevel
        };
        width = this._renderingCanvas.clientWidth || boundingRect.width || this._renderingCanvas.width || 100;
        height = this._renderingCanvas.clientHeight || boundingRect.height || this._renderingCanvas.height || 100;
      } else {
        width = window.innerWidth;
        height = window.innerHeight;
      }
    } else {
      width = this._renderingCanvas ? this._renderingCanvas.width : 100;
      height = this._renderingCanvas ? this._renderingCanvas.height : 100;
    }
    this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel, forceSetSize);
  }
  /**
   * Force a specific size of the canvas
   * @param width defines the new canvas' width
   * @param height defines the new canvas' height
   * @param forceSetSize true to force setting the sizes of the underlying canvas
   * @returns true if the size was changed
   */
  setSize(width, height, forceSetSize = false) {
    if (!this._renderingCanvas) {
      return false;
    }
    width = width | 0;
    height = height | 0;
    if (!forceSetSize && this._renderingCanvas.width === width && this._renderingCanvas.height === height) {
      return false;
    }
    this._renderingCanvas.width = width;
    this._renderingCanvas.height = height;
    return true;
  }
  /**
   * Binds the frame buffer to the specified texture.
   * @param rtWrapper The render target wrapper to render to
   * @param faceIndex The face of the texture to render to in case of cube texture and if the render target wrapper is not a multi render target
   * @param requiredWidth The width of the target to render to
   * @param requiredHeight The height of the target to render to
   * @param forceFullscreenViewport Forces the viewport to be the entire texture/screen if true
   * @param lodLevel Defines the lod level to bind to the frame buffer
   * @param layer Defines the 2d array index to bind to the frame buffer if the render target wrapper is not a multi render target
   */
  bindFramebuffer(rtWrapper, faceIndex = 0, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel = 0, layer = 0) {
    var _a, _b, _c, _d, _e, _f;
    const webglRTWrapper = rtWrapper;
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    }
    this._currentRenderTarget = rtWrapper;
    this._bindUnboundFramebuffer(webglRTWrapper._MSAAFramebuffer ? webglRTWrapper._MSAAFramebuffer : webglRTWrapper._framebuffer);
    const gl = this._gl;
    if (!rtWrapper.isMulti) {
      if (rtWrapper.is2DArray) {
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, (_a = rtWrapper.texture._hardwareTexture) == null ? void 0 : _a.underlyingResource, lodLevel, layer);
      } else if (rtWrapper.isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_b = rtWrapper.texture._hardwareTexture) == null ? void 0 : _b.underlyingResource, lodLevel);
      } else if (webglRTWrapper._currentLOD !== lodLevel) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, (_c = rtWrapper.texture._hardwareTexture) == null ? void 0 : _c.underlyingResource, lodLevel);
        webglRTWrapper._currentLOD = lodLevel;
      }
    }
    const depthStencilTexture = rtWrapper._depthStencilTexture;
    if (depthStencilTexture) {
      const attachment = rtWrapper._depthStencilTextureWithStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
      if (rtWrapper.is2DArray) {
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, (_d = depthStencilTexture._hardwareTexture) == null ? void 0 : _d.underlyingResource, lodLevel, layer);
      } else if (rtWrapper.isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_e = depthStencilTexture._hardwareTexture) == null ? void 0 : _e.underlyingResource, lodLevel);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, (_f = depthStencilTexture._hardwareTexture) == null ? void 0 : _f.underlyingResource, lodLevel);
      }
    }
    if (this._cachedViewport && !forceFullscreenViewport) {
      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
    } else {
      if (!requiredWidth) {
        requiredWidth = rtWrapper.width;
        if (lodLevel) {
          requiredWidth = requiredWidth / Math.pow(2, lodLevel);
        }
      }
      if (!requiredHeight) {
        requiredHeight = rtWrapper.height;
        if (lodLevel) {
          requiredHeight = requiredHeight / Math.pow(2, lodLevel);
        }
      }
      this._viewport(0, 0, requiredWidth, requiredHeight);
    }
    this.wipeCaches();
  }
  /**
   * Set various states to the webGL context
   * @param culling defines culling state: true to enable culling, false to disable it
   * @param zOffset defines the value to apply to zOffset (0 by default)
   * @param force defines if states must be applied even if cache is up to date
   * @param reverseSide defines if culling must be reversed (CCW if false, CW if true)
   * @param cullBackFaces true to cull back faces, false to cull front faces (if culling is enabled)
   * @param stencil stencil states to set
   * @param zOffsetUnits defines the value to apply to zOffsetUnits (0 by default)
   */
  setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {
    if (this._depthCullingState.cull !== culling || force) {
      this._depthCullingState.cull = culling;
    }
    const cullFace = this.cullBackFaces ?? cullBackFaces ?? true ? this._gl.BACK : this._gl.FRONT;
    if (this._depthCullingState.cullFace !== cullFace || force) {
      this._depthCullingState.cullFace = cullFace;
    }
    this.setZOffset(zOffset);
    this.setZOffsetUnits(zOffsetUnits);
    const frontFace = reverseSide ? this._gl.CW : this._gl.CCW;
    if (this._depthCullingState.frontFace !== frontFace || force) {
      this._depthCullingState.frontFace = frontFace;
    }
    this._stencilStateComposer.stencilMaterial = stencil;
  }
  /**
   * Gets a boolean indicating if depth testing is enabled
   * @returns the current state
   */
  getDepthBuffer() {
    return this._depthCullingState.depthTest;
  }
  /**
   * Enable or disable depth buffering
   * @param enable defines the state to set
   */
  setDepthBuffer(enable) {
    this._depthCullingState.depthTest = enable;
  }
  /**
   * Set the z offset Factor to apply to current rendering
   * @param value defines the offset to apply
   */
  setZOffset(value) {
    this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -value : value;
  }
  /**
   * Gets the current value of the zOffset Factor
   * @returns the current zOffset Factor state
   */
  getZOffset() {
    const zOffset = this._depthCullingState.zOffset;
    return this.useReverseDepthBuffer ? -zOffset : zOffset;
  }
  /**
   * Set the z offset Units to apply to current rendering
   * @param value defines the offset to apply
   */
  setZOffsetUnits(value) {
    this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -value : value;
  }
  /**
   * Gets the current value of the zOffset Units
   * @returns the current zOffset Units state
   */
  getZOffsetUnits() {
    const zOffsetUnits = this._depthCullingState.zOffsetUnits;
    return this.useReverseDepthBuffer ? -zOffsetUnits : zOffsetUnits;
  }
  /**
   * @internal
   */
  _bindUnboundFramebuffer(framebuffer) {
    if (this._currentFramebuffer !== framebuffer) {
      this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
      this._currentFramebuffer = framebuffer;
    }
  }
  /** @internal */
  _currentFrameBufferIsDefaultFrameBuffer() {
    return this._currentFramebuffer === null;
  }
  /**
   * Generates the mipmaps for a texture
   * @param texture texture to generate the mipmaps for
   */
  generateMipmaps(texture) {
    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  }
  /**
   * Unbind the current render target texture from the webGL context
   * @param texture defines the render target wrapper to unbind
   * @param disableGenerateMipMaps defines a boolean indicating that mipmaps must not be generated
   * @param onBeforeUnbind defines a function which will be called before the effective unbind
   */
  unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {
    var _a;
    const webglRTWrapper = texture;
    this._currentRenderTarget = null;
    const gl = this._gl;
    if (webglRTWrapper._MSAAFramebuffer) {
      if (texture.isMulti) {
        this.unBindMultiColorAttachmentFramebuffer(texture, disableGenerateMipMaps, onBeforeUnbind);
        return;
      }
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, webglRTWrapper._MSAAFramebuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, webglRTWrapper._framebuffer);
      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
    }
    if (((_a = texture.texture) == null ? void 0 : _a.generateMipMaps) && !disableGenerateMipMaps && !texture.isCube) {
      this.generateMipmaps(texture.texture);
    }
    if (onBeforeUnbind) {
      if (webglRTWrapper._MSAAFramebuffer) {
        this._bindUnboundFramebuffer(webglRTWrapper._framebuffer);
      }
      onBeforeUnbind();
    }
    this._bindUnboundFramebuffer(null);
  }
  /**
   * Force a webGL flush (ie. a flush of all waiting webGL commands)
   */
  flushFramebuffer() {
    this._gl.flush();
  }
  /**
   * Unbind the current render target and bind the default framebuffer
   */
  restoreDefaultFramebuffer() {
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    } else {
      this._bindUnboundFramebuffer(null);
    }
    if (this._cachedViewport) {
      this.setViewport(this._cachedViewport);
    }
    this.wipeCaches();
  }
  // VBOs
  /** @internal */
  _resetVertexBufferBinding() {
    this.bindArrayBuffer(null);
    this._cachedVertexBuffers = null;
  }
  /**
   * Creates a vertex buffer
   * @param data the data or size for the vertex buffer
   * @param _updatable whether the buffer should be created as updatable
   * @param _label defines the label of the buffer (for debug purpose)
   * @returns the new WebGL static buffer
   */
  createVertexBuffer(data, _updatable, _label) {
    return this._createVertexBuffer(data, this._gl.STATIC_DRAW);
  }
  _createVertexBuffer(data, usage) {
    const vbo = this._gl.createBuffer();
    if (!vbo) {
      throw new Error("Unable to create vertex buffer");
    }
    const dataBuffer = new WebGLDataBuffer(vbo);
    this.bindArrayBuffer(dataBuffer);
    if (typeof data !== "number") {
      if (data instanceof Array) {
        this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(data), usage);
        dataBuffer.capacity = data.length * 4;
      } else {
        this._gl.bufferData(this._gl.ARRAY_BUFFER, data, usage);
        dataBuffer.capacity = data.byteLength;
      }
    } else {
      this._gl.bufferData(this._gl.ARRAY_BUFFER, new Uint8Array(data), usage);
      dataBuffer.capacity = data;
    }
    this._resetVertexBufferBinding();
    dataBuffer.references = 1;
    return dataBuffer;
  }
  /**
   * Creates a dynamic vertex buffer
   * @param data the data for the dynamic vertex buffer
   * @param _label defines the label of the buffer (for debug purpose)
   * @returns the new WebGL dynamic buffer
   */
  createDynamicVertexBuffer(data, _label) {
    return this._createVertexBuffer(data, this._gl.DYNAMIC_DRAW);
  }
  _resetIndexBufferBinding() {
    this.bindIndexBuffer(null);
    this._cachedIndexBuffer = null;
  }
  /**
   * Creates a new index buffer
   * @param indices defines the content of the index buffer
   * @param updatable defines if the index buffer must be updatable
   * @param _label defines the label of the buffer (for debug purpose)
   * @returns a new webGL buffer
   */
  createIndexBuffer(indices, updatable, _label) {
    const vbo = this._gl.createBuffer();
    const dataBuffer = new WebGLDataBuffer(vbo);
    if (!vbo) {
      throw new Error("Unable to create index buffer");
    }
    this.bindIndexBuffer(dataBuffer);
    const data = this._normalizeIndexData(indices);
    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, updatable ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW);
    this._resetIndexBufferBinding();
    dataBuffer.references = 1;
    dataBuffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
    return dataBuffer;
  }
  _normalizeIndexData(indices) {
    const bytesPerElement = indices.BYTES_PER_ELEMENT;
    if (bytesPerElement === 2) {
      return indices;
    }
    if (this._caps.uintIndices) {
      if (indices instanceof Uint32Array) {
        return indices;
      } else {
        for (let index = 0; index < indices.length; index++) {
          if (indices[index] >= 65535) {
            return new Uint32Array(indices);
          }
        }
        return new Uint16Array(indices);
      }
    }
    return new Uint16Array(indices);
  }
  /**
   * Bind a webGL buffer to the webGL context
   * @param buffer defines the buffer to bind
   */
  bindArrayBuffer(buffer) {
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this._bindBuffer(buffer, this._gl.ARRAY_BUFFER);
  }
  /**
   * Bind a specific block at a given index in a specific shader program
   * @param pipelineContext defines the pipeline context to use
   * @param blockName defines the block name
   * @param index defines the index where to bind the block
   */
  bindUniformBlock(pipelineContext, blockName, index) {
    const program = pipelineContext.program;
    const uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
    this._gl.uniformBlockBinding(program, uniformLocation, index);
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  bindIndexBuffer(buffer) {
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this._bindBuffer(buffer, this._gl.ELEMENT_ARRAY_BUFFER);
  }
  _bindBuffer(buffer, target) {
    if (this._vaoRecordInProgress || this._currentBoundBuffer[target] !== buffer) {
      this._gl.bindBuffer(target, buffer ? buffer.underlyingResource : null);
      this._currentBoundBuffer[target] = buffer;
    }
  }
  /**
   * update the bound buffer with the given data
   * @param data defines the data to update
   */
  updateArrayBuffer(data) {
    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
  }
  _vertexAttribPointer(buffer, indx, size, type, normalized, stride, offset) {
    const pointer = this._currentBufferPointers[indx];
    if (!pointer) {
      return;
    }
    let changed = false;
    if (!pointer.active) {
      changed = true;
      pointer.active = true;
      pointer.index = indx;
      pointer.size = size;
      pointer.type = type;
      pointer.normalized = normalized;
      pointer.stride = stride;
      pointer.offset = offset;
      pointer.buffer = buffer;
    } else {
      if (pointer.buffer !== buffer) {
        pointer.buffer = buffer;
        changed = true;
      }
      if (pointer.size !== size) {
        pointer.size = size;
        changed = true;
      }
      if (pointer.type !== type) {
        pointer.type = type;
        changed = true;
      }
      if (pointer.normalized !== normalized) {
        pointer.normalized = normalized;
        changed = true;
      }
      if (pointer.stride !== stride) {
        pointer.stride = stride;
        changed = true;
      }
      if (pointer.offset !== offset) {
        pointer.offset = offset;
        changed = true;
      }
    }
    if (changed || this._vaoRecordInProgress) {
      this.bindArrayBuffer(buffer);
      if (type === this._gl.UNSIGNED_INT || type === this._gl.INT) {
        this._gl.vertexAttribIPointer(indx, size, type, stride, offset);
      } else {
        this._gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);
      }
    }
  }
  /**
   * @internal
   */
  _bindIndexBufferWithCache(indexBuffer) {
    if (indexBuffer == null) {
      return;
    }
    if (this._cachedIndexBuffer !== indexBuffer) {
      this._cachedIndexBuffer = indexBuffer;
      this.bindIndexBuffer(indexBuffer);
      this._uintIndicesCurrentlySet = indexBuffer.is32Bits;
    }
  }
  _bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers) {
    const attributes = effect.getAttributesNames();
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this.unbindAllAttributes();
    for (let index = 0; index < attributes.length; index++) {
      const order = effect.getAttributeLocation(index);
      if (order >= 0) {
        const ai = attributes[index];
        let vertexBuffer = null;
        if (overrideVertexBuffers) {
          vertexBuffer = overrideVertexBuffers[ai];
        }
        if (!vertexBuffer) {
          vertexBuffer = vertexBuffers[ai];
        }
        if (!vertexBuffer) {
          continue;
        }
        this._gl.enableVertexAttribArray(order);
        if (!this._vaoRecordInProgress) {
          this._vertexAttribArraysEnabled[order] = true;
        }
        const buffer = vertexBuffer.getBuffer();
        if (buffer) {
          this._vertexAttribPointer(buffer, order, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.normalized, vertexBuffer.byteStride, vertexBuffer.byteOffset);
          if (vertexBuffer.getIsInstanced()) {
            this._gl.vertexAttribDivisor(order, vertexBuffer.getInstanceDivisor());
            if (!this._vaoRecordInProgress) {
              this._currentInstanceLocations.push(order);
              this._currentInstanceBuffers.push(buffer);
            }
          }
        }
      }
    }
  }
  /**
   * Records a vertex array object
   * @see https://doc.babylonjs.com/setup/support/webGL2#vertex-array-objects
   * @param vertexBuffers defines the list of vertex buffers to store
   * @param indexBuffer defines the index buffer to store
   * @param effect defines the effect to store
   * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers
   * @returns the new vertex array object
   */
  recordVertexArrayObject(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    const vao = this._gl.createVertexArray();
    if (!vao) {
      throw new Error("Unable to create VAO");
    }
    this._vaoRecordInProgress = true;
    this._gl.bindVertexArray(vao);
    this._mustWipeVertexAttributes = true;
    this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
    this.bindIndexBuffer(indexBuffer);
    this._vaoRecordInProgress = false;
    this._gl.bindVertexArray(null);
    return vao;
  }
  /**
   * Bind a specific vertex array object
   * @see https://doc.babylonjs.com/setup/support/webGL2#vertex-array-objects
   * @param vertexArrayObject defines the vertex array object to bind
   * @param indexBuffer defines the index buffer to bind
   */
  bindVertexArrayObject(vertexArrayObject, indexBuffer) {
    if (this._cachedVertexArrayObject !== vertexArrayObject) {
      this._cachedVertexArrayObject = vertexArrayObject;
      this._gl.bindVertexArray(vertexArrayObject);
      this._cachedVertexBuffers = null;
      this._cachedIndexBuffer = null;
      this._uintIndicesCurrentlySet = indexBuffer != null && indexBuffer.is32Bits;
      this._mustWipeVertexAttributes = true;
    }
  }
  /**
   * Bind webGl buffers directly to the webGL context
   * @param vertexBuffer defines the vertex buffer to bind
   * @param indexBuffer defines the index buffer to bind
   * @param vertexDeclaration defines the vertex declaration to use with the vertex buffer
   * @param vertexStrideSize defines the vertex stride of the vertex buffer
   * @param effect defines the effect associated with the vertex buffer
   */
  bindBuffersDirectly(vertexBuffer, indexBuffer, vertexDeclaration, vertexStrideSize, effect) {
    if (this._cachedVertexBuffers !== vertexBuffer || this._cachedEffectForVertexBuffers !== effect) {
      this._cachedVertexBuffers = vertexBuffer;
      this._cachedEffectForVertexBuffers = effect;
      const attributesCount = effect.getAttributesCount();
      this._unbindVertexArrayObject();
      this.unbindAllAttributes();
      let offset = 0;
      for (let index = 0; index < attributesCount; index++) {
        if (index < vertexDeclaration.length) {
          const order = effect.getAttributeLocation(index);
          if (order >= 0) {
            this._gl.enableVertexAttribArray(order);
            this._vertexAttribArraysEnabled[order] = true;
            this._vertexAttribPointer(vertexBuffer, order, vertexDeclaration[index], this._gl.FLOAT, false, vertexStrideSize, offset);
          }
          offset += vertexDeclaration[index] * 4;
        }
      }
    }
    this._bindIndexBufferWithCache(indexBuffer);
  }
  _unbindVertexArrayObject() {
    if (!this._cachedVertexArrayObject) {
      return;
    }
    this._cachedVertexArrayObject = null;
    this._gl.bindVertexArray(null);
  }
  /**
   * Bind a list of vertex buffers to the webGL context
   * @param vertexBuffers defines the list of vertex buffers to bind
   * @param indexBuffer defines the index buffer to bind
   * @param effect defines the effect associated with the vertex buffers
   * @param overrideVertexBuffers defines optional list of avertex buffers that overrides the entries in vertexBuffers
   */
  bindBuffers(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    if (this._cachedVertexBuffers !== vertexBuffers || this._cachedEffectForVertexBuffers !== effect) {
      this._cachedVertexBuffers = vertexBuffers;
      this._cachedEffectForVertexBuffers = effect;
      this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
    }
    this._bindIndexBufferWithCache(indexBuffer);
  }
  /**
   * Unbind all instance attributes
   */
  unbindInstanceAttributes() {
    let boundBuffer;
    for (let i = 0, ul = this._currentInstanceLocations.length; i < ul; i++) {
      const instancesBuffer = this._currentInstanceBuffers[i];
      if (boundBuffer != instancesBuffer && instancesBuffer.references) {
        boundBuffer = instancesBuffer;
        this.bindArrayBuffer(instancesBuffer);
      }
      const offsetLocation = this._currentInstanceLocations[i];
      this._gl.vertexAttribDivisor(offsetLocation, 0);
    }
    this._currentInstanceBuffers.length = 0;
    this._currentInstanceLocations.length = 0;
  }
  /**
   * Release and free the memory of a vertex array object
   * @param vao defines the vertex array object to delete
   */
  releaseVertexArrayObject(vao) {
    this._gl.deleteVertexArray(vao);
  }
  /**
   * @internal
   */
  _releaseBuffer(buffer) {
    buffer.references--;
    if (buffer.references === 0) {
      this._deleteBuffer(buffer);
      return true;
    }
    return false;
  }
  _deleteBuffer(buffer) {
    this._gl.deleteBuffer(buffer.underlyingResource);
  }
  /**
   * Update the content of a webGL buffer used with instantiation and bind it to the webGL context
   * @param instancesBuffer defines the webGL buffer to update and bind
   * @param data defines the data to store in the buffer
   * @param offsetLocations defines the offsets or attributes information used to determine where data must be stored in the buffer
   */
  updateAndBindInstancesBuffer(instancesBuffer, data, offsetLocations) {
    this.bindArrayBuffer(instancesBuffer);
    if (data) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
    }
    if (offsetLocations[0].index !== void 0) {
      this.bindInstancesBuffer(instancesBuffer, offsetLocations, true);
    } else {
      for (let index = 0; index < 4; index++) {
        const offsetLocation = offsetLocations[index];
        if (!this._vertexAttribArraysEnabled[offsetLocation]) {
          this._gl.enableVertexAttribArray(offsetLocation);
          this._vertexAttribArraysEnabled[offsetLocation] = true;
        }
        this._vertexAttribPointer(instancesBuffer, offsetLocation, 4, this._gl.FLOAT, false, 64, index * 16);
        this._gl.vertexAttribDivisor(offsetLocation, 1);
        this._currentInstanceLocations.push(offsetLocation);
        this._currentInstanceBuffers.push(instancesBuffer);
      }
    }
  }
  /**
   * Bind the content of a webGL buffer used with instantiation
   * @param instancesBuffer defines the webGL buffer to bind
   * @param attributesInfo defines the offsets or attributes information used to determine where data must be stored in the buffer
   * @param computeStride defines Whether to compute the strides from the info or use the default 0
   */
  bindInstancesBuffer(instancesBuffer, attributesInfo, computeStride = true) {
    this.bindArrayBuffer(instancesBuffer);
    let stride = 0;
    if (computeStride) {
      for (let i = 0; i < attributesInfo.length; i++) {
        const ai = attributesInfo[i];
        stride += ai.attributeSize * 4;
      }
    }
    for (let i = 0; i < attributesInfo.length; i++) {
      const ai = attributesInfo[i];
      if (ai.index === void 0) {
        ai.index = this._currentEffect.getAttributeLocationByName(ai.attributeName);
      }
      if (ai.index < 0) {
        continue;
      }
      if (!this._vertexAttribArraysEnabled[ai.index]) {
        this._gl.enableVertexAttribArray(ai.index);
        this._vertexAttribArraysEnabled[ai.index] = true;
      }
      this._vertexAttribPointer(instancesBuffer, ai.index, ai.attributeSize, ai.attributeType || this._gl.FLOAT, ai.normalized || false, stride, ai.offset);
      this._gl.vertexAttribDivisor(ai.index, ai.divisor === void 0 ? 1 : ai.divisor);
      this._currentInstanceLocations.push(ai.index);
      this._currentInstanceBuffers.push(instancesBuffer);
    }
  }
  /**
   * Disable the instance attribute corresponding to the name in parameter
   * @param name defines the name of the attribute to disable
   */
  disableInstanceAttributeByName(name) {
    if (!this._currentEffect) {
      return;
    }
    const attributeLocation = this._currentEffect.getAttributeLocationByName(name);
    this.disableInstanceAttribute(attributeLocation);
  }
  /**
   * Disable the instance attribute corresponding to the location in parameter
   * @param attributeLocation defines the attribute location of the attribute to disable
   */
  disableInstanceAttribute(attributeLocation) {
    let shouldClean = false;
    let index;
    while ((index = this._currentInstanceLocations.indexOf(attributeLocation)) !== -1) {
      this._currentInstanceLocations.splice(index, 1);
      this._currentInstanceBuffers.splice(index, 1);
      shouldClean = true;
      index = this._currentInstanceLocations.indexOf(attributeLocation);
    }
    if (shouldClean) {
      this._gl.vertexAttribDivisor(attributeLocation, 0);
      this.disableAttributeByIndex(attributeLocation);
    }
  }
  /**
   * Disable the attribute corresponding to the location in parameter
   * @param attributeLocation defines the attribute location of the attribute to disable
   */
  disableAttributeByIndex(attributeLocation) {
    this._gl.disableVertexAttribArray(attributeLocation);
    this._vertexAttribArraysEnabled[attributeLocation] = false;
    this._currentBufferPointers[attributeLocation].active = false;
  }
  /**
   * Send a draw order
   * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
   * @param indexStart defines the starting index
   * @param indexCount defines the number of index to draw
   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
   */
  draw(useTriangles, indexStart, indexCount, instancesCount) {
    this.drawElementsType(useTriangles ? 0 : 1, indexStart, indexCount, instancesCount);
  }
  /**
   * Draw a list of points
   * @param verticesStart defines the index of first vertex to draw
   * @param verticesCount defines the count of vertices to draw
   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
   */
  drawPointClouds(verticesStart, verticesCount, instancesCount) {
    this.drawArraysType(2, verticesStart, verticesCount, instancesCount);
  }
  /**
   * Draw a list of unindexed primitives
   * @param useTriangles defines if triangles must be used to draw (else wireframe will be used)
   * @param verticesStart defines the index of first vertex to draw
   * @param verticesCount defines the count of vertices to draw
   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
   */
  drawUnIndexed(useTriangles, verticesStart, verticesCount, instancesCount) {
    this.drawArraysType(useTriangles ? 0 : 1, verticesStart, verticesCount, instancesCount);
  }
  /**
   * Draw a list of indexed primitives
   * @param fillMode defines the primitive to use
   * @param indexStart defines the starting index
   * @param indexCount defines the number of index to draw
   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
   */
  drawElementsType(fillMode, indexStart, indexCount, instancesCount) {
    this.applyStates();
    this._reportDrawCall();
    const drawMode = this._drawMode(fillMode);
    const indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;
    const mult = this._uintIndicesCurrentlySet ? 4 : 2;
    if (instancesCount) {
      this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);
    } else {
      this._gl.drawElements(drawMode, indexCount, indexFormat, indexStart * mult);
    }
  }
  /**
   * Draw a list of unindexed primitives
   * @param fillMode defines the primitive to use
   * @param verticesStart defines the index of first vertex to draw
   * @param verticesCount defines the count of vertices to draw
   * @param instancesCount defines the number of instances to draw (if instantiation is enabled)
   */
  drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {
    this.applyStates();
    this._reportDrawCall();
    const drawMode = this._drawMode(fillMode);
    if (instancesCount) {
      this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);
    } else {
      this._gl.drawArrays(drawMode, verticesStart, verticesCount);
    }
  }
  _drawMode(fillMode) {
    switch (fillMode) {
      case 0:
        return this._gl.TRIANGLES;
      case 2:
        return this._gl.POINTS;
      case 1:
        return this._gl.LINES;
      case 3:
        return this._gl.POINTS;
      case 4:
        return this._gl.LINES;
      case 5:
        return this._gl.LINE_LOOP;
      case 6:
        return this._gl.LINE_STRIP;
      case 7:
        return this._gl.TRIANGLE_STRIP;
      case 8:
        return this._gl.TRIANGLE_FAN;
      default:
        return this._gl.TRIANGLES;
    }
  }
  /** @internal */
  _reportDrawCall() {
  }
  // Shaders
  /**
   * @internal
   */
  _releaseEffect(effect) {
    if (this._compiledEffects[effect._key]) {
      delete this._compiledEffects[effect._key];
    }
    const pipelineContext = effect.getPipelineContext();
    if (pipelineContext) {
      this._deletePipelineContext(pipelineContext);
    }
  }
  /**
   * @internal
   */
  _deletePipelineContext(pipelineContext) {
    const webGLPipelineContext = pipelineContext;
    if (webGLPipelineContext && webGLPipelineContext.program) {
      webGLPipelineContext.program.__SPECTOR_rebuildProgram = null;
      this._gl.deleteProgram(webGLPipelineContext.program);
    }
  }
  /** @internal */
  _getGlobalDefines(defines) {
    if (defines) {
      if (this.isNDCHalfZRange) {
        defines["IS_NDC_HALF_ZRANGE"] = "";
      } else {
        delete defines["IS_NDC_HALF_ZRANGE"];
      }
      if (this.useReverseDepthBuffer) {
        defines["USE_REVERSE_DEPTHBUFFER"] = "";
      } else {
        delete defines["USE_REVERSE_DEPTHBUFFER"];
      }
      if (this.useExactSrgbConversions) {
        defines["USE_EXACT_SRGB_CONVERSIONS"] = "";
      } else {
        delete defines["USE_EXACT_SRGB_CONVERSIONS"];
      }
      return;
    } else {
      let s = "";
      if (this.isNDCHalfZRange) {
        s += "#define IS_NDC_HALF_ZRANGE";
      }
      if (this.useReverseDepthBuffer) {
        if (s) {
          s += "\n";
        }
        s += "#define USE_REVERSE_DEPTHBUFFER";
      }
      if (this.useExactSrgbConversions) {
        if (s) {
          s += "\n";
        }
        s += "#define USE_EXACT_SRGB_CONVERSIONS";
      }
      return s;
    }
  }
  /**
   * Create a new effect (used to store vertex/fragment shaders)
   * @param baseName defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)
   * @param attributesNamesOrOptions defines either a list of attribute names or an IEffectCreationOptions object
   * @param uniformsNamesOrEngine defines either a list of uniform names or the engine to use
   * @param samplers defines an array of string used to represent textures
   * @param defines defines the string containing the defines to use to compile the shaders
   * @param fallbacks defines the list of potential fallbacks to use if shader compilation fails
   * @param onCompiled defines a function to call when the effect creation is successful
   * @param onError defines a function to call when the effect creation has failed
   * @param indexParameters defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)
   * @param shaderLanguage the language the shader is written in (default: GLSL)
   * @returns the new Effect
   */
  createEffect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage = ShaderLanguage.GLSL) {
    const vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;
    const fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;
    const globalDefines = this._getGlobalDefines();
    let fullDefines = defines ?? attributesNamesOrOptions.defines ?? "";
    if (globalDefines) {
      fullDefines += globalDefines;
    }
    const name = vertex + "+" + fragment + "@" + fullDefines;
    if (this._compiledEffects[name]) {
      const compiledEffect = this._compiledEffects[name];
      if (onCompiled && compiledEffect.isReady()) {
        onCompiled(compiledEffect);
      }
      return compiledEffect;
    }
    const effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name, shaderLanguage);
    this._compiledEffects[name] = effect;
    return effect;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static _ConcatenateShader(source, defines, shaderVersion = "") {
    return shaderVersion + (defines ? defines + "\n" : "") + source;
  }
  _compileShader(source, type, defines, shaderVersion) {
    return this._compileRawShader(_ThinEngine._ConcatenateShader(source, defines, shaderVersion), type);
  }
  _compileRawShader(source, type) {
    const gl = this._gl;
    const shader = gl.createShader(type === "vertex" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
    if (!shader) {
      let error = gl.NO_ERROR;
      let tempError = gl.NO_ERROR;
      while ((tempError = gl.getError()) !== gl.NO_ERROR) {
        error = tempError;
      }
      throw new Error(`Something went wrong while creating a gl ${type} shader object. gl error=${error}, gl isContextLost=${gl.isContextLost()}, _contextWasLost=${this._contextWasLost}`);
    }
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    return shader;
  }
  /**
   * @internal
   */
  _getShaderSource(shader) {
    return this._gl.getShaderSource(shader);
  }
  /**
   * Directly creates a webGL program
   * @param pipelineContext  defines the pipeline context to attach to
   * @param vertexCode defines the vertex shader code to use
   * @param fragmentCode defines the fragment shader code to use
   * @param context defines the webGL context to use (if not set, the current one will be used)
   * @param transformFeedbackVaryings defines the list of transform feedback varyings to use
   * @returns the new webGL program
   */
  createRawShaderProgram(pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings = null) {
    context = context || this._gl;
    const vertexShader = this._compileRawShader(vertexCode, "vertex");
    const fragmentShader = this._compileRawShader(fragmentCode, "fragment");
    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
  }
  /**
   * Creates a webGL program
   * @param pipelineContext  defines the pipeline context to attach to
   * @param vertexCode  defines the vertex shader code to use
   * @param fragmentCode defines the fragment shader code to use
   * @param defines defines the string containing the defines to use to compile the shaders
   * @param context defines the webGL context to use (if not set, the current one will be used)
   * @param transformFeedbackVaryings defines the list of transform feedback varyings to use
   * @returns the new webGL program
   */
  createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings = null) {
    context = context || this._gl;
    const shaderVersion = this._webGLVersion > 1 ? "#version 300 es\n#define WEBGL2 \n" : "";
    const vertexShader = this._compileShader(vertexCode, "vertex", defines, shaderVersion);
    const fragmentShader = this._compileShader(fragmentCode, "fragment", defines, shaderVersion);
    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
  }
  /**
   * Inline functions in shader code that are marked to be inlined
   * @param code code to inline
   * @returns inlined code
   */
  inlineShaderCode(code) {
    return code;
  }
  /**
   * Creates a new pipeline context
   * @param shaderProcessingContext defines the shader processing context used during the processing if available
   * @returns the new pipeline
   */
  createPipelineContext(shaderProcessingContext) {
    const pipelineContext = new WebGLPipelineContext();
    pipelineContext.engine = this;
    if (this._caps.parallelShaderCompile) {
      pipelineContext.isParallelCompiled = true;
    }
    return pipelineContext;
  }
  /**
   * Creates a new material context
   * @returns the new context
   */
  createMaterialContext() {
    return void 0;
  }
  /**
   * Creates a new draw context
   * @returns the new context
   */
  createDrawContext() {
    return void 0;
  }
  _createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings = null) {
    const shaderProgram = context.createProgram();
    pipelineContext.program = shaderProgram;
    if (!shaderProgram) {
      throw new Error("Unable to create program");
    }
    context.attachShader(shaderProgram, vertexShader);
    context.attachShader(shaderProgram, fragmentShader);
    context.linkProgram(shaderProgram);
    pipelineContext.context = context;
    pipelineContext.vertexShader = vertexShader;
    pipelineContext.fragmentShader = fragmentShader;
    if (!pipelineContext.isParallelCompiled) {
      this._finalizePipelineContext(pipelineContext);
    }
    return shaderProgram;
  }
  _finalizePipelineContext(pipelineContext) {
    const context = pipelineContext.context;
    const vertexShader = pipelineContext.vertexShader;
    const fragmentShader = pipelineContext.fragmentShader;
    const program = pipelineContext.program;
    const linked = context.getProgramParameter(program, context.LINK_STATUS);
    if (!linked) {
      if (!this._gl.getShaderParameter(vertexShader, this._gl.COMPILE_STATUS)) {
        const log = this._gl.getShaderInfoLog(vertexShader);
        if (log) {
          pipelineContext.vertexCompilationError = log;
          throw new Error("VERTEX SHADER " + log);
        }
      }
      if (!this._gl.getShaderParameter(fragmentShader, this._gl.COMPILE_STATUS)) {
        const log = this._gl.getShaderInfoLog(fragmentShader);
        if (log) {
          pipelineContext.fragmentCompilationError = log;
          throw new Error("FRAGMENT SHADER " + log);
        }
      }
      const error = context.getProgramInfoLog(program);
      if (error) {
        pipelineContext.programLinkError = error;
        throw new Error(error);
      }
    }
    if (this.validateShaderPrograms) {
      context.validateProgram(program);
      const validated = context.getProgramParameter(program, context.VALIDATE_STATUS);
      if (!validated) {
        const error = context.getProgramInfoLog(program);
        if (error) {
          pipelineContext.programValidationError = error;
          throw new Error(error);
        }
      }
    }
    context.deleteShader(vertexShader);
    context.deleteShader(fragmentShader);
    pipelineContext.vertexShader = void 0;
    pipelineContext.fragmentShader = void 0;
    if (pipelineContext.onCompiled) {
      pipelineContext.onCompiled();
      pipelineContext.onCompiled = void 0;
    }
  }
  /**
   * @internal
   */
  _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines, transformFeedbackVaryings, key) {
    const webGLRenderingState = pipelineContext;
    if (createAsRaw) {
      webGLRenderingState.program = this.createRawShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, void 0, transformFeedbackVaryings);
    } else {
      webGLRenderingState.program = this.createShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, defines, void 0, transformFeedbackVaryings);
    }
    webGLRenderingState.program.__SPECTOR_rebuildProgram = rebuildRebind;
  }
  /**
   * @internal
   */
  _isRenderingStateCompiled(pipelineContext) {
    const webGLPipelineContext = pipelineContext;
    if (this._isDisposed || webGLPipelineContext._isDisposed) {
      return false;
    }
    if (this._gl.getProgramParameter(webGLPipelineContext.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR)) {
      this._finalizePipelineContext(webGLPipelineContext);
      return true;
    }
    return false;
  }
  /**
   * @internal
   */
  _executeWhenRenderingStateIsCompiled(pipelineContext, action) {
    const webGLPipelineContext = pipelineContext;
    if (!webGLPipelineContext.isParallelCompiled) {
      action();
      return;
    }
    const oldHandler = webGLPipelineContext.onCompiled;
    if (oldHandler) {
      webGLPipelineContext.onCompiled = () => {
        oldHandler();
        action();
      };
    } else {
      webGLPipelineContext.onCompiled = action;
    }
  }
  /**
   * Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names
   * @param pipelineContext defines the pipeline context to use
   * @param uniformsNames defines the list of uniform names
   * @returns an array of webGL uniform locations
   */
  getUniforms(pipelineContext, uniformsNames) {
    const results = new Array();
    const webGLPipelineContext = pipelineContext;
    for (let index = 0; index < uniformsNames.length; index++) {
      results.push(this._gl.getUniformLocation(webGLPipelineContext.program, uniformsNames[index]));
    }
    return results;
  }
  /**
   * Gets the list of active attributes for a given webGL program
   * @param pipelineContext defines the pipeline context to use
   * @param attributesNames defines the list of attribute names to get
   * @returns an array of indices indicating the offset of each attribute
   */
  getAttributes(pipelineContext, attributesNames) {
    const results = [];
    const webGLPipelineContext = pipelineContext;
    for (let index = 0; index < attributesNames.length; index++) {
      try {
        results.push(this._gl.getAttribLocation(webGLPipelineContext.program, attributesNames[index]));
      } catch (e) {
        results.push(-1);
      }
    }
    return results;
  }
  /**
   * Activates an effect, making it the current one (ie. the one used for rendering)
   * @param effect defines the effect to activate
   */
  enableEffect(effect) {
    effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect;
    if (!effect || effect === this._currentEffect) {
      return;
    }
    this._stencilStateComposer.stencilMaterial = void 0;
    effect = effect;
    this.bindSamplers(effect);
    this._currentEffect = effect;
    if (effect.onBind) {
      effect.onBind(effect);
    }
    if (effect._onBindObservable) {
      effect._onBindObservable.notifyObservers(effect);
    }
  }
  /**
   * Set the value of an uniform to a number (int)
   * @param uniform defines the webGL uniform location where to store the value
   * @param value defines the int number to store
   * @returns true if the value was set
   */
  setInt(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1i(uniform, value);
    return true;
  }
  /**
   * Set the value of an uniform to a int2
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @returns true if the value was set
   */
  setInt2(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform2i(uniform, x, y);
    return true;
  }
  /**
   * Set the value of an uniform to a int3
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @param z defines the 3rd component of the value
   * @returns true if the value was set
   */
  setInt3(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform3i(uniform, x, y, z);
    return true;
  }
  /**
   * Set the value of an uniform to a int4
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @param z defines the 3rd component of the value
   * @param w defines the 4th component of the value
   * @returns true if the value was set
   */
  setInt4(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform4i(uniform, x, y, z, w);
    return true;
  }
  /**
   * Set the value of an uniform to an array of int32
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of int32 to store
   * @returns true if the value was set
   */
  setIntArray(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1iv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to an array of int32 (stored as vec2)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of int32 to store
   * @returns true if the value was set
   */
  setIntArray2(uniform, array) {
    if (!uniform || array.length % 2 !== 0) {
      return false;
    }
    this._gl.uniform2iv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to an array of int32 (stored as vec3)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of int32 to store
   * @returns true if the value was set
   */
  setIntArray3(uniform, array) {
    if (!uniform || array.length % 3 !== 0) {
      return false;
    }
    this._gl.uniform3iv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to an array of int32 (stored as vec4)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of int32 to store
   * @returns true if the value was set
   */
  setIntArray4(uniform, array) {
    if (!uniform || array.length % 4 !== 0) {
      return false;
    }
    this._gl.uniform4iv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to a number (unsigned int)
   * @param uniform defines the webGL uniform location where to store the value
   * @param value defines the unsigned int number to store
   * @returns true if the value was set
   */
  setUInt(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1ui(uniform, value);
    return true;
  }
  /**
   * Set the value of an uniform to a unsigned int2
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @returns true if the value was set
   */
  setUInt2(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform2ui(uniform, x, y);
    return true;
  }
  /**
   * Set the value of an uniform to a unsigned int3
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @param z defines the 3rd component of the value
   * @returns true if the value was set
   */
  setUInt3(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform3ui(uniform, x, y, z);
    return true;
  }
  /**
   * Set the value of an uniform to a unsigned int4
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @param z defines the 3rd component of the value
   * @param w defines the 4th component of the value
   * @returns true if the value was set
   */
  setUInt4(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform4ui(uniform, x, y, z, w);
    return true;
  }
  /**
   * Set the value of an uniform to an array of unsigned int32
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of unsigned int32 to store
   * @returns true if the value was set
   */
  setUIntArray(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1uiv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to an array of unsigned int32 (stored as vec2)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of unsigned int32 to store
   * @returns true if the value was set
   */
  setUIntArray2(uniform, array) {
    if (!uniform || array.length % 2 !== 0) {
      return false;
    }
    this._gl.uniform2uiv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to an array of unsigned int32 (stored as vec3)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of unsigned int32 to store
   * @returns true if the value was set
   */
  setUIntArray3(uniform, array) {
    if (!uniform || array.length % 3 !== 0) {
      return false;
    }
    this._gl.uniform3uiv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to an array of unsigned int32 (stored as vec4)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of unsigned int32 to store
   * @returns true if the value was set
   */
  setUIntArray4(uniform, array) {
    if (!uniform || array.length % 4 !== 0) {
      return false;
    }
    this._gl.uniform4uiv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to an array of number
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of number to store
   * @returns true if the value was set
   */
  setArray(uniform, array) {
    if (!uniform) {
      return false;
    }
    if (array.length < 1) {
      return false;
    }
    this._gl.uniform1fv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to an array of number (stored as vec2)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of number to store
   * @returns true if the value was set
   */
  setArray2(uniform, array) {
    if (!uniform || array.length % 2 !== 0) {
      return false;
    }
    this._gl.uniform2fv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to an array of number (stored as vec3)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of number to store
   * @returns true if the value was set
   */
  setArray3(uniform, array) {
    if (!uniform || array.length % 3 !== 0) {
      return false;
    }
    this._gl.uniform3fv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to an array of number (stored as vec4)
   * @param uniform defines the webGL uniform location where to store the value
   * @param array defines the array of number to store
   * @returns true if the value was set
   */
  setArray4(uniform, array) {
    if (!uniform || array.length % 4 !== 0) {
      return false;
    }
    this._gl.uniform4fv(uniform, array);
    return true;
  }
  /**
   * Set the value of an uniform to an array of float32 (stored as matrices)
   * @param uniform defines the webGL uniform location where to store the value
   * @param matrices defines the array of float32 to store
   * @returns true if the value was set
   */
  setMatrices(uniform, matrices) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix4fv(uniform, false, matrices);
    return true;
  }
  /**
   * Set the value of an uniform to a matrix (3x3)
   * @param uniform defines the webGL uniform location where to store the value
   * @param matrix defines the Float32Array representing the 3x3 matrix to store
   * @returns true if the value was set
   */
  setMatrix3x3(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix3fv(uniform, false, matrix);
    return true;
  }
  /**
   * Set the value of an uniform to a matrix (2x2)
   * @param uniform defines the webGL uniform location where to store the value
   * @param matrix defines the Float32Array representing the 2x2 matrix to store
   * @returns true if the value was set
   */
  setMatrix2x2(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix2fv(uniform, false, matrix);
    return true;
  }
  /**
   * Set the value of an uniform to a number (float)
   * @param uniform defines the webGL uniform location where to store the value
   * @param value defines the float number to store
   * @returns true if the value was transferred
   */
  setFloat(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1f(uniform, value);
    return true;
  }
  /**
   * Set the value of an uniform to a vec2
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @returns true if the value was set
   */
  setFloat2(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform2f(uniform, x, y);
    return true;
  }
  /**
   * Set the value of an uniform to a vec3
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @param z defines the 3rd component of the value
   * @returns true if the value was set
   */
  setFloat3(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform3f(uniform, x, y, z);
    return true;
  }
  /**
   * Set the value of an uniform to a vec4
   * @param uniform defines the webGL uniform location where to store the value
   * @param x defines the 1st component of the value
   * @param y defines the 2nd component of the value
   * @param z defines the 3rd component of the value
   * @param w defines the 4th component of the value
   * @returns true if the value was set
   */
  setFloat4(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform4f(uniform, x, y, z, w);
    return true;
  }
  // States
  /**
   * Apply all cached states (depth, culling, stencil and alpha)
   */
  applyStates() {
    this._depthCullingState.apply(this._gl);
    this._stencilStateComposer.apply(this._gl);
    this._alphaState.apply(this._gl);
    if (this._colorWriteChanged) {
      this._colorWriteChanged = false;
      const enable = this._colorWrite;
      this._gl.colorMask(enable, enable, enable, enable);
    }
  }
  /**
   * Enable or disable color writing
   * @param enable defines the state to set
   */
  setColorWrite(enable) {
    if (enable !== this._colorWrite) {
      this._colorWriteChanged = true;
      this._colorWrite = enable;
    }
  }
  /**
   * Gets a boolean indicating if color writing is enabled
   * @returns the current color writing state
   */
  getColorWrite() {
    return this._colorWrite;
  }
  /**
   * Gets the depth culling state manager
   */
  get depthCullingState() {
    return this._depthCullingState;
  }
  /**
   * Gets the alpha state manager
   */
  get alphaState() {
    return this._alphaState;
  }
  /**
   * Gets the stencil state manager
   */
  get stencilState() {
    return this._stencilState;
  }
  /**
   * Gets the stencil state composer
   */
  get stencilStateComposer() {
    return this._stencilStateComposer;
  }
  // Textures
  /**
   * Clears the list of texture accessible through engine.
   * This can help preventing texture load conflict due to name collision.
   */
  clearInternalTexturesCache() {
    this._internalTexturesCache.length = 0;
  }
  /**
   * Force the entire cache to be cleared
   * You should not have to use this function unless your engine needs to share the webGL context with another engine
   * @param bruteForce defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)
   */
  wipeCaches(bruteForce) {
    if (this.preventCacheWipeBetweenFrames && !bruteForce) {
      return;
    }
    this._currentEffect = null;
    this._viewportCached.x = 0;
    this._viewportCached.y = 0;
    this._viewportCached.z = 0;
    this._viewportCached.w = 0;
    this._unbindVertexArrayObject();
    if (bruteForce) {
      this._currentProgram = null;
      this.resetTextureCache();
      this._stencilStateComposer.reset();
      this._depthCullingState.reset();
      this._depthCullingState.depthFunc = this._gl.LEQUAL;
      this._alphaState.reset();
      this._alphaMode = 1;
      this._alphaEquation = 0;
      this._colorWrite = true;
      this._colorWriteChanged = true;
      this._unpackFlipYCached = null;
      this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
      this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      this._mustWipeVertexAttributes = true;
      this.unbindAllAttributes();
    }
    this._resetVertexBufferBinding();
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
    this.bindIndexBuffer(null);
  }
  /**
   * @internal
   */
  _getSamplingParameters(samplingMode, generateMipMaps) {
    const gl = this._gl;
    let magFilter = gl.NEAREST;
    let minFilter = gl.NEAREST;
    switch (samplingMode) {
      case 11:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_NEAREST;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 3:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_LINEAR;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 8:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 4:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 5:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_NEAREST;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 6:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_LINEAR;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 7:
        magFilter = gl.NEAREST;
        minFilter = gl.LINEAR;
        break;
      case 1:
        magFilter = gl.NEAREST;
        minFilter = gl.NEAREST;
        break;
      case 9:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 10:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 2:
        magFilter = gl.LINEAR;
        minFilter = gl.LINEAR;
        break;
      case 12:
        magFilter = gl.LINEAR;
        minFilter = gl.NEAREST;
        break;
    }
    return {
      min: minFilter,
      mag: magFilter
    };
  }
  /** @internal */
  _createTexture() {
    const texture = this._gl.createTexture();
    if (!texture) {
      throw new Error("Unable to create texture");
    }
    return texture;
  }
  /** @internal */
  _createHardwareTexture() {
    return new WebGLHardwareTexture(this._createTexture(), this._gl);
  }
  /**
   * Creates an internal texture without binding it to a framebuffer
   * @internal
   * @param size defines the size of the texture
   * @param options defines the options used to create the texture
   * @param delayGPUTextureCreation true to delay the texture creation the first time it is really needed. false to create it right away
   * @param source source type of the texture
   * @returns a new internal texture
   */
  _createInternalTexture(size, options, delayGPUTextureCreation = true, source = InternalTextureSource.Unknown) {
    let generateMipMaps = false;
    let type = 0;
    let samplingMode = 3;
    let format = 5;
    let useSRGBBuffer = false;
    let samples = 1;
    let label;
    if (options !== void 0 && typeof options === "object") {
      generateMipMaps = !!options.generateMipMaps;
      type = options.type === void 0 ? 0 : options.type;
      samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
      format = options.format === void 0 ? 5 : options.format;
      useSRGBBuffer = options.useSRGBBuffer === void 0 ? false : options.useSRGBBuffer;
      samples = options.samples ?? 1;
      label = options.label;
    } else {
      generateMipMaps = !!options;
    }
    useSRGBBuffer && (useSRGBBuffer = this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU));
    if (type === 1 && !this._caps.textureFloatLinearFiltering) {
      samplingMode = 1;
    } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      samplingMode = 1;
    }
    if (type === 1 && !this._caps.textureFloat) {
      type = 0;
      Logger.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE");
    }
    const gl = this._gl;
    const texture = new InternalTexture(this, source);
    const width = size.width || size;
    const height = size.height || size;
    const layers = size.layers || 0;
    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    const target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
    const sizedFormat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);
    const internalFormat = this._getInternalFormat(format);
    const textureType = this._getWebGLTextureType(type);
    this._bindTextureDirectly(target, texture);
    if (layers !== 0) {
      texture.is2DArray = true;
      gl.texImage3D(target, 0, sizedFormat, width, height, layers, 0, internalFormat, textureType, null);
    } else {
      gl.texImage2D(target, 0, sizedFormat, width, height, 0, internalFormat, textureType, null);
    }
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture._useSRGBBuffer = useSRGBBuffer;
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.depth = layers;
    texture.isReady = true;
    texture.samples = samples;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    texture.type = type;
    texture.format = format;
    texture.label = label;
    this._internalTexturesCache.push(texture);
    return texture;
  }
  /**
   * @internal
   */
  _getUseSRGBBuffer(useSRGBBuffer, noMipmap) {
    return useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || noMipmap);
  }
  _createTextureBase(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, prepareTexture, prepareTextureProcessFunction, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, useSRGBBuffer) {
    url = url || "";
    const fromData = url.substr(0, 5) === "data:";
    const fromBlob = url.substr(0, 5) === "blob:";
    const isBase64 = fromData && url.indexOf(";base64,") !== -1;
    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);
    if (texture !== fallback) {
      texture.label = url.substring(0, 60);
    }
    const originalUrl = url;
    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {
      url = this._transformTextureUrl(url);
    }
    if (originalUrl !== url) {
      texture._originalUrl = originalUrl;
    }
    const lastDot = url.lastIndexOf(".");
    let extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
    let loader = null;
    const queryStringIndex = extension.indexOf("?");
    if (queryStringIndex > -1) {
      extension = extension.split("?")[0];
    }
    for (const availableLoader of _ThinEngine._TextureLoaders) {
      if (availableLoader.canLoad(extension, mimeType)) {
        loader = availableLoader;
        break;
      }
    }
    if (scene) {
      scene.addPendingData(texture);
    }
    texture.url = url;
    texture.generateMipMaps = !noMipmap;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture._useSRGBBuffer = this._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
    if (!this._doNotHandleContextLost) {
      texture._buffer = buffer;
    }
    let onLoadObserver = null;
    if (onLoad && !fallback) {
      onLoadObserver = texture.onLoadedObservable.add(onLoad);
    }
    if (!fallback) {
      this._internalTexturesCache.push(texture);
    }
    const onInternalError = (message, exception) => {
      if (scene) {
        scene.removePendingData(texture);
      }
      if (url === originalUrl) {
        if (onLoadObserver) {
          texture.onLoadedObservable.remove(onLoadObserver);
        }
        if (EngineStore.UseFallbackTexture && url !== EngineStore.FallbackTexture) {
          this._createTextureBase(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture);
        }
        message = (message || "Unknown error") + (EngineStore.UseFallbackTexture ? " - Fallback texture was used" : "");
        texture.onErrorObservable.notifyObservers({ message, exception });
        if (onError) {
          onError(message, exception);
        }
      } else {
        Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);
        this._createTextureBase(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
      }
    };
    if (loader) {
      const callback = (data) => {
        loader.loadData(data, texture, (width, height, loadMipmap, isCompressed, done, loadFailed) => {
          if (loadFailed) {
            onInternalError("TextureLoader failed to load data");
          } else {
            prepareTexture(texture, extension, scene, { width, height }, texture.invertY, !loadMipmap, isCompressed, () => {
              done();
              return false;
            }, samplingMode);
          }
        }, loaderOptions);
      };
      if (!buffer) {
        this._loadFile(url, (data) => callback(new Uint8Array(data)), void 0, scene ? scene.offlineProvider : void 0, true, (request, exception) => {
          onInternalError("Unable to load " + (request ? request.responseURL : url, exception));
        });
      } else {
        if (buffer instanceof ArrayBuffer) {
          callback(new Uint8Array(buffer));
        } else if (ArrayBuffer.isView(buffer)) {
          callback(buffer);
        } else {
          if (onError) {
            onError("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null);
          }
        }
      }
    } else {
      const onload = (img) => {
        if (fromBlob && !this._doNotHandleContextLost) {
          texture._buffer = img;
        }
        prepareTexture(texture, extension, scene, img, texture.invertY, noMipmap, false, prepareTextureProcessFunction, samplingMode);
      };
      if (!fromData || isBase64) {
        if (buffer && (typeof buffer.decoding === "string" || buffer.close)) {
          onload(buffer);
        } else {
          _ThinEngine._FileToolsLoadImage(url, onload, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
        }
      } else if (typeof buffer === "string" || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer) || buffer instanceof Blob) {
        _ThinEngine._FileToolsLoadImage(buffer, onload, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
      } else if (buffer) {
        onload(buffer);
      }
    }
    return texture;
  }
  /**
   * Usually called from Texture.ts.
   * Passed information to create a WebGLTexture
   * @param url defines a value which contains one of the following:
   * * A conventional http URL, e.g. 'http://...' or 'file://...'
   * * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
   * * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'
   * @param noMipmap defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file
   * @param invertY when true, image is flipped when loaded.  You probably want true. Certain compressed textures may invert this if their default is inverted (eg. ktx)
   * @param scene needed for loading to the correct scene
   * @param samplingMode mode with should be used sample / access the texture (Default: Texture.TRILINEAR_SAMPLINGMODE)
   * @param onLoad optional callback to be called upon successful completion
   * @param onError optional callback to be called upon failure
   * @param buffer a source of a file previously fetched as either a base64 string, an ArrayBuffer (compressed or image format), HTMLImageElement (image format), or a Blob
   * @param fallback an internal argument in case the function must be called again, due to etc1 not having alpha capabilities
   * @param format internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures
   * @param forcedExtension defines the extension to use to pick the right loader
   * @param mimeType defines an optional mime type
   * @param loaderOptions options to be passed to the loader
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns a InternalTexture for assignment back into BABYLON.Texture
   */
  createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {
    return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, this._prepareWebGLTexture.bind(this), (potWidth, potHeight, img, extension, texture, continuationCallback) => {
      const gl = this._gl;
      const isPot = img.width === potWidth && img.height === potHeight;
      texture._creationFlags = creationFlags ?? 0;
      const tip = this._getTexImageParametersForCreateTexture(format, extension, texture._useSRGBBuffer);
      if (isPot) {
        gl.texImage2D(gl.TEXTURE_2D, 0, tip.internalFormat, tip.format, tip.type, img);
        return false;
      }
      const maxTextureSize = this._caps.maxTextureSize;
      if (img.width > maxTextureSize || img.height > maxTextureSize || !this._supportsHardwareTextureRescaling) {
        this._prepareWorkingCanvas();
        if (!this._workingCanvas || !this._workingContext) {
          return false;
        }
        this._workingCanvas.width = potWidth;
        this._workingCanvas.height = potHeight;
        this._workingContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, potWidth, potHeight);
        gl.texImage2D(gl.TEXTURE_2D, 0, tip.internalFormat, tip.format, tip.type, this._workingCanvas);
        texture.width = potWidth;
        texture.height = potHeight;
        return false;
      } else {
        const source = new InternalTexture(this, InternalTextureSource.Temp);
        this._bindTextureDirectly(gl.TEXTURE_2D, source, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, tip.internalFormat, tip.format, tip.type, img);
        this._rescaleTexture(source, texture, scene, tip.format, () => {
          this._releaseTexture(source);
          this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
          continuationCallback();
        });
      }
      return true;
    }, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
  }
  /**
   * Calls to the GL texImage2D and texImage3D functions require three arguments describing the pixel format of the texture.
   * createTexture derives these from the babylonFormat and useSRGBBuffer arguments and also the file extension of the URL it's working with.
   * This function encapsulates that derivation for easy unit testing.
   * @param babylonFormat Babylon's format enum, as specified in ITextureCreationOptions.
   * @param fileExtension The file extension including the dot, e.g. .jpg.
   * @param useSRGBBuffer Use SRGB not linear.
   * @returns The options to pass to texImage2D or texImage3D calls.
   * @internal
   */
  _getTexImageParametersForCreateTexture(babylonFormat, fileExtension, useSRGBBuffer) {
    if (babylonFormat === void 0 || babylonFormat === null) {
      babylonFormat = fileExtension === ".jpg" && !useSRGBBuffer ? 4 : 5;
    }
    let format, internalFormat;
    if (this.webGLVersion === 1) {
      format = this._getInternalFormat(babylonFormat, useSRGBBuffer);
      internalFormat = format;
    } else {
      format = this._getInternalFormat(babylonFormat, false);
      internalFormat = this._getRGBABufferInternalSizedFormat(0, babylonFormat, useSRGBBuffer);
    }
    return {
      internalFormat,
      format,
      type: this._gl.UNSIGNED_BYTE
    };
  }
  /**
   * Loads an image as an HTMLImageElement.
   * @param input url string, ArrayBuffer, or Blob to load
   * @param onLoad callback called when the image successfully loads
   * @param onError callback called when the image fails to load
   * @param offlineProvider offline provider for caching
   * @param mimeType optional mime type
   * @param imageBitmapOptions optional the options to use when creating an ImageBitmap
   * @returns the HTMLImageElement of the loaded image
   * @internal
   */
  static _FileToolsLoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
    throw _WarnImport("FileTools");
  }
  /**
   * @internal
   */
  _rescaleTexture(source, destination, scene, internalFormat, onComplete) {
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a raw texture
   * @param data defines the data to store in the texture
   * @param width defines the width of the texture
   * @param height defines the height of the texture
   * @param format defines the format of the data
   * @param generateMipMaps defines if the engine should generate the mip levels
   * @param invertY defines if data must be stored with Y axis inverted
   * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)
   * @param compression defines the compression used (null by default)
   * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_INT by default)
   * @param creationFlags specific flags to use when creating the texture (1 for storage textures, for eg)
   * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).
   * @returns the raw texture inside an InternalTexture
   */
  createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
    throw _WarnImport("Engine.RawTexture");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a new raw cube texture
   * @param data defines the array of data to use to create each face
   * @param size defines the size of the textures
   * @param format defines the format of the data
   * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_INT)
   * @param generateMipMaps  defines if the engine should generate the mip levels
   * @param invertY defines if data must be stored with Y axis inverted
   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
   * @param compression defines the compression used (null by default)
   * @returns the cube texture as an InternalTexture
   */
  createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {
    throw _WarnImport("Engine.RawTexture");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a new raw 3D texture
   * @param data defines the data used to create the texture
   * @param width defines the width of the texture
   * @param height defines the height of the texture
   * @param depth defines the depth of the texture
   * @param format defines the format of the texture
   * @param generateMipMaps defines if the engine must generate mip levels
   * @param invertY defines if data must be stored with Y axis inverted
   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
   * @param compression defines the compressed used (can be null)
   * @param textureType defines the compressed used (can be null)
   * @returns a new raw 3D texture (stored in an InternalTexture)
   */
  createRawTexture3D(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
    throw _WarnImport("Engine.RawTexture");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a new raw 2D array texture
   * @param data defines the data used to create the texture
   * @param width defines the width of the texture
   * @param height defines the height of the texture
   * @param depth defines the number of layers of the texture
   * @param format defines the format of the texture
   * @param generateMipMaps defines if the engine must generate mip levels
   * @param invertY defines if data must be stored with Y axis inverted
   * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)
   * @param compression defines the compressed used (can be null)
   * @param textureType defines the compressed used (can be null)
   * @returns a new raw 2D array texture (stored in an InternalTexture)
   */
  createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
    throw _WarnImport("Engine.RawTexture");
  }
  /**
   * @internal
   */
  _unpackFlipY(value) {
    if (this._unpackFlipYCached !== value) {
      this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, value ? 1 : 0);
      if (this.enableUnpackFlipYCached) {
        this._unpackFlipYCached = value;
      }
    }
  }
  /** @internal */
  _getUnpackAlignement() {
    return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);
  }
  _getTextureTarget(texture) {
    if (texture.isCube) {
      return this._gl.TEXTURE_CUBE_MAP;
    } else if (texture.is3D) {
      return this._gl.TEXTURE_3D;
    } else if (texture.is2DArray || texture.isMultiview) {
      return this._gl.TEXTURE_2D_ARRAY;
    }
    return this._gl.TEXTURE_2D;
  }
  /**
   * Update the sampling mode of a given texture
   * @param samplingMode defines the required sampling mode
   * @param texture defines the texture to update
   * @param generateMipMaps defines whether to generate mipmaps for the texture
   */
  updateTextureSamplingMode(samplingMode, texture, generateMipMaps = false) {
    const target = this._getTextureTarget(texture);
    const filters = this._getSamplingParameters(samplingMode, texture.useMipMaps || generateMipMaps);
    this._setTextureParameterInteger(target, this._gl.TEXTURE_MAG_FILTER, filters.mag, texture);
    this._setTextureParameterInteger(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      texture.generateMipMaps = true;
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture.samplingMode = samplingMode;
  }
  /**
   * Update the dimensions of a texture
   * @param texture texture to update
   * @param width new width of the texture
   * @param height new height of the texture
   * @param depth new depth of the texture
   */
  updateTextureDimensions(texture, width, height, depth = 1) {
  }
  /**
   * Update the sampling mode of a given texture
   * @param texture defines the texture to update
   * @param wrapU defines the texture wrap mode of the u coordinates
   * @param wrapV defines the texture wrap mode of the v coordinates
   * @param wrapR defines the texture wrap mode of the r coordinates
   */
  updateTextureWrappingMode(texture, wrapU, wrapV = null, wrapR = null) {
    const target = this._getTextureTarget(texture);
    if (wrapU !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(wrapU), texture);
      texture._cachedWrapU = wrapU;
    }
    if (wrapV !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(wrapV), texture);
      texture._cachedWrapV = wrapV;
    }
    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {
      this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(wrapR), texture);
      texture._cachedWrapR = wrapR;
    }
    this._bindTextureDirectly(target, null);
  }
  /**
   * @internal
   */
  _setupDepthStencilTexture(internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction, samples = 1) {
    const width = size.width || size;
    const height = size.height || size;
    const layers = size.layers || 0;
    internalTexture.baseWidth = width;
    internalTexture.baseHeight = height;
    internalTexture.width = width;
    internalTexture.height = height;
    internalTexture.is2DArray = layers > 0;
    internalTexture.depth = layers;
    internalTexture.isReady = true;
    internalTexture.samples = samples;
    internalTexture.generateMipMaps = false;
    internalTexture.samplingMode = bilinearFiltering ? 2 : 1;
    internalTexture.type = 0;
    internalTexture._comparisonFunction = comparisonFunction;
    const gl = this._gl;
    const target = this._getTextureTarget(internalTexture);
    const samplingParameters = this._getSamplingParameters(internalTexture.samplingMode, false);
    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, samplingParameters.mag);
    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, samplingParameters.min);
    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (this.webGLVersion > 1) {
      if (comparisonFunction === 0) {
        gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, 515);
        gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.NONE);
      } else {
        gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
        gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      }
    }
  }
  /**
   * @internal
   */
  _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {
    const gl = this._gl;
    let target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    if (texture._useSRGBBuffer) {
      switch (internalFormat) {
        case 37492:
        case 36196:
          if (this._caps.etc2) {
            internalFormat = gl.COMPRESSED_SRGB8_ETC2;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 37496:
          if (this._caps.etc2) {
            internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 36492:
          internalFormat = gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
          break;
        case 37808:
          internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
          break;
        case 33776:
          if (this._caps.s3tc_srgb) {
            internalFormat = gl.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 33777:
          if (this._caps.s3tc_srgb) {
            internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 33779:
          if (this._caps.s3tc_srgb) {
            internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        default:
          texture._useSRGBBuffer = false;
          break;
      }
    }
    this._gl.compressedTexImage2D(target, lod, internalFormat, width, height, 0, data);
  }
  /**
   * @internal
   */
  _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0, babylonInternalFormat, useTextureWidthAndHeight = false) {
    const gl = this._gl;
    const textureType = this._getWebGLTextureType(texture.type);
    const format = this._getInternalFormat(texture.format);
    const internalFormat = babylonInternalFormat === void 0 ? this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer) : this._getInternalFormat(babylonInternalFormat, texture._useSRGBBuffer);
    this._unpackFlipY(texture.invertY);
    let target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);
    const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);
    const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));
    const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));
    gl.texImage2D(target, lod, internalFormat, width, height, 0, format, textureType, imageData);
  }
  /**
   * Update a portion of an internal texture
   * @param texture defines the texture to update
   * @param imageData defines the data to store into the texture
   * @param xOffset defines the x coordinates of the update rectangle
   * @param yOffset defines the y coordinates of the update rectangle
   * @param width defines the width of the update rectangle
   * @param height defines the height of the update rectangle
   * @param faceIndex defines the face index if texture is a cube (0 by default)
   * @param lod defines the lod level to update (0 by default)
   * @param generateMipMaps defines whether to generate mipmaps or not
   */
  updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {
    const gl = this._gl;
    const textureType = this._getWebGLTextureType(texture.type);
    const format = this._getInternalFormat(texture.format);
    this._unpackFlipY(texture.invertY);
    let targetForBinding = gl.TEXTURE_2D;
    let target = gl.TEXTURE_2D;
    if (texture.isCube) {
      target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
      targetForBinding = gl.TEXTURE_CUBE_MAP;
    }
    this._bindTextureDirectly(targetForBinding, texture, true);
    gl.texSubImage2D(target, lod, xOffset, yOffset, width, height, format, textureType, imageData);
    if (generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(targetForBinding, null);
  }
  /**
   * @internal
   */
  _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {
    const gl = this._gl;
    const bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    this._bindTextureDirectly(bindTarget, texture, true);
    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);
    this._bindTextureDirectly(bindTarget, null, true);
  }
  _prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode) {
    const gl = this._gl;
    if (!gl) {
      return;
    }
    const filters = this._getSamplingParameters(samplingMode, !noMipmap);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);
    if (!noMipmap && !isCompressed) {
      gl.generateMipmap(gl.TEXTURE_2D);
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, null);
    if (scene) {
      scene.removePendingData(texture);
    }
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
  }
  _prepareWebGLTexture(texture, extension, scene, img, invertY, noMipmap, isCompressed, processFunction, samplingMode = 3) {
    const maxTextureSize = this.getCaps().maxTextureSize;
    const potWidth = Math.min(maxTextureSize, this.needPOTTextures ? _ThinEngine.GetExponentOfTwo(img.width, maxTextureSize) : img.width);
    const potHeight = Math.min(maxTextureSize, this.needPOTTextures ? _ThinEngine.GetExponentOfTwo(img.height, maxTextureSize) : img.height);
    const gl = this._gl;
    if (!gl) {
      return;
    }
    if (!texture._hardwareTexture) {
      if (scene) {
        scene.removePendingData(texture);
      }
      return;
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    texture.baseWidth = img.width;
    texture.baseHeight = img.height;
    texture.width = potWidth;
    texture.height = potHeight;
    texture.isReady = true;
    texture.type = texture.type !== -1 ? texture.type : 0;
    texture.format = texture.format !== -1 ? texture.format : extension === ".jpg" && !texture._useSRGBBuffer ? 4 : 5;
    if (processFunction(potWidth, potHeight, img, extension, texture, () => {
      this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
    })) {
      return;
    }
    this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
  }
  /**
   * @internal
   */
  _setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height, samples = 1) {
    const gl = this._gl;
    if (generateStencilBuffer && generateDepthBuffer) {
      return this._createRenderBuffer(width, height, samples, gl.DEPTH_STENCIL, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);
    }
    if (generateDepthBuffer) {
      let depthFormat = gl.DEPTH_COMPONENT16;
      if (this._webGLVersion > 1) {
        depthFormat = gl.DEPTH_COMPONENT32F;
      }
      return this._createRenderBuffer(width, height, samples, depthFormat, depthFormat, gl.DEPTH_ATTACHMENT);
    }
    if (generateStencilBuffer) {
      return this._createRenderBuffer(width, height, samples, gl.STENCIL_INDEX8, gl.STENCIL_INDEX8, gl.STENCIL_ATTACHMENT);
    }
    return null;
  }
  /**
   * @internal
   */
  _createRenderBuffer(width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer = true) {
    const gl = this._gl;
    const renderBuffer = gl.createRenderbuffer();
    return this._updateRenderBuffer(renderBuffer, width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer);
  }
  _updateRenderBuffer(renderBuffer, width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer = true) {
    const gl = this._gl;
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
    if (samples > 1 && gl.renderbufferStorageMultisample) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, msInternalFormat, width, height);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
    }
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderBuffer);
    if (unbindBuffer) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }
    return renderBuffer;
  }
  /**
   * @internal
   */
  _releaseTexture(texture) {
    var _a;
    this._deleteTexture((_a = texture._hardwareTexture) == null ? void 0 : _a.underlyingResource);
    this.unbindAllTextures();
    const index = this._internalTexturesCache.indexOf(texture);
    if (index !== -1) {
      this._internalTexturesCache.splice(index, 1);
    }
    if (texture._lodTextureHigh) {
      texture._lodTextureHigh.dispose();
    }
    if (texture._lodTextureMid) {
      texture._lodTextureMid.dispose();
    }
    if (texture._lodTextureLow) {
      texture._lodTextureLow.dispose();
    }
    if (texture._irradianceTexture) {
      texture._irradianceTexture.dispose();
    }
  }
  /**
   * @internal
   */
  _releaseRenderTargetWrapper(rtWrapper) {
    const index = this._renderTargetWrapperCache.indexOf(rtWrapper);
    if (index !== -1) {
      this._renderTargetWrapperCache.splice(index, 1);
    }
  }
  _deleteTexture(texture) {
    if (texture) {
      this._gl.deleteTexture(texture);
    }
  }
  _setProgram(program) {
    if (this._currentProgram !== program) {
      this._gl.useProgram(program);
      this._currentProgram = program;
    }
  }
  /**
   * Binds an effect to the webGL context
   * @param effect defines the effect to bind
   */
  bindSamplers(effect) {
    const webGLPipelineContext = effect.getPipelineContext();
    this._setProgram(webGLPipelineContext.program);
    const samplers = effect.getSamplers();
    for (let index = 0; index < samplers.length; index++) {
      const uniform = effect.getUniform(samplers[index]);
      if (uniform) {
        this._boundUniforms[index] = uniform;
      }
    }
    this._currentEffect = null;
  }
  _activateCurrentTexture() {
    if (this._currentTextureChannel !== this._activeChannel) {
      this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel);
      this._currentTextureChannel = this._activeChannel;
    }
  }
  /**
   * @internal
   */
  _bindTextureDirectly(target, texture, forTextureDataUpdate = false, force = false) {
    var _a;
    let wasPreviouslyBound = false;
    const isTextureForRendering = texture && texture._associatedChannel > -1;
    if (forTextureDataUpdate && isTextureForRendering) {
      this._activeChannel = texture._associatedChannel;
    }
    const currentTextureBound = this._boundTexturesCache[this._activeChannel];
    if (currentTextureBound !== texture || force) {
      this._activateCurrentTexture();
      if (texture && texture.isMultiview) {
        Logger.Error(["_bindTextureDirectly called with a multiview texture!", target, texture]);
        throw "_bindTextureDirectly called with a multiview texture!";
      } else {
        this._gl.bindTexture(target, ((_a = texture == null ? void 0 : texture._hardwareTexture) == null ? void 0 : _a.underlyingResource) ?? null);
      }
      this._boundTexturesCache[this._activeChannel] = texture;
      if (texture) {
        texture._associatedChannel = this._activeChannel;
      }
    } else if (forTextureDataUpdate) {
      wasPreviouslyBound = true;
      this._activateCurrentTexture();
    }
    if (isTextureForRendering && !forTextureDataUpdate) {
      this._bindSamplerUniformToChannel(texture._associatedChannel, this._activeChannel);
    }
    return wasPreviouslyBound;
  }
  /**
   * @internal
   */
  _bindTexture(channel, texture, name) {
    if (channel === void 0) {
      return;
    }
    if (texture) {
      texture._associatedChannel = channel;
    }
    this._activeChannel = channel;
    const target = texture ? this._getTextureTarget(texture) : this._gl.TEXTURE_2D;
    this._bindTextureDirectly(target, texture);
  }
  /**
   * Unbind all textures from the webGL context
   */
  unbindAllTextures() {
    for (let channel = 0; channel < this._maxSimultaneousTextures; channel++) {
      this._activeChannel = channel;
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
      if (this.webGLVersion > 1) {
        this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
        this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
      }
    }
  }
  /**
   * Sets a texture to the according uniform.
   * @param channel The texture channel
   * @param uniform The uniform to set
   * @param texture The texture to apply
   * @param name The name of the uniform in the effect
   */
  setTexture(channel, uniform, texture, name) {
    if (channel === void 0) {
      return;
    }
    if (uniform) {
      this._boundUniforms[channel] = uniform;
    }
    this._setTexture(channel, texture);
  }
  _bindSamplerUniformToChannel(sourceSlot, destination) {
    const uniform = this._boundUniforms[sourceSlot];
    if (!uniform || uniform._currentState === destination) {
      return;
    }
    this._gl.uniform1i(uniform, destination);
    uniform._currentState = destination;
  }
  _getTextureWrapMode(mode) {
    switch (mode) {
      case 1:
        return this._gl.REPEAT;
      case 0:
        return this._gl.CLAMP_TO_EDGE;
      case 2:
        return this._gl.MIRRORED_REPEAT;
    }
    return this._gl.REPEAT;
  }
  _setTexture(channel, texture, isPartOfTextureArray = false, depthStencilTexture = false, name = "") {
    if (!texture) {
      if (this._boundTexturesCache[channel] != null) {
        this._activeChannel = channel;
        this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
        if (this.webGLVersion > 1) {
          this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
          this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
        }
      }
      return false;
    }
    if (texture.video) {
      this._activeChannel = channel;
      const videoInternalTexture = texture.getInternalTexture();
      if (videoInternalTexture) {
        videoInternalTexture._associatedChannel = channel;
      }
      texture.update();
    } else if (texture.delayLoadState === 4) {
      texture.delayLoad();
      return false;
    }
    let internalTexture;
    if (depthStencilTexture) {
      internalTexture = texture.depthStencilTexture;
    } else if (texture.isReady()) {
      internalTexture = texture.getInternalTexture();
    } else if (texture.isCube) {
      internalTexture = this.emptyCubeTexture;
    } else if (texture.is3D) {
      internalTexture = this.emptyTexture3D;
    } else if (texture.is2DArray) {
      internalTexture = this.emptyTexture2DArray;
    } else {
      internalTexture = this.emptyTexture;
    }
    if (!isPartOfTextureArray && internalTexture) {
      internalTexture._associatedChannel = channel;
    }
    let needToBind = true;
    if (this._boundTexturesCache[channel] === internalTexture) {
      if (!isPartOfTextureArray) {
        this._bindSamplerUniformToChannel(internalTexture._associatedChannel, channel);
      }
      needToBind = false;
    }
    this._activeChannel = channel;
    const target = this._getTextureTarget(internalTexture);
    if (needToBind) {
      this._bindTextureDirectly(target, internalTexture, isPartOfTextureArray);
    }
    if (internalTexture && !internalTexture.isMultiview) {
      if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {
        internalTexture._cachedCoordinatesMode = texture.coordinatesMode;
        const textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;
        texture.wrapU = textureWrapMode;
        texture.wrapV = textureWrapMode;
      }
      if (internalTexture._cachedWrapU !== texture.wrapU) {
        internalTexture._cachedWrapU = texture.wrapU;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(texture.wrapU), internalTexture);
      }
      if (internalTexture._cachedWrapV !== texture.wrapV) {
        internalTexture._cachedWrapV = texture.wrapV;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(texture.wrapV), internalTexture);
      }
      if (internalTexture.is3D && internalTexture._cachedWrapR !== texture.wrapR) {
        internalTexture._cachedWrapR = texture.wrapR;
        this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(texture.wrapR), internalTexture);
      }
      this._setAnisotropicLevel(target, internalTexture, texture.anisotropicFilteringLevel);
    }
    return true;
  }
  /**
   * Sets an array of texture to the webGL context
   * @param channel defines the channel where the texture array must be set
   * @param uniform defines the associated uniform location
   * @param textures defines the array of textures to bind
   * @param name name of the channel
   */
  setTextureArray(channel, uniform, textures, name) {
    if (channel === void 0 || !uniform) {
      return;
    }
    if (!this._textureUnits || this._textureUnits.length !== textures.length) {
      this._textureUnits = new Int32Array(textures.length);
    }
    for (let i = 0; i < textures.length; i++) {
      const texture = textures[i].getInternalTexture();
      if (texture) {
        this._textureUnits[i] = channel + i;
        texture._associatedChannel = channel + i;
      } else {
        this._textureUnits[i] = -1;
      }
    }
    this._gl.uniform1iv(uniform, this._textureUnits);
    for (let index = 0; index < textures.length; index++) {
      this._setTexture(this._textureUnits[index], textures[index], true);
    }
  }
  /**
   * @internal
   */
  _setAnisotropicLevel(target, internalTexture, anisotropicFilteringLevel) {
    const anisotropicFilterExtension = this._caps.textureAnisotropicFilterExtension;
    if (internalTexture.samplingMode !== 11 && internalTexture.samplingMode !== 3 && internalTexture.samplingMode !== 2) {
      anisotropicFilteringLevel = 1;
    }
    if (anisotropicFilterExtension && internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {
      this._setTextureParameterFloat(target, anisotropicFilterExtension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy), internalTexture);
      internalTexture._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
    }
  }
  _setTextureParameterFloat(target, parameter, value, texture) {
    this._bindTextureDirectly(target, texture, true, true);
    this._gl.texParameterf(target, parameter, value);
  }
  _setTextureParameterInteger(target, parameter, value, texture) {
    if (texture) {
      this._bindTextureDirectly(target, texture, true, true);
    }
    this._gl.texParameteri(target, parameter, value);
  }
  /**
   * Unbind all vertex attributes from the webGL context
   */
  unbindAllAttributes() {
    if (this._mustWipeVertexAttributes) {
      this._mustWipeVertexAttributes = false;
      for (let i = 0; i < this._caps.maxVertexAttribs; i++) {
        this.disableAttributeByIndex(i);
      }
      return;
    }
    for (let i = 0, ul = this._vertexAttribArraysEnabled.length; i < ul; i++) {
      if (i >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[i]) {
        continue;
      }
      this.disableAttributeByIndex(i);
    }
  }
  /**
   * Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
   */
  releaseEffects() {
    for (const name in this._compiledEffects) {
      const webGLPipelineContext = this._compiledEffects[name].getPipelineContext();
      this._deletePipelineContext(webGLPipelineContext);
    }
    this._compiledEffects = {};
  }
  /**
   * Dispose and release all associated resources
   */
  dispose() {
    var _a, _b;
    this._isDisposed = true;
    this.stopRenderLoop();
    if (this.onBeforeTextureInitObservable) {
      this.onBeforeTextureInitObservable.clear();
    }
    if (this._emptyTexture) {
      this._releaseTexture(this._emptyTexture);
      this._emptyTexture = null;
    }
    if (this._emptyCubeTexture) {
      this._releaseTexture(this._emptyCubeTexture);
      this._emptyCubeTexture = null;
    }
    if (this._dummyFramebuffer) {
      this._gl.deleteFramebuffer(this._dummyFramebuffer);
    }
    this.releaseEffects();
    (_a = this.releaseComputeEffects) == null ? void 0 : _a.call(this);
    this.unbindAllAttributes();
    this._boundUniforms = {};
    if (IsWindowObjectExist()) {
      if (this._renderingCanvas) {
        if (!this._doNotHandleContextLost) {
          this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost);
          this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored);
        }
        window.removeEventListener("resize", this._checkForMobile);
      }
    }
    this._workingCanvas = null;
    this._workingContext = null;
    this._currentBufferPointers.length = 0;
    this._renderingCanvas = null;
    this._currentProgram = null;
    this._boundRenderFunction = null;
    Effect.ResetCache();
    for (const request of this._activeRequests) {
      request.abort();
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    if (this._creationOptions.loseContextOnDispose) {
      (_b = this._gl.getExtension("WEBGL_lose_context")) == null ? void 0 : _b.loseContext();
    }
  }
  /**
   * Attach a new callback raised when context lost event is fired
   * @param callback defines the callback to call
   */
  attachContextLostEvent(callback) {
    if (this._renderingCanvas) {
      this._renderingCanvas.addEventListener("webglcontextlost", callback, false);
    }
  }
  /**
   * Attach a new callback raised when context restored event is fired
   * @param callback defines the callback to call
   */
  attachContextRestoredEvent(callback) {
    if (this._renderingCanvas) {
      this._renderingCanvas.addEventListener("webglcontextrestored", callback, false);
    }
  }
  /**
   * Get the current error code of the webGL context
   * @returns the error code
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/getError
   */
  getError() {
    return this._gl.getError();
  }
  _canRenderToFloatFramebuffer() {
    if (this._webGLVersion > 1) {
      return this._caps.colorBufferFloat;
    }
    return this._canRenderToFramebuffer(1);
  }
  _canRenderToHalfFloatFramebuffer() {
    if (this._webGLVersion > 1) {
      return this._caps.colorBufferFloat;
    }
    return this._canRenderToFramebuffer(2);
  }
  // Thank you : http://stackoverflow.com/questions/28827511/webgl-ios-render-to-floating-point-texture
  _canRenderToFramebuffer(type) {
    const gl = this._gl;
    while (gl.getError() !== gl.NO_ERROR) {
    }
    let successful = true;
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), 1, 1, 0, gl.RGBA, this._getWebGLTextureType(type), null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    successful = successful && status === gl.FRAMEBUFFER_COMPLETE;
    successful = successful && gl.getError() === gl.NO_ERROR;
    if (successful) {
      gl.clear(gl.COLOR_BUFFER_BIT);
      successful = successful && gl.getError() === gl.NO_ERROR;
    }
    if (successful) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      const readFormat = gl.RGBA;
      const readType = gl.UNSIGNED_BYTE;
      const buffer = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, readFormat, readType, buffer);
      successful = successful && gl.getError() === gl.NO_ERROR;
    }
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(fb);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    while (!successful && gl.getError() !== gl.NO_ERROR) {
    }
    return successful;
  }
  /**
   * @internal
   */
  _getWebGLTextureType(type) {
    if (this._webGLVersion === 1) {
      switch (type) {
        case 1:
          return this._gl.FLOAT;
        case 2:
          return this._gl.HALF_FLOAT_OES;
        case 0:
          return this._gl.UNSIGNED_BYTE;
        case 8:
          return this._gl.UNSIGNED_SHORT_4_4_4_4;
        case 9:
          return this._gl.UNSIGNED_SHORT_5_5_5_1;
        case 10:
          return this._gl.UNSIGNED_SHORT_5_6_5;
      }
      return this._gl.UNSIGNED_BYTE;
    }
    switch (type) {
      case 3:
        return this._gl.BYTE;
      case 0:
        return this._gl.UNSIGNED_BYTE;
      case 4:
        return this._gl.SHORT;
      case 5:
        return this._gl.UNSIGNED_SHORT;
      case 6:
        return this._gl.INT;
      case 7:
        return this._gl.UNSIGNED_INT;
      case 1:
        return this._gl.FLOAT;
      case 2:
        return this._gl.HALF_FLOAT;
      case 8:
        return this._gl.UNSIGNED_SHORT_4_4_4_4;
      case 9:
        return this._gl.UNSIGNED_SHORT_5_5_5_1;
      case 10:
        return this._gl.UNSIGNED_SHORT_5_6_5;
      case 11:
        return this._gl.UNSIGNED_INT_2_10_10_10_REV;
      case 12:
        return this._gl.UNSIGNED_INT_24_8;
      case 13:
        return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
      case 14:
        return this._gl.UNSIGNED_INT_5_9_9_9_REV;
      case 15:
        return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
    }
    return this._gl.UNSIGNED_BYTE;
  }
  /**
   * @internal
   */
  _getInternalFormat(format, useSRGBBuffer = false) {
    let internalFormat = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA;
    switch (format) {
      case 0:
        internalFormat = this._gl.ALPHA;
        break;
      case 1:
        internalFormat = this._gl.LUMINANCE;
        break;
      case 2:
        internalFormat = this._gl.LUMINANCE_ALPHA;
        break;
      case 6:
        internalFormat = this._gl.RED;
        break;
      case 7:
        internalFormat = this._gl.RG;
        break;
      case 4:
        internalFormat = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB : this._gl.RGB;
        break;
      case 5:
        internalFormat = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA;
        break;
    }
    if (this._webGLVersion > 1) {
      switch (format) {
        case 8:
          internalFormat = this._gl.RED_INTEGER;
          break;
        case 9:
          internalFormat = this._gl.RG_INTEGER;
          break;
        case 10:
          internalFormat = this._gl.RGB_INTEGER;
          break;
        case 11:
          internalFormat = this._gl.RGBA_INTEGER;
          break;
      }
    }
    return internalFormat;
  }
  /**
   * @internal
   */
  _getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer = false) {
    if (this._webGLVersion === 1) {
      if (format !== void 0) {
        switch (format) {
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          case 4:
            return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB : this._gl.RGB;
        }
      }
      return this._gl.RGBA;
    }
    switch (type) {
      case 3:
        switch (format) {
          case 6:
            return this._gl.R8_SNORM;
          case 7:
            return this._gl.RG8_SNORM;
          case 4:
            return this._gl.RGB8_SNORM;
          case 8:
            return this._gl.R8I;
          case 9:
            return this._gl.RG8I;
          case 10:
            return this._gl.RGB8I;
          case 11:
            return this._gl.RGBA8I;
          default:
            return this._gl.RGBA8_SNORM;
        }
      case 0:
        switch (format) {
          case 6:
            return this._gl.R8;
          case 7:
            return this._gl.RG8;
          case 4:
            return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8 : this._gl.RGB8;
          case 5:
            return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8;
          case 8:
            return this._gl.R8UI;
          case 9:
            return this._gl.RG8UI;
          case 10:
            return this._gl.RGB8UI;
          case 11:
            return this._gl.RGBA8UI;
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          default:
            return this._gl.RGBA8;
        }
      case 4:
        switch (format) {
          case 8:
            return this._gl.R16I;
          case 9:
            return this._gl.RG16I;
          case 10:
            return this._gl.RGB16I;
          case 11:
            return this._gl.RGBA16I;
          default:
            return this._gl.RGBA16I;
        }
      case 5:
        switch (format) {
          case 8:
            return this._gl.R16UI;
          case 9:
            return this._gl.RG16UI;
          case 10:
            return this._gl.RGB16UI;
          case 11:
            return this._gl.RGBA16UI;
          default:
            return this._gl.RGBA16UI;
        }
      case 6:
        switch (format) {
          case 8:
            return this._gl.R32I;
          case 9:
            return this._gl.RG32I;
          case 10:
            return this._gl.RGB32I;
          case 11:
            return this._gl.RGBA32I;
          default:
            return this._gl.RGBA32I;
        }
      case 7:
        switch (format) {
          case 8:
            return this._gl.R32UI;
          case 9:
            return this._gl.RG32UI;
          case 10:
            return this._gl.RGB32UI;
          case 11:
            return this._gl.RGBA32UI;
          default:
            return this._gl.RGBA32UI;
        }
      case 1:
        switch (format) {
          case 6:
            return this._gl.R32F;
          case 7:
            return this._gl.RG32F;
          case 4:
            return this._gl.RGB32F;
          case 5:
            return this._gl.RGBA32F;
          default:
            return this._gl.RGBA32F;
        }
      case 2:
        switch (format) {
          case 6:
            return this._gl.R16F;
          case 7:
            return this._gl.RG16F;
          case 4:
            return this._gl.RGB16F;
          case 5:
            return this._gl.RGBA16F;
          default:
            return this._gl.RGBA16F;
        }
      case 10:
        return this._gl.RGB565;
      case 13:
        return this._gl.R11F_G11F_B10F;
      case 14:
        return this._gl.RGB9_E5;
      case 8:
        return this._gl.RGBA4;
      case 9:
        return this._gl.RGB5_A1;
      case 11:
        switch (format) {
          case 5:
            return this._gl.RGB10_A2;
          case 11:
            return this._gl.RGB10_A2UI;
          default:
            return this._gl.RGB10_A2;
        }
    }
    return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8;
  }
  /**
   * @internal
   */
  _loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    const request = _ThinEngine._FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add((request2) => {
      this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
    });
    return request;
  }
  /**
   * Loads a file from a url
   * @param url url to load
   * @param onSuccess callback called when the file successfully loads
   * @param onProgress callback called while file is loading (if the server supports this mode)
   * @param offlineProvider defines the offline provider for caching
   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
   * @param onError callback called when the file fails to load
   * @returns a file request object
   * @internal
   */
  static _FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    throw _WarnImport("FileTools");
  }
  /**
   * Reads pixels from the current frame buffer. Please note that this function can be slow
   * @param x defines the x coordinate of the rectangle where pixels must be read
   * @param y defines the y coordinate of the rectangle where pixels must be read
   * @param width defines the width of the rectangle where pixels must be read
   * @param height defines the height of the rectangle where pixels must be read
   * @param hasAlpha defines whether the output should have alpha or not (defaults to true)
   * @param flushRenderer true to flush the renderer from the pending commands before reading the pixels
   * @returns a ArrayBufferView promise (Uint8Array) containing RGBA colors
   */
  readPixels(x, y, width, height, hasAlpha = true, flushRenderer = true) {
    const numChannels = hasAlpha ? 4 : 3;
    const format = hasAlpha ? this._gl.RGBA : this._gl.RGB;
    const data = new Uint8Array(height * width * numChannels);
    if (flushRenderer) {
      this.flushFramebuffer();
    }
    this._gl.readPixels(x, y, width, height, format, this._gl.UNSIGNED_BYTE, data);
    return Promise.resolve(data);
  }
  /**
   * Gets a Promise<boolean> indicating if the engine can be instantiated (ie. if a webGL context can be found)
   */
  static get IsSupportedAsync() {
    return Promise.resolve(this.isSupported());
  }
  /**
   * Gets a boolean indicating if the engine can be instantiated (ie. if a webGL context can be found)
   */
  static get IsSupported() {
    return this.isSupported();
  }
  /**
   * Gets a boolean indicating if the engine can be instantiated (ie. if a webGL context can be found)
   * @returns true if the engine can be created
   * @ignorenaming
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static isSupported() {
    if (this._HasMajorPerformanceCaveat !== null) {
      return !this._HasMajorPerformanceCaveat;
    }
    if (this._IsSupported === null) {
      try {
        const tempcanvas = this._CreateCanvas(1, 1);
        const gl = tempcanvas.getContext("webgl") || tempcanvas.getContext("experimental-webgl");
        this._IsSupported = gl != null && !!window.WebGLRenderingContext;
      } catch (e) {
        this._IsSupported = false;
      }
    }
    return this._IsSupported;
  }
  /**
   * Gets a boolean indicating if the engine can be instantiated on a performant device (ie. if a webGL context can be found and it does not use a slow implementation)
   */
  static get HasMajorPerformanceCaveat() {
    if (this._HasMajorPerformanceCaveat === null) {
      try {
        const tempcanvas = this._CreateCanvas(1, 1);
        const gl = tempcanvas.getContext("webgl", { failIfMajorPerformanceCaveat: true }) || tempcanvas.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: true });
        this._HasMajorPerformanceCaveat = !gl;
      } catch (e) {
        this._HasMajorPerformanceCaveat = false;
      }
    }
    return this._HasMajorPerformanceCaveat;
  }
  /**
   * Find the next highest power of two.
   * @param x Number to start search from.
   * @returns Next highest power of two.
   */
  static CeilingPOT(x) {
    x--;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x++;
    return x;
  }
  /**
   * Find the next lowest power of two.
   * @param x Number to start search from.
   * @returns Next lowest power of two.
   */
  static FloorPOT(x) {
    x = x | x >> 1;
    x = x | x >> 2;
    x = x | x >> 4;
    x = x | x >> 8;
    x = x | x >> 16;
    return x - (x >> 1);
  }
  /**
   * Find the nearest power of two.
   * @param x Number to start search from.
   * @returns Next nearest power of two.
   */
  static NearestPOT(x) {
    const c = _ThinEngine.CeilingPOT(x);
    const f = _ThinEngine.FloorPOT(x);
    return c - x > x - f ? f : c;
  }
  /**
   * Get the closest exponent of two
   * @param value defines the value to approximate
   * @param max defines the maximum value to return
   * @param mode defines how to define the closest value
   * @returns closest exponent of two of the given value
   */
  static GetExponentOfTwo(value, max, mode = 2) {
    let pot;
    switch (mode) {
      case 1:
        pot = _ThinEngine.FloorPOT(value);
        break;
      case 2:
        pot = _ThinEngine.NearestPOT(value);
        break;
      case 3:
      default:
        pot = _ThinEngine.CeilingPOT(value);
        break;
    }
    return Math.min(pot, max);
  }
  /**
   * Queue a new function into the requested animation frame pool (ie. this function will be executed by the browser (or the javascript engine) for the next frame)
   * @param func - the function to be called
   * @param requester - the object that will request the next frame. Falls back to window.
   * @returns frame number
   */
  static QueueNewFrame(func, requester) {
    if (!IsWindowObjectExist()) {
      if (typeof requestAnimationFrame === "function") {
        return requestAnimationFrame(func);
      }
    } else {
      const { requestAnimationFrame: requestAnimationFrame2 } = requester || window;
      if (typeof requestAnimationFrame2 === "function") {
        return requestAnimationFrame2(func);
      }
    }
    return setTimeout(func, 16);
  }
  /**
   * Gets host document
   * @returns the host document object
   */
  getHostDocument() {
    if (this._renderingCanvas && this._renderingCanvas.ownerDocument) {
      return this._renderingCanvas.ownerDocument;
    }
    return IsDocumentAvailable() ? document : null;
  }
};
ThinEngine._TempClearColorUint32 = new Uint32Array(4);
ThinEngine._TempClearColorInt32 = new Int32Array(4);
ThinEngine.ExceptionList = [
  { key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] },
  { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: "Chrome/12\\d\\..+?Mobile", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  // desktop osx safari 15.4
  { key: ".*AppleWebKit.*(15.4).*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] },
  // mobile browsers using safari 15.4 on ios
  { key: ".*(15.4).*AppleWebKit.*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] }
];
ThinEngine._TextureLoaders = [];
ThinEngine.CollisionsEpsilon = 1e-3;
ThinEngine._IsSupported = null;
ThinEngine._HasMajorPerformanceCaveat = null;

// node_modules/@babylonjs/core/Misc/timingTools.js
var TimingTools = class {
  /**
   * Polyfill for setImmediate
   * @param action defines the action to execute after the current execution block
   */
  static SetImmediate(action) {
    if (IsWindowObjectExist() && window.setImmediate) {
      window.setImmediate(action);
    } else {
      setTimeout(action, 1);
    }
  }
};

// node_modules/@babylonjs/core/Misc/fileTools.js
var Base64DataUrlRegEx = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);
var LoadFileError = class _LoadFileError extends RuntimeError {
  /**
   * Creates a new LoadFileError
   * @param message defines the message of the error
   * @param object defines the optional web request
   */
  constructor(message, object) {
    super(message, ErrorCodes.LoadFileError);
    this.name = "LoadFileError";
    BaseError._setPrototypeOf(this, _LoadFileError.prototype);
    if (object instanceof WebRequest) {
      this.request = object;
    } else {
      this.file = object;
    }
  }
};
var RequestFileError = class _RequestFileError extends RuntimeError {
  /**
   * Creates a new LoadFileError
   * @param message defines the message of the error
   * @param request defines the optional web request
   */
  constructor(message, request) {
    super(message, ErrorCodes.RequestFileError);
    this.request = request;
    this.name = "RequestFileError";
    BaseError._setPrototypeOf(this, _RequestFileError.prototype);
  }
};
var ReadFileError = class _ReadFileError extends RuntimeError {
  /**
   * Creates a new ReadFileError
   * @param message defines the message of the error
   * @param file defines the optional file
   */
  constructor(message, file) {
    super(message, ErrorCodes.ReadFileError);
    this.file = file;
    this.name = "ReadFileError";
    BaseError._setPrototypeOf(this, _ReadFileError.prototype);
  }
};
var FileToolsOptions = {
  /**
   * Gets or sets the retry strategy to apply when an error happens while loading an asset.
   * When defining this function, return the wait time before trying again or return -1 to
   * stop retrying and error out.
   */
  DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),
  /**
   * Gets or sets the base URL to use to load assets
   */
  BaseUrl: "",
  /**
   * Default behaviour for cors in the application.
   * It can be a string if the expected behavior is identical in the entire app.
   * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
   */
  CorsBehavior: "anonymous",
  /**
   * Gets or sets a function used to pre-process url before using them to load assets
   * @param url
   * @returns the processed url
   */
  PreprocessUrl: (url) => url,
  /**
   * Gets or sets the base URL to use to load scripts
   * Used for both JS and WASM
   */
  ScriptBaseUrl: "",
  /**
   * Gets or sets a function used to pre-process script url before using them to load.
   * Used for both JS and WASM
   * @param url defines the url to process
   * @returns the processed url
   */
  ScriptPreprocessUrl: (url) => url
};
var _CleanUrl = (url) => {
  url = url.replace(/#/gm, "%23");
  return url;
};
var SetCorsBehavior = (url, element) => {
  if (url && url.indexOf("data:") === 0) {
    return;
  }
  if (FileToolsOptions.CorsBehavior) {
    if (typeof FileToolsOptions.CorsBehavior === "string" || FileToolsOptions.CorsBehavior instanceof String) {
      element.crossOrigin = FileToolsOptions.CorsBehavior;
    } else {
      const result = FileToolsOptions.CorsBehavior(url);
      if (result) {
        element.crossOrigin = result;
      }
    }
  }
};
var LoadImage = (input, onLoad, onError, offlineProvider, mimeType = "", imageBitmapOptions) => {
  const engine = EngineStore.LastCreatedEngine;
  if (typeof HTMLImageElement === "undefined" && !(engine == null ? void 0 : engine._features.forceBitmapOverHTMLImageElement)) {
    onError("LoadImage is only supported in web or BabylonNative environments.");
    return null;
  }
  let url;
  let usingObjectURL = false;
  if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
    if (typeof Blob !== "undefined" && typeof URL !== "undefined") {
      url = URL.createObjectURL(new Blob([input], { type: mimeType }));
      usingObjectURL = true;
    } else {
      url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);
    }
  } else if (input instanceof Blob) {
    url = URL.createObjectURL(input);
    usingObjectURL = true;
  } else {
    url = _CleanUrl(input);
    url = FileToolsOptions.PreprocessUrl(input);
  }
  const onErrorHandler = (exception) => {
    if (onError) {
      const inputText = url || input.toString();
      onError(`Error while trying to load image: ${inputText.indexOf("http") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + "..."}`, exception);
    }
  };
  if (engine == null ? void 0 : engine._features.forceBitmapOverHTMLImageElement) {
    LoadFile(url, (data) => {
      engine.createImageBitmap(new Blob([data], { type: mimeType }), { premultiplyAlpha: "none", ...imageBitmapOptions }).then((imgBmp) => {
        onLoad(imgBmp);
        if (usingObjectURL) {
          URL.revokeObjectURL(url);
        }
      }).catch((reason) => {
        if (onError) {
          onError("Error while trying to load image: " + input, reason);
        }
      });
    }, void 0, offlineProvider || void 0, true, (request, exception) => {
      onErrorHandler(exception);
    });
    return null;
  }
  const img = new Image();
  SetCorsBehavior(url, img);
  const handlersList = [];
  const loadHandlersList = () => {
    handlersList.forEach((handler) => {
      handler.target.addEventListener(handler.name, handler.handler);
    });
  };
  const unloadHandlersList = () => {
    handlersList.forEach((handler) => {
      handler.target.removeEventListener(handler.name, handler.handler);
    });
    handlersList.length = 0;
  };
  const loadHandler = () => {
    unloadHandlersList();
    onLoad(img);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
  };
  const errorHandler = (err) => {
    unloadHandlersList();
    onErrorHandler(err);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
  };
  const cspHandler = (err) => {
    if (err.blockedURI !== img.src) {
      return;
    }
    unloadHandlersList();
    const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);
    EngineStore.UseFallbackTexture = false;
    onErrorHandler(cspException);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
    img.src = "";
  };
  handlersList.push({ target: img, name: "load", handler: loadHandler });
  handlersList.push({ target: img, name: "error", handler: errorHandler });
  handlersList.push({ target: document, name: "securitypolicyviolation", handler: cspHandler });
  loadHandlersList();
  const fromBlob = url.substring(0, 5) === "blob:";
  const fromData = url.substring(0, 5) === "data:";
  const noOfflineSupport = () => {
    if (fromBlob || fromData || !WebRequest.IsCustomRequestAvailable) {
      img.src = url;
    } else {
      LoadFile(url, (data, _, contentType) => {
        const type = !mimeType && contentType ? contentType : mimeType;
        const blob = new Blob([data], { type });
        const url2 = URL.createObjectURL(blob);
        usingObjectURL = true;
        img.src = url2;
      }, void 0, offlineProvider || void 0, true, (_request, exception) => {
        onErrorHandler(exception);
      });
    }
  };
  const loadFromOfflineSupport = () => {
    if (offlineProvider) {
      offlineProvider.loadImage(url, img);
    }
  };
  if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {
    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
  } else {
    if (url.indexOf("file:") !== -1) {
      const textureName = decodeURIComponent(url.substring(5).toLowerCase());
      if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== "undefined") {
        try {
          let blobURL;
          try {
            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
          } catch (ex) {
            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
          }
          img.src = blobURL;
          usingObjectURL = true;
        } catch (e) {
          img.src = "";
        }
        return img;
      }
    }
    noOfflineSupport();
  }
  return img;
};
var ReadFile = (file, onSuccess, onProgress, useArrayBuffer, onError) => {
  const reader = new FileReader();
  const fileRequest = {
    onCompleteObservable: new Observable(),
    abort: () => reader.abort()
  };
  reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);
  if (onError) {
    reader.onerror = () => {
      onError(new ReadFileError(`Unable to read ${file.name}`, file));
    };
  }
  reader.onload = (e) => {
    onSuccess(e.target["result"]);
  };
  if (onProgress) {
    reader.onprogress = onProgress;
  }
  if (!useArrayBuffer) {
    reader.readAsText(file);
  } else {
    reader.readAsArrayBuffer(file);
  }
  return fileRequest;
};
var LoadFile = (fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {
  if (fileOrUrl.name) {
    return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? (error) => {
      onError(void 0, error);
    } : void 0);
  }
  const url = fileOrUrl;
  if (url.indexOf("file:") !== -1) {
    let fileName = decodeURIComponent(url.substring(5).toLowerCase());
    if (fileName.indexOf("./") === 0) {
      fileName = fileName.substring(2);
    }
    const file = FilesInputStore.FilesToLoad[fileName];
    if (file) {
      return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error) => onError(void 0, new LoadFileError(error.message, error.file)) : void 0);
    }
  }
  const { match, type } = TestBase64DataUrl(url);
  if (match) {
    const fileRequest = {
      onCompleteObservable: new Observable(),
      abort: () => () => {
      }
    };
    try {
      const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);
      onSuccess(data, void 0, type);
    } catch (error) {
      if (onError) {
        onError(void 0, error);
      } else {
        Logger.Error(error.message || "Failed to parse the Data URL");
      }
    }
    TimingTools.SetImmediate(() => {
      fileRequest.onCompleteObservable.notifyObservers(fileRequest);
    });
    return fileRequest;
  }
  return RequestFile(url, (data, request) => {
    onSuccess(data, request == null ? void 0 : request.responseURL, request == null ? void 0 : request.getResponseHeader("content-type"));
  }, onProgress, offlineProvider, useArrayBuffer, onError ? (error) => {
    onError(error.request, new LoadFileError(error.message, error.request));
  } : void 0, onOpened);
};
var RequestFile = (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {
  url = _CleanUrl(url);
  url = FileToolsOptions.PreprocessUrl(url);
  const loadUrl = FileToolsOptions.BaseUrl + url;
  let aborted = false;
  const fileRequest = {
    onCompleteObservable: new Observable(),
    abort: () => aborted = true
  };
  const requestFile = () => {
    let request = new WebRequest();
    let retryHandle = null;
    let onReadyStateChange;
    const unbindEvents = () => {
      if (!request) {
        return;
      }
      if (onProgress) {
        request.removeEventListener("progress", onProgress);
      }
      if (onReadyStateChange) {
        request.removeEventListener("readystatechange", onReadyStateChange);
      }
      request.removeEventListener("loadend", onLoadEnd);
    };
    let onLoadEnd = () => {
      unbindEvents();
      fileRequest.onCompleteObservable.notifyObservers(fileRequest);
      fileRequest.onCompleteObservable.clear();
      onProgress = void 0;
      onReadyStateChange = null;
      onLoadEnd = null;
      onError = void 0;
      onOpened = void 0;
      onSuccess = void 0;
    };
    fileRequest.abort = () => {
      aborted = true;
      if (onLoadEnd) {
        onLoadEnd();
      }
      if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {
        request.abort();
      }
      if (retryHandle !== null) {
        clearTimeout(retryHandle);
        retryHandle = null;
      }
      request = null;
    };
    const handleError = (error) => {
      const message = error.message || "Unknown error";
      if (onError && request) {
        onError(new RequestFileError(message, request));
      } else {
        Logger.Error(message);
      }
    };
    const retryLoop = (retryIndex) => {
      if (!request) {
        return;
      }
      request.open("GET", loadUrl);
      if (onOpened) {
        try {
          onOpened(request);
        } catch (e) {
          handleError(e);
          return;
        }
      }
      if (useArrayBuffer) {
        request.responseType = "arraybuffer";
      }
      if (onProgress) {
        request.addEventListener("progress", onProgress);
      }
      if (onLoadEnd) {
        request.addEventListener("loadend", onLoadEnd);
      }
      onReadyStateChange = () => {
        if (aborted || !request) {
          return;
        }
        if (request.readyState === (XMLHttpRequest.DONE || 4)) {
          if (onReadyStateChange) {
            request.removeEventListener("readystatechange", onReadyStateChange);
          }
          if (request.status >= 200 && request.status < 300 || request.status === 0 && (!IsWindowObjectExist() || IsFileURL())) {
            try {
              if (onSuccess) {
                onSuccess(useArrayBuffer ? request.response : request.responseText, request);
              }
            } catch (e) {
              handleError(e);
            }
            return;
          }
          const retryStrategy = FileToolsOptions.DefaultRetryStrategy;
          if (retryStrategy) {
            const waitTime = retryStrategy(loadUrl, request, retryIndex);
            if (waitTime !== -1) {
              unbindEvents();
              request = new WebRequest();
              retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);
              return;
            }
          }
          const error = new RequestFileError("Error status: " + request.status + " " + request.statusText + " - Unable to load " + loadUrl, request);
          if (onError) {
            onError(error);
          }
        }
      };
      request.addEventListener("readystatechange", onReadyStateChange);
      request.send();
    };
    retryLoop(0);
  };
  if (offlineProvider && offlineProvider.enableSceneOffline) {
    const noOfflineSupport = (request) => {
      if (request && request.status > 400) {
        if (onError) {
          onError(request);
        }
      } else {
        requestFile();
      }
    };
    const loadFromOfflineSupport = () => {
      if (offlineProvider) {
        offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, (data) => {
          if (!aborted && onSuccess) {
            onSuccess(data);
          }
          fileRequest.onCompleteObservable.notifyObservers(fileRequest);
        }, onProgress ? (event) => {
          if (!aborted && onProgress) {
            onProgress(event);
          }
        } : void 0, noOfflineSupport, useArrayBuffer);
      }
    };
    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
  } else {
    requestFile();
  }
  return fileRequest;
};
var IsFileURL = () => {
  return typeof location !== "undefined" && location.protocol === "file:";
};
var IsBase64DataUrl = (uri) => {
  return Base64DataUrlRegEx.test(uri);
};
var TestBase64DataUrl = (uri) => {
  const results = Base64DataUrlRegEx.exec(uri);
  if (results === null || results.length === 0) {
    return { match: false, type: "" };
  } else {
    const type = results[0].replace("data:", "").replace("base64,", "");
    return { match: true, type };
  }
};
function DecodeBase64UrlToBinary(uri) {
  return DecodeBase64ToBinary(uri.split(",")[1]);
}
var DecodeBase64UrlToString = (uri) => {
  return DecodeBase64ToString(uri.split(",")[1]);
};
var initSideEffects = () => {
  ThinEngine._FileToolsLoadImage = LoadImage;
  ThinEngine._FileToolsLoadFile = LoadFile;
  ShaderProcessor._FileToolsLoadFile = LoadFile;
};
initSideEffects();
var FileTools;
var _injectLTSFileTools = (DecodeBase64UrlToBinary2, DecodeBase64UrlToString2, FileToolsOptions2, IsBase64DataUrl2, IsFileURL2, LoadFile2, LoadImage2, ReadFile2, RequestFile2, SetCorsBehavior2) => {
  FileTools = {
    DecodeBase64UrlToBinary: DecodeBase64UrlToBinary2,
    DecodeBase64UrlToString: DecodeBase64UrlToString2,
    DefaultRetryStrategy: FileToolsOptions2.DefaultRetryStrategy,
    BaseUrl: FileToolsOptions2.BaseUrl,
    CorsBehavior: FileToolsOptions2.CorsBehavior,
    PreprocessUrl: FileToolsOptions2.PreprocessUrl,
    IsBase64DataUrl: IsBase64DataUrl2,
    IsFileURL: IsFileURL2,
    LoadFile: LoadFile2,
    LoadImage: LoadImage2,
    ReadFile: ReadFile2,
    RequestFile: RequestFile2,
    SetCorsBehavior: SetCorsBehavior2
  };
  Object.defineProperty(FileTools, "DefaultRetryStrategy", {
    get: function() {
      return FileToolsOptions2.DefaultRetryStrategy;
    },
    set: function(value) {
      FileToolsOptions2.DefaultRetryStrategy = value;
    }
  });
  Object.defineProperty(FileTools, "BaseUrl", {
    get: function() {
      return FileToolsOptions2.BaseUrl;
    },
    set: function(value) {
      FileToolsOptions2.BaseUrl = value;
    }
  });
  Object.defineProperty(FileTools, "PreprocessUrl", {
    get: function() {
      return FileToolsOptions2.PreprocessUrl;
    },
    set: function(value) {
      FileToolsOptions2.PreprocessUrl = value;
    }
  });
  Object.defineProperty(FileTools, "CorsBehavior", {
    get: function() {
      return FileToolsOptions2.CorsBehavior;
    },
    set: function(value) {
      FileToolsOptions2.CorsBehavior = value;
    }
  });
};
_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);

// node_modules/@babylonjs/core/Misc/guid.js
function RandomGUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var GUID = {
  /**
   * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
   * Be aware Math.random() could cause collisions, but:
   * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
   * @returns a pseudo random id
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  RandomId: RandomGUID
};

// node_modules/@babylonjs/core/Misc/instantiationTools.js
var InstantiationTools = class {
  /**
   * Tries to instantiate a new object from a given class name
   * @param className defines the class name to instantiate
   * @returns the new object or null if the system was not able to do the instantiation
   */
  static Instantiate(className2) {
    if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className2]) {
      return this.RegisteredExternalClasses[className2];
    }
    const internalClass = GetClass(className2);
    if (internalClass) {
      return internalClass;
    }
    Logger.Warn(className2 + " not found, you may have missed an import.");
    const arr = className2.split(".");
    let fn = window || this;
    for (let i = 0, len = arr.length; i < len; i++) {
      fn = fn[arr[i]];
    }
    if (typeof fn !== "function") {
      return null;
    }
    return fn;
  }
};
InstantiationTools.RegisteredExternalClasses = {};

// node_modules/@babylonjs/core/Misc/tools.js
var Tools = class _Tools {
  /**
   * Gets or sets the base URL to use to load assets
   */
  static get BaseUrl() {
    return FileToolsOptions.BaseUrl;
  }
  static set BaseUrl(value) {
    FileToolsOptions.BaseUrl = value;
  }
  /**
   * This function checks whether a URL is absolute or not.
   * It will also detect data and blob URLs
   * @param url the url to check
   * @returns is the url absolute or relative
   */
  static IsAbsoluteUrl(url) {
    if (url.indexOf("//") === 0) {
      return true;
    }
    if (url.indexOf("://") === -1) {
      return false;
    }
    if (url.indexOf(".") === -1) {
      return false;
    }
    if (url.indexOf("/") === -1) {
      return false;
    }
    if (url.indexOf(":") > url.indexOf("/")) {
      return false;
    }
    if (url.indexOf("://") < url.indexOf(".")) {
      return true;
    }
    if (url.indexOf("data:") === 0 || url.indexOf("blob:") === 0) {
      return true;
    }
    return false;
  }
  /**
   * Sets the base URL to use to load scripts
   */
  static set ScriptBaseUrl(value) {
    FileToolsOptions.ScriptBaseUrl = value;
  }
  static get ScriptBaseUrl() {
    return FileToolsOptions.ScriptBaseUrl;
  }
  /**
   * Sets a preprocessing function to run on a source URL before importing it
   * Note that this function will execute AFTER the base URL is appended to the URL
   */
  static set ScriptPreprocessUrl(func) {
    FileToolsOptions.ScriptPreprocessUrl = func;
  }
  static get ScriptPreprocessUrl() {
    return FileToolsOptions.ScriptPreprocessUrl;
  }
  /**
   * Gets or sets the retry strategy to apply when an error happens while loading an asset
   */
  static get DefaultRetryStrategy() {
    return FileToolsOptions.DefaultRetryStrategy;
  }
  static set DefaultRetryStrategy(strategy) {
    FileToolsOptions.DefaultRetryStrategy = strategy;
  }
  /**
   * Default behavior for cors in the application.
   * It can be a string if the expected behavior is identical in the entire app.
   * Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
   */
  static get CorsBehavior() {
    return FileToolsOptions.CorsBehavior;
  }
  static set CorsBehavior(value) {
    FileToolsOptions.CorsBehavior = value;
  }
  /**
   * Gets or sets a global variable indicating if fallback texture must be used when a texture cannot be loaded
   * @ignorenaming
   */
  static get UseFallbackTexture() {
    return EngineStore.UseFallbackTexture;
  }
  static set UseFallbackTexture(value) {
    EngineStore.UseFallbackTexture = value;
  }
  /**
   * Use this object to register external classes like custom textures or material
   * to allow the loaders to instantiate them
   */
  static get RegisteredExternalClasses() {
    return InstantiationTools.RegisteredExternalClasses;
  }
  static set RegisteredExternalClasses(classes) {
    InstantiationTools.RegisteredExternalClasses = classes;
  }
  /**
   * Texture content used if a texture cannot loaded
   * @ignorenaming
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static get fallbackTexture() {
    return EngineStore.FallbackTexture;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static set fallbackTexture(value) {
    EngineStore.FallbackTexture = value;
  }
  /**
   * Read the content of a byte array at a specified coordinates (taking in account wrapping)
   * @param u defines the coordinate on X axis
   * @param v defines the coordinate on Y axis
   * @param width defines the width of the source data
   * @param height defines the height of the source data
   * @param pixels defines the source byte array
   * @param color defines the output color
   */
  static FetchToRef(u, v, width, height, pixels, color) {
    const wrappedU = Math.abs(u) * width % width | 0;
    const wrappedV = Math.abs(v) * height % height | 0;
    const position = (wrappedU + wrappedV * width) * 4;
    color.r = pixels[position] / 255;
    color.g = pixels[position + 1] / 255;
    color.b = pixels[position + 2] / 255;
    color.a = pixels[position + 3] / 255;
  }
  /**
   * Interpolates between a and b via alpha
   * @param a The lower value (returned when alpha = 0)
   * @param b The upper value (returned when alpha = 1)
   * @param alpha The interpolation-factor
   * @returns The mixed value
   */
  static Mix(a, b, alpha) {
    return a * (1 - alpha) + b * alpha;
  }
  /**
   * Tries to instantiate a new object from a given class name
   * @param className defines the class name to instantiate
   * @returns the new object or null if the system was not able to do the instantiation
   */
  static Instantiate(className2) {
    return InstantiationTools.Instantiate(className2);
  }
  /**
   * Polyfill for setImmediate
   * @param action defines the action to execute after the current execution block
   */
  static SetImmediate(action) {
    TimingTools.SetImmediate(action);
  }
  /**
   * Function indicating if a number is an exponent of 2
   * @param value defines the value to test
   * @returns true if the value is an exponent of 2
   */
  static IsExponentOfTwo(value) {
    let count = 1;
    do {
      count *= 2;
    } while (count < value);
    return count === value;
  }
  /**
   * Returns the nearest 32-bit single precision float representation of a Number
   * @param value A Number.  If the parameter is of a different type, it will get converted
   * to a number or to NaN if it cannot be converted
   * @returns number
   */
  static FloatRound(value) {
    return Math.fround(value);
  }
  /**
   * Extracts the filename from a path
   * @param path defines the path to use
   * @returns the filename
   */
  static GetFilename(path) {
    const index = path.lastIndexOf("/");
    if (index < 0) {
      return path;
    }
    return path.substring(index + 1);
  }
  /**
   * Extracts the "folder" part of a path (everything before the filename).
   * @param uri The URI to extract the info from
   * @param returnUnchangedIfNoSlash Do not touch the URI if no slashes are present
   * @returns The "folder" part of the path
   */
  static GetFolderPath(uri, returnUnchangedIfNoSlash = false) {
    const index = uri.lastIndexOf("/");
    if (index < 0) {
      if (returnUnchangedIfNoSlash) {
        return uri;
      }
      return "";
    }
    return uri.substring(0, index + 1);
  }
  /**
   * Convert an angle in radians to degrees
   * @param angle defines the angle to convert
   * @returns the angle in degrees
   */
  static ToDegrees(angle) {
    return angle * 180 / Math.PI;
  }
  /**
   * Convert an angle in degrees to radians
   * @param angle defines the angle to convert
   * @returns the angle in radians
   */
  static ToRadians(angle) {
    return angle * Math.PI / 180;
  }
  /**
   * Smooth angle changes (kind of low-pass filter), in particular for device orientation "shaking"
   * Use trigonometric functions to avoid discontinuity (0/360, -180/180)
   * @param previousAngle defines last angle value, in degrees
   * @param newAngle defines new angle value, in degrees
   * @param smoothFactor defines smoothing sensitivity; min 0: no smoothing, max 1: new data ignored
   * @returns the angle in degrees
   */
  static SmoothAngleChange(previousAngle, newAngle, smoothFactor = 0.9) {
    const previousAngleRad = this.ToRadians(previousAngle);
    const newAngleRad = this.ToRadians(newAngle);
    return this.ToDegrees(Math.atan2((1 - smoothFactor) * Math.sin(newAngleRad) + smoothFactor * Math.sin(previousAngleRad), (1 - smoothFactor) * Math.cos(newAngleRad) + smoothFactor * Math.cos(previousAngleRad)));
  }
  /**
   * Returns an array if obj is not an array
   * @param obj defines the object to evaluate as an array
   * @param allowsNullUndefined defines a boolean indicating if obj is allowed to be null or undefined
   * @returns either obj directly if obj is an array or a new array containing obj
   */
  static MakeArray(obj, allowsNullUndefined) {
    if (allowsNullUndefined !== true && (obj === void 0 || obj == null)) {
      return null;
    }
    return Array.isArray(obj) ? obj : [obj];
  }
  /**
   * Gets the pointer prefix to use
   * @param engine defines the engine we are finding the prefix for
   * @returns "pointer" if touch is enabled. Else returns "mouse"
   */
  static GetPointerPrefix(engine) {
    let eventPrefix = "pointer";
    if (IsWindowObjectExist() && !window.PointerEvent) {
      eventPrefix = "mouse";
    }
    if (engine._badDesktopOS && !engine._badOS && // And not ipad pros who claim to be macs...
    !(document && "ontouchend" in document)) {
      eventPrefix = "mouse";
    }
    return eventPrefix;
  }
  /**
   * Sets the cors behavior on a dom element. This will add the required Tools.CorsBehavior to the element.
   * @param url define the url we are trying
   * @param element define the dom element where to configure the cors policy
   * @param element.crossOrigin
   */
  static SetCorsBehavior(url, element) {
    SetCorsBehavior(url, element);
  }
  /**
   * Sets the referrerPolicy behavior on a dom element.
   * @param referrerPolicy define the referrer policy to use
   * @param element define the dom element where to configure the referrer policy
   * @param element.referrerPolicy
   */
  static SetReferrerPolicyBehavior(referrerPolicy, element) {
    element.referrerPolicy = referrerPolicy;
  }
  // External files
  /**
   * Removes unwanted characters from an url
   * @param url defines the url to clean
   * @returns the cleaned url
   */
  static CleanUrl(url) {
    url = url.replace(/#/gm, "%23");
    return url;
  }
  /**
   * Gets or sets a function used to pre-process url before using them to load assets
   */
  static get PreprocessUrl() {
    return FileToolsOptions.PreprocessUrl;
  }
  static set PreprocessUrl(processor) {
    FileToolsOptions.PreprocessUrl = processor;
  }
  /**
   * Loads an image as an HTMLImageElement.
   * @param input url string, ArrayBuffer, or Blob to load
   * @param onLoad callback called when the image successfully loads
   * @param onError callback called when the image fails to load
   * @param offlineProvider offline provider for caching
   * @param mimeType optional mime type
   * @param imageBitmapOptions optional the options to use when creating an ImageBitmap
   * @returns the HTMLImageElement of the loaded image
   */
  static LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
    return LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions);
  }
  /**
   * Loads a file from a url
   * @param url url string, ArrayBuffer, or Blob to load
   * @param onSuccess callback called when the file successfully loads
   * @param onProgress callback called while file is loading (if the server supports this mode)
   * @param offlineProvider defines the offline provider for caching
   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
   * @param onError callback called when the file fails to load
   * @returns a file request object
   */
  static LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    return LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
  }
  /**
   * Loads a file from a url
   * @param url the file url to load
   * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer
   * @returns a promise containing an ArrayBuffer corresponding to the loaded file
   */
  static LoadFileAsync(url, useArrayBuffer = true) {
    return new Promise((resolve, reject) => {
      LoadFile(url, (data) => {
        resolve(data);
      }, void 0, void 0, useArrayBuffer, (request, exception) => {
        reject(exception);
      });
    });
  }
  /**
   * Get a script URL including preprocessing
   * @param scriptUrl the script Url to process
   * @param forceAbsoluteUrl force the script to be an absolute url (adding the current base url if necessary)
   * @returns a modified URL to use
   */
  static GetBabylonScriptURL(scriptUrl, forceAbsoluteUrl) {
    if (!scriptUrl) {
      return "";
    }
    if (_Tools.ScriptBaseUrl && scriptUrl.startsWith(_Tools._DefaultCdnUrl)) {
      const baseUrl = _Tools.ScriptBaseUrl[_Tools.ScriptBaseUrl.length - 1] === "/" ? _Tools.ScriptBaseUrl.substring(0, _Tools.ScriptBaseUrl.length - 1) : _Tools.ScriptBaseUrl;
      scriptUrl = scriptUrl.replace(_Tools._DefaultCdnUrl, baseUrl);
    }
    scriptUrl = _Tools.ScriptPreprocessUrl(scriptUrl);
    if (forceAbsoluteUrl) {
      scriptUrl = _Tools.GetAbsoluteUrl(scriptUrl);
    }
    return scriptUrl;
  }
  /**
   * This function is used internally by babylon components to load a script (identified by an url). When the url returns, the
   * content of this file is added into a new script element, attached to the DOM (body element)
   * @param scriptUrl defines the url of the script to load
   * @param onSuccess defines the callback called when the script is loaded
   * @param onError defines the callback to call if an error occurs
   * @param scriptId defines the id of the script element
   */
  static LoadBabylonScript(scriptUrl, onSuccess, onError, scriptId) {
    scriptUrl = _Tools.GetBabylonScriptURL(scriptUrl);
    _Tools.LoadScript(scriptUrl, onSuccess, onError);
  }
  /**
   * Load an asynchronous script (identified by an url). When the url returns, the
   * content of this file is added into a new script element, attached to the DOM (body element)
   * @param scriptUrl defines the url of the script to laod
   * @returns a promise request object
   */
  static LoadBabylonScriptAsync(scriptUrl) {
    scriptUrl = _Tools.GetBabylonScriptURL(scriptUrl);
    return _Tools.LoadScriptAsync(scriptUrl);
  }
  /**
   * This function is used internally by babylon components to load a script (identified by an url). When the url returns, the
   * content of this file is added into a new script element, attached to the DOM (body element)
   * @param scriptUrl defines the url of the script to load
   * @param onSuccess defines the callback called when the script is loaded
   * @param onError defines the callback to call if an error occurs
   * @param scriptId defines the id of the script element
   */
  static LoadScript(scriptUrl, onSuccess, onError, scriptId) {
    if (typeof importScripts === "function") {
      try {
        importScripts(scriptUrl);
        onSuccess();
      } catch (e) {
        onError == null ? void 0 : onError(`Unable to load script '${scriptUrl}' in worker`, e);
      }
      return;
    } else if (!IsWindowObjectExist()) {
      onError == null ? void 0 : onError(`Cannot load script '${scriptUrl}' outside of a window or a worker`);
      return;
    }
    const head = document.getElementsByTagName("head")[0];
    const script = document.createElement("script");
    script.setAttribute("type", "text/javascript");
    script.setAttribute("src", scriptUrl);
    if (scriptId) {
      script.id = scriptId;
    }
    script.onload = () => {
      if (onSuccess) {
        onSuccess();
      }
    };
    script.onerror = (e) => {
      if (onError) {
        onError(`Unable to load script '${scriptUrl}'`, e);
      }
    };
    head.appendChild(script);
  }
  /**
   * Load an asynchronous script (identified by an url). When the url returns, the
   * content of this file is added into a new script element, attached to the DOM (body element)
   * @param scriptUrl defines the url of the script to load
   * @param scriptId defines the id of the script element
   * @returns a promise request object
   */
  static LoadScriptAsync(scriptUrl, scriptId) {
    return new Promise((resolve, reject) => {
      this.LoadScript(scriptUrl, () => {
        resolve();
      }, (message, exception) => {
        reject(exception || new Error(message));
      }, scriptId);
    });
  }
  /**
   * Loads a file from a blob
   * @param fileToLoad defines the blob to use
   * @param callback defines the callback to call when data is loaded
   * @param progressCallback defines the callback to call during loading process
   * @returns a file request object
   */
  static ReadFileAsDataURL(fileToLoad, callback, progressCallback) {
    const reader = new FileReader();
    const request = {
      onCompleteObservable: new Observable(),
      abort: () => reader.abort()
    };
    reader.onloadend = () => {
      request.onCompleteObservable.notifyObservers(request);
    };
    reader.onload = (e) => {
      callback(e.target["result"]);
    };
    reader.onprogress = progressCallback;
    reader.readAsDataURL(fileToLoad);
    return request;
  }
  /**
   * Reads a file from a File object
   * @param file defines the file to load
   * @param onSuccess defines the callback to call when data is loaded
   * @param onProgress defines the callback to call during loading process
   * @param useArrayBuffer defines a boolean indicating that data must be returned as an ArrayBuffer
   * @param onError defines the callback to call when an error occurs
   * @returns a file request object
   */
  static ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError) {
    return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
  }
  /**
   * Creates a data url from a given string content
   * @param content defines the content to convert
   * @returns the new data url link
   */
  static FileAsURL(content) {
    const fileBlob = new Blob([content]);
    const url = window.URL;
    const link = url.createObjectURL(fileBlob);
    return link;
  }
  /**
   * Format the given number to a specific decimal format
   * @param value defines the number to format
   * @param decimals defines the number of decimals to use
   * @returns the formatted string
   */
  static Format(value, decimals = 2) {
    return value.toFixed(decimals);
  }
  /**
   * Tries to copy an object by duplicating every property
   * @param source defines the source object
   * @param destination defines the target object
   * @param doNotCopyList defines a list of properties to avoid
   * @param mustCopyList defines a list of properties to copy (even if they start with _)
   */
  static DeepCopy(source, destination, doNotCopyList, mustCopyList) {
    DeepCopier.DeepCopy(source, destination, doNotCopyList, mustCopyList);
  }
  /**
   * Gets a boolean indicating if the given object has no own property
   * @param obj defines the object to test
   * @returns true if object has no own property
   */
  static IsEmpty(obj) {
    for (const i in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, i)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Function used to register events at window level
   * @param windowElement defines the Window object to use
   * @param events defines the events to register
   */
  static RegisterTopRootEvents(windowElement, events) {
    for (let index = 0; index < events.length; index++) {
      const event = events[index];
      windowElement.addEventListener(event.name, event.handler, false);
      try {
        if (window.parent) {
          window.parent.addEventListener(event.name, event.handler, false);
        }
      } catch (e) {
      }
    }
  }
  /**
   * Function used to unregister events from window level
   * @param windowElement defines the Window object to use
   * @param events defines the events to unregister
   */
  static UnregisterTopRootEvents(windowElement, events) {
    for (let index = 0; index < events.length; index++) {
      const event = events[index];
      windowElement.removeEventListener(event.name, event.handler);
      try {
        if (windowElement.parent) {
          windowElement.parent.removeEventListener(event.name, event.handler);
        }
      } catch (e) {
      }
    }
  }
  /**
   * Dumps the current bound framebuffer
   * @param width defines the rendering width
   * @param height defines the rendering height
   * @param engine defines the hosting engine
   * @param successCallback defines the callback triggered once the data are available
   * @param mimeType defines the mime type of the result
   * @param fileName defines the filename to download. If present, the result will automatically be downloaded
   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
   * @returns a void promise
   */
  static async DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName, quality) {
    throw _WarnImport("DumpTools");
  }
  /**
   * Dumps an array buffer
   * @param width defines the rendering width
   * @param height defines the rendering height
   * @param data the data array
   * @param successCallback defines the callback triggered once the data are available
   * @param mimeType defines the mime type of the result
   * @param fileName defines the filename to download. If present, the result will automatically be downloaded
   * @param invertY true to invert the picture in the Y dimension
   * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string
   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
   */
  static DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    throw _WarnImport("DumpTools");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Dumps an array buffer
   * @param width defines the rendering width
   * @param height defines the rendering height
   * @param data the data array
   * @param mimeType defines the mime type of the result
   * @param fileName defines the filename to download. If present, the result will automatically be downloaded
   * @param invertY true to invert the picture in the Y dimension
   * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string
   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
   * @returns a promise that resolve to the final data
   */
  static DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
    throw _WarnImport("DumpTools");
  }
  static _IsOffScreenCanvas(canvas) {
    return canvas.convertToBlob !== void 0;
  }
  /**
   * Converts the canvas data to blob.
   * This acts as a polyfill for browsers not supporting the to blob function.
   * @param canvas Defines the canvas to extract the data from (can be an offscreen canvas)
   * @param successCallback Defines the callback triggered once the data are available
   * @param mimeType Defines the mime type of the result
   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
   */
  static ToBlob(canvas, successCallback, mimeType = "image/png", quality) {
    if (!_Tools._IsOffScreenCanvas(canvas) && !canvas.toBlob) {
      canvas.toBlob = function(callback, type, quality2) {
        setTimeout(() => {
          const binStr = atob(this.toDataURL(type, quality2).split(",")[1]), len = binStr.length, arr = new Uint8Array(len);
          for (let i = 0; i < len; i++) {
            arr[i] = binStr.charCodeAt(i);
          }
          callback(new Blob([arr]));
        });
      };
    }
    if (_Tools._IsOffScreenCanvas(canvas)) {
      canvas.convertToBlob({
        type: mimeType,
        quality
      }).then((blob) => successCallback(blob));
    } else {
      canvas.toBlob(function(blob) {
        successCallback(blob);
      }, mimeType, quality);
    }
  }
  /**
   * Download a Blob object
   * @param blob the Blob object
   * @param fileName the file name to download
   */
  static DownloadBlob(blob, fileName) {
    if ("download" in document.createElement("a")) {
      if (!fileName) {
        const date = /* @__PURE__ */ new Date();
        const stringDate = (date.getFullYear() + "-" + (date.getMonth() + 1)).slice(2) + "-" + date.getDate() + "_" + date.getHours() + "-" + ("0" + date.getMinutes()).slice(-2);
        fileName = "screenshot_" + stringDate + ".png";
      }
      _Tools.Download(blob, fileName);
    } else {
      if (blob && typeof URL !== "undefined") {
        const url = URL.createObjectURL(blob);
        const newWindow = window.open("");
        if (!newWindow) {
          return;
        }
        const img = newWindow.document.createElement("img");
        img.onload = function() {
          URL.revokeObjectURL(url);
        };
        img.src = url;
        newWindow.document.body.appendChild(img);
      }
    }
  }
  /**
   * Encodes the canvas data to base 64, or automatically downloads the result if `fileName` is defined.
   * @param canvas The canvas to get the data from, which can be an offscreen canvas.
   * @param successCallback The callback which is triggered once the data is available. If `fileName` is defined, the callback will be invoked after the download occurs, and the `data` argument will be an empty string.
   * @param mimeType The mime type of the result.
   * @param fileName The name of the file to download. If defined, the result will automatically be downloaded. If not defined, and `successCallback` is also not defined, the result will automatically be downloaded with an auto-generated file name.
   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
   */
  static EncodeScreenshotCanvasData(canvas, successCallback, mimeType = "image/png", fileName, quality) {
    if (typeof fileName === "string" || !successCallback) {
      this.ToBlob(canvas, function(blob) {
        if (blob) {
          _Tools.DownloadBlob(blob, fileName);
        }
        if (successCallback) {
          successCallback("");
        }
      }, mimeType, quality);
    } else if (successCallback) {
      if (_Tools._IsOffScreenCanvas(canvas)) {
        canvas.convertToBlob({
          type: mimeType,
          quality
        }).then((blob) => {
          const reader = new FileReader();
          reader.readAsDataURL(blob);
          reader.onloadend = () => {
            const base64data = reader.result;
            successCallback(base64data);
          };
        });
        return;
      }
      const base64Image = canvas.toDataURL(mimeType, quality);
      successCallback(base64Image);
    }
  }
  /**
   * Downloads a blob in the browser
   * @param blob defines the blob to download
   * @param fileName defines the name of the downloaded file
   */
  static Download(blob, fileName) {
    if (typeof URL === "undefined") {
      return;
    }
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    a.addEventListener("click", () => {
      if (a.parentElement) {
        a.parentElement.removeChild(a);
      }
    });
    a.click();
    window.URL.revokeObjectURL(url);
  }
  /**
   * Will return the right value of the noPreventDefault variable
   * Needed to keep backwards compatibility to the old API.
   *
   * @param args arguments passed to the attachControl function
   * @returns the correct value for noPreventDefault
   */
  static BackCompatCameraNoPreventDefault(args) {
    if (typeof args[0] === "boolean") {
      return args[0];
    } else if (typeof args[1] === "boolean") {
      return args[1];
    }
    return false;
  }
  /**
   * Captures a screenshot of the current rendering
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
   * @param engine defines the rendering engine
   * @param camera defines the source camera
   * @param size This parameter can be set to a single number or to an object with the
   * following (optional) properties: precision, width, height. If a single number is passed,
   * it will be used for both width and height. If an object is passed, the screenshot size
   * will be derived from the parameters. The precision property is a multiplier allowing
   * rendering at a higher or lower resolution
   * @param successCallback defines the callback receives a single parameter which contains the
   * screenshot as a string of base64-encoded characters. This string can be assigned to the
   * src parameter of an <img> to display it
   * @param mimeType defines the MIME type of the screenshot image (default: image/png).
   * Check your browser for supported MIME types
   * @param forceDownload force the system to download the image even if a successCallback is provided
   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static CreateScreenshot(engine, camera, size, successCallback, mimeType = "image/png", forceDownload = false, quality) {
    throw _WarnImport("ScreenshotTools");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Captures a screenshot of the current rendering
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
   * @param engine defines the rendering engine
   * @param camera defines the source camera
   * @param size This parameter can be set to a single number or to an object with the
   * following (optional) properties: precision, width, height. If a single number is passed,
   * it will be used for both width and height. If an object is passed, the screenshot size
   * will be derived from the parameters. The precision property is a multiplier allowing
   * rendering at a higher or lower resolution
   * @param mimeType defines the MIME type of the screenshot image (default: image/png).
   * Check your browser for supported MIME types
   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
   * @returns screenshot as a string of base64-encoded characters. This string can be assigned
   * to the src parameter of an <img> to display it
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static CreateScreenshotAsync(engine, camera, size, mimeType = "image/png", quality) {
    throw _WarnImport("ScreenshotTools");
  }
  /**
   * Generates an image screenshot from the specified camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
   * @param engine The engine to use for rendering
   * @param camera The camera to use for rendering
   * @param size This parameter can be set to a single number or to an object with the
   * following (optional) properties: precision, width, height. If a single number is passed,
   * it will be used for both width and height. If an object is passed, the screenshot size
   * will be derived from the parameters. The precision property is a multiplier allowing
   * rendering at a higher or lower resolution
   * @param successCallback The callback receives a single parameter which contains the
   * screenshot as a string of base64-encoded characters. This string can be assigned to the
   * src parameter of an <img> to display it
   * @param mimeType The MIME type of the screenshot image (default: image/png).
   * Check your browser for supported MIME types
   * @param samples Texture samples (default: 1)
   * @param antialiasing Whether antialiasing should be turned on or not (default: false)
   * @param fileName A name for for the downloaded file.
   * @param renderSprites Whether the sprites should be rendered or not (default: false)
   * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)
   * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)
   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality) {
    throw _WarnImport("ScreenshotTools");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Generates an image screenshot from the specified camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToPNG
   * @param engine The engine to use for rendering
   * @param camera The camera to use for rendering
   * @param size This parameter can be set to a single number or to an object with the
   * following (optional) properties: precision, width, height. If a single number is passed,
   * it will be used for both width and height. If an object is passed, the screenshot size
   * will be derived from the parameters. The precision property is a multiplier allowing
   * rendering at a higher or lower resolution
   * @param mimeType The MIME type of the screenshot image (default: image/png).
   * Check your browser for supported MIME types
   * @param samples Texture samples (default: 1)
   * @param antialiasing Whether antialiasing should be turned on or not (default: false)
   * @param fileName A name for for the downloaded file.
   * @returns screenshot as a string of base64-encoded characters. This string can be assigned
   * @param renderSprites Whether the sprites should be rendered or not (default: false)
   * @param enableStencilBuffer Whether the stencil buffer should be enabled or not (default: false)
   * @param useLayerMask if the camera's layer mask should be used to filter what should be rendered (default: true)
   * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.
   * to the src parameter of an <img> to display it
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality) {
    throw _WarnImport("ScreenshotTools");
  }
  /**
   * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
   * Be aware Math.random() could cause collisions, but:
   * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
   * @returns a pseudo random id
   */
  static RandomId() {
    return RandomGUID();
  }
  /**
   * Test if the given uri is a base64 string
   * @deprecated Please use FileTools.IsBase64DataUrl instead.
   * @param uri The uri to test
   * @returns True if the uri is a base64 string or false otherwise
   */
  static IsBase64(uri) {
    return IsBase64DataUrl(uri);
  }
  /**
   * Decode the given base64 uri.
   * @deprecated Please use FileTools.DecodeBase64UrlToBinary instead.
   * @param uri The uri to decode
   * @returns The decoded base64 data.
   */
  static DecodeBase64(uri) {
    return DecodeBase64UrlToBinary(uri);
  }
  /**
   * Gets a value indicating the number of loading errors
   * @ignorenaming
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static get errorsCount() {
    return Logger.errorsCount;
  }
  /**
   * Log a message to the console
   * @param message defines the message to log
   */
  static Log(message) {
    Logger.Log(message);
  }
  /**
   * Write a warning message to the console
   * @param message defines the message to log
   */
  static Warn(message) {
    Logger.Warn(message);
  }
  /**
   * Write an error message to the console
   * @param message defines the message to log
   */
  static Error(message) {
    Logger.Error(message);
  }
  /**
   * Gets current log cache (list of logs)
   */
  static get LogCache() {
    return Logger.LogCache;
  }
  /**
   * Clears the log cache
   */
  static ClearLogCache() {
    Logger.ClearLogCache();
  }
  /**
   * Sets the current log level (MessageLogLevel / WarningLogLevel / ErrorLogLevel)
   */
  static set LogLevels(level) {
    Logger.LogLevels = level;
  }
  /**
   * Sets the current performance log level
   */
  static set PerformanceLogLevel(level) {
    if ((level & _Tools.PerformanceUserMarkLogLevel) === _Tools.PerformanceUserMarkLogLevel) {
      _Tools.StartPerformanceCounter = _Tools._StartUserMark;
      _Tools.EndPerformanceCounter = _Tools._EndUserMark;
      return;
    }
    if ((level & _Tools.PerformanceConsoleLogLevel) === _Tools.PerformanceConsoleLogLevel) {
      _Tools.StartPerformanceCounter = _Tools._StartPerformanceConsole;
      _Tools.EndPerformanceCounter = _Tools._EndPerformanceConsole;
      return;
    }
    _Tools.StartPerformanceCounter = _Tools._StartPerformanceCounterDisabled;
    _Tools.EndPerformanceCounter = _Tools._EndPerformanceCounterDisabled;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static _StartPerformanceCounterDisabled(counterName, condition) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  static _EndPerformanceCounterDisabled(counterName, condition) {
  }
  static _StartUserMark(counterName, condition = true) {
    if (!_Tools._Performance) {
      if (!IsWindowObjectExist()) {
        return;
      }
      _Tools._Performance = window.performance;
    }
    if (!condition || !_Tools._Performance.mark) {
      return;
    }
    _Tools._Performance.mark(counterName + "-Begin");
  }
  static _EndUserMark(counterName, condition = true) {
    if (!condition || !_Tools._Performance.mark) {
      return;
    }
    _Tools._Performance.mark(counterName + "-End");
    _Tools._Performance.measure(counterName, counterName + "-Begin", counterName + "-End");
  }
  static _StartPerformanceConsole(counterName, condition = true) {
    if (!condition) {
      return;
    }
    _Tools._StartUserMark(counterName, condition);
    if (console.time) {
      console.time(counterName);
    }
  }
  static _EndPerformanceConsole(counterName, condition = true) {
    if (!condition) {
      return;
    }
    _Tools._EndUserMark(counterName, condition);
    console.timeEnd(counterName);
  }
  /**
   * Gets either window.performance.now() if supported or Date.now() else
   */
  static get Now() {
    return PrecisionDate.Now;
  }
  /**
   * This method will return the name of the class used to create the instance of the given object.
   * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.
   * @param object the object to get the class name from
   * @param isType defines if the object is actually a type
   * @returns the name of the class, will be "object" for a custom data type not using the @className decorator
   */
  static GetClassName(object, isType = false) {
    let name = null;
    if (!isType && object.getClassName) {
      name = object.getClassName();
    } else {
      if (object instanceof Object) {
        const classObj = isType ? object : Object.getPrototypeOf(object);
        name = classObj.constructor["__bjsclassName__"];
      }
      if (!name) {
        name = typeof object;
      }
    }
    return name;
  }
  /**
   * Gets the first element of an array satisfying a given predicate
   * @param array defines the array to browse
   * @param predicate defines the predicate to use
   * @returns null if not found or the element
   */
  static First(array, predicate) {
    for (const el of array) {
      if (predicate(el)) {
        return el;
      }
    }
    return null;
  }
  /**
   * This method will return the name of the full name of the class, including its owning module (if any).
   * It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).
   * @param object the object to get the class name from
   * @param isType defines if the object is actually a type
   * @returns a string that can have two forms: "moduleName.className" if module was specified when the class' Name was registered or "className" if there was not module specified.
   * @ignorenaming
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static getFullClassName(object, isType = false) {
    let className2 = null;
    let moduleName = null;
    if (!isType && object.getClassName) {
      className2 = object.getClassName();
    } else {
      if (object instanceof Object) {
        const classObj = isType ? object : Object.getPrototypeOf(object);
        className2 = classObj.constructor["__bjsclassName__"];
        moduleName = classObj.constructor["__bjsmoduleName__"];
      }
      if (!className2) {
        className2 = typeof object;
      }
    }
    if (!className2) {
      return null;
    }
    return (moduleName != null ? moduleName + "." : "") + className2;
  }
  /**
   * Returns a promise that resolves after the given amount of time.
   * @param delay Number of milliseconds to delay
   * @returns Promise that resolves after the given amount of time
   */
  static DelayAsync(delay) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, delay);
    });
  }
  /**
   * Utility function to detect if the current user agent is Safari
   * @returns whether or not the current user agent is safari
   */
  static IsSafari() {
    if (!IsNavigatorAvailable()) {
      return false;
    }
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  }
};
Tools.UseCustomRequestHeaders = false;
Tools.CustomRequestHeaders = WebRequest.CustomRequestHeaders;
Tools.GetDOMTextContent = GetDOMTextContent;
Tools._DefaultCdnUrl = "https://cdn.babylonjs.com";
Tools.GetAbsoluteUrl = typeof document === "object" ? (url) => {
  const a = document.createElement("a");
  a.href = url;
  return a.href;
} : typeof URL === "function" && typeof location === "object" ? (url) => new URL(url, location.origin).href : () => {
  throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.");
};
Tools.NoneLogLevel = Logger.NoneLogLevel;
Tools.MessageLogLevel = Logger.MessageLogLevel;
Tools.WarningLogLevel = Logger.WarningLogLevel;
Tools.ErrorLogLevel = Logger.ErrorLogLevel;
Tools.AllLogLevel = Logger.AllLogLevel;
Tools.IsWindowObjectExist = IsWindowObjectExist;
Tools.PerformanceNoneLogLevel = 0;
Tools.PerformanceUserMarkLogLevel = 1;
Tools.PerformanceConsoleLogLevel = 2;
Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;
Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;
function className(name, module) {
  return (target) => {
    target["__bjsclassName__"] = name;
    target["__bjsmoduleName__"] = module != null ? module : null;
  };
}
var AsyncLoop = class _AsyncLoop {
  /**
   * Constructor.
   * @param iterations the number of iterations.
   * @param func the function to run each iteration
   * @param successCallback the callback that will be called upon successful execution
   * @param offset starting offset.
   */
  constructor(iterations, func, successCallback, offset = 0) {
    this.iterations = iterations;
    this.index = offset - 1;
    this._done = false;
    this._fn = func;
    this._successCallback = successCallback;
  }
  /**
   * Execute the next iteration. Must be called after the last iteration was finished.
   */
  executeNext() {
    if (!this._done) {
      if (this.index + 1 < this.iterations) {
        ++this.index;
        this._fn(this);
      } else {
        this.breakLoop();
      }
    }
  }
  /**
   * Break the loop and run the success callback.
   */
  breakLoop() {
    this._done = true;
    this._successCallback();
  }
  /**
   * Create and run an async loop.
   * @param iterations the number of iterations.
   * @param fn the function to run each iteration
   * @param successCallback the callback that will be called upon successful execution
   * @param offset starting offset.
   * @returns the created async loop object
   */
  static Run(iterations, fn, successCallback, offset = 0) {
    const loop = new _AsyncLoop(iterations, fn, successCallback, offset);
    loop.executeNext();
    return loop;
  }
  /**
   * A for-loop that will run a given number of iterations synchronous and the rest async.
   * @param iterations total number of iterations
   * @param syncedIterations number of synchronous iterations in each async iteration.
   * @param fn the function to call each iteration.
   * @param callback a success call back that will be called when iterating stops.
   * @param breakFunction a break condition (optional)
   * @param timeout timeout settings for the setTimeout function. default - 0.
   * @returns the created async loop object
   */
  static SyncAsyncForLoop(iterations, syncedIterations, fn, callback, breakFunction, timeout = 0) {
    return _AsyncLoop.Run(Math.ceil(iterations / syncedIterations), (loop) => {
      if (breakFunction && breakFunction()) {
        loop.breakLoop();
      } else {
        setTimeout(() => {
          for (let i = 0; i < syncedIterations; ++i) {
            const iteration = loop.index * syncedIterations + i;
            if (iteration >= iterations) {
              break;
            }
            fn(iteration);
            if (breakFunction && breakFunction()) {
              loop.breakLoop();
              break;
            }
          }
          loop.executeNext();
        }, timeout);
      }
    }, callback);
  }
};
EngineStore.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";

// node_modules/@babylonjs/core/Engines/Extensions/engine.uniformBuffer.js
ThinEngine.prototype.createUniformBuffer = function(elements, _label) {
  const ubo = this._gl.createBuffer();
  if (!ubo) {
    throw new Error("Unable to create uniform buffer");
  }
  const result = new WebGLDataBuffer(ubo);
  this.bindUniformBuffer(result);
  if (elements instanceof Float32Array) {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.STATIC_DRAW);
  } else {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.STATIC_DRAW);
  }
  this.bindUniformBuffer(null);
  result.references = 1;
  return result;
};
ThinEngine.prototype.createDynamicUniformBuffer = function(elements, _label) {
  const ubo = this._gl.createBuffer();
  if (!ubo) {
    throw new Error("Unable to create dynamic uniform buffer");
  }
  const result = new WebGLDataBuffer(ubo);
  this.bindUniformBuffer(result);
  if (elements instanceof Float32Array) {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.DYNAMIC_DRAW);
  } else {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.DYNAMIC_DRAW);
  }
  this.bindUniformBuffer(null);
  result.references = 1;
  return result;
};
ThinEngine.prototype.updateUniformBuffer = function(uniformBuffer, elements, offset, count) {
  this.bindUniformBuffer(uniformBuffer);
  if (offset === void 0) {
    offset = 0;
  }
  if (count === void 0) {
    if (elements instanceof Float32Array) {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, elements);
    } else {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(elements));
    }
  } else {
    if (elements instanceof Float32Array) {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, elements.subarray(offset, offset + count));
    } else {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(elements).subarray(offset, offset + count));
    }
  }
  this.bindUniformBuffer(null);
};
ThinEngine.prototype.bindUniformBuffer = function(buffer) {
  this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);
};
ThinEngine.prototype.bindUniformBufferBase = function(buffer, location2, name) {
  this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location2, buffer ? buffer.underlyingResource : null);
};
ThinEngine.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
  const program = pipelineContext.program;
  const uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
  if (uniformLocation !== 4294967295) {
    this._gl.uniformBlockBinding(program, uniformLocation, index);
  }
};

// node_modules/@babylonjs/core/Materials/uniformBuffer.js
var UniformBuffer = class _UniformBuffer {
  /**
   * Instantiates a new Uniform buffer objects.
   *
   * Handles blocks of uniform on the GPU.
   *
   * If WebGL 2 is not available, this class falls back on traditional setUniformXXX calls.
   *
   * For more information, please refer to :
   * @see https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object
   * @param engine Define the engine the buffer is associated with
   * @param data Define the data contained in the buffer
   * @param dynamic Define if the buffer is updatable
   * @param name to assign to the buffer (debugging purpose)
   * @param forceNoUniformBuffer define that this object must not rely on UBO objects
   */
  constructor(engine, data, dynamic, name, forceNoUniformBuffer = false) {
    this._valueCache = {};
    this._engine = engine;
    this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;
    this._dynamic = dynamic;
    this._name = name ?? "no-name";
    this._data = data || [];
    this._uniformLocations = {};
    this._uniformSizes = {};
    this._uniformArraySizes = {};
    this._uniformLocationPointer = 0;
    this._needSync = false;
    if (this._engine._features.trackUbosInFrame) {
      this._buffers = [];
      this._bufferIndex = -1;
      this._createBufferOnWrite = false;
      this._currentFrameId = 0;
    }
    if (this._noUBO) {
      this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;
      this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;
      this.updateFloat = this._updateFloatForEffect;
      this.updateFloat2 = this._updateFloat2ForEffect;
      this.updateFloat3 = this._updateFloat3ForEffect;
      this.updateFloat4 = this._updateFloat4ForEffect;
      this.updateFloatArray = this._updateFloatArrayForEffect;
      this.updateArray = this._updateArrayForEffect;
      this.updateIntArray = this._updateIntArrayForEffect;
      this.updateUIntArray = this._updateUIntArrayForEffect;
      this.updateMatrix = this._updateMatrixForEffect;
      this.updateMatrices = this._updateMatricesForEffect;
      this.updateVector3 = this._updateVector3ForEffect;
      this.updateVector4 = this._updateVector4ForEffect;
      this.updateColor3 = this._updateColor3ForEffect;
      this.updateColor4 = this._updateColor4ForEffect;
      this.updateDirectColor4 = this._updateDirectColor4ForEffect;
      this.updateInt = this._updateIntForEffect;
      this.updateInt2 = this._updateInt2ForEffect;
      this.updateInt3 = this._updateInt3ForEffect;
      this.updateInt4 = this._updateInt4ForEffect;
      this.updateUInt = this._updateUIntForEffect;
      this.updateUInt2 = this._updateUInt2ForEffect;
      this.updateUInt3 = this._updateUInt3ForEffect;
      this.updateUInt4 = this._updateUInt4ForEffect;
    } else {
      this._engine._uniformBuffers.push(this);
      this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;
      this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;
      this.updateFloat = this._updateFloatForUniform;
      this.updateFloat2 = this._updateFloat2ForUniform;
      this.updateFloat3 = this._updateFloat3ForUniform;
      this.updateFloat4 = this._updateFloat4ForUniform;
      this.updateFloatArray = this._updateFloatArrayForUniform;
      this.updateArray = this._updateArrayForUniform;
      this.updateIntArray = this._updateIntArrayForUniform;
      this.updateUIntArray = this._updateUIntArrayForUniform;
      this.updateMatrix = this._updateMatrixForUniform;
      this.updateMatrices = this._updateMatricesForUniform;
      this.updateVector3 = this._updateVector3ForUniform;
      this.updateVector4 = this._updateVector4ForUniform;
      this.updateColor3 = this._updateColor3ForUniform;
      this.updateColor4 = this._updateColor4ForUniform;
      this.updateDirectColor4 = this._updateDirectColor4ForUniform;
      this.updateInt = this._updateIntForUniform;
      this.updateInt2 = this._updateInt2ForUniform;
      this.updateInt3 = this._updateInt3ForUniform;
      this.updateInt4 = this._updateInt4ForUniform;
      this.updateUInt = this._updateUIntForUniform;
      this.updateUInt2 = this._updateUInt2ForUniform;
      this.updateUInt3 = this._updateUInt3ForUniform;
      this.updateUInt4 = this._updateUInt4ForUniform;
    }
  }
  /**
   * Indicates if the buffer is using the WebGL2 UBO implementation,
   * or just falling back on setUniformXXX calls.
   */
  get useUbo() {
    return !this._noUBO;
  }
  /**
   * Indicates if the WebGL underlying uniform buffer is in sync
   * with the javascript cache data.
   */
  get isSync() {
    return !this._needSync;
  }
  /**
   * Indicates if the WebGL underlying uniform buffer is dynamic.
   * Also, a dynamic UniformBuffer will disable cache verification and always
   * update the underlying WebGL uniform buffer to the GPU.
   * @returns if Dynamic, otherwise false
   */
  isDynamic() {
    return this._dynamic !== void 0;
  }
  /**
   * The data cache on JS side.
   * @returns the underlying data as a float array
   */
  getData() {
    return this._bufferData;
  }
  /**
   * The underlying WebGL Uniform buffer.
   * @returns the webgl buffer
   */
  getBuffer() {
    return this._buffer;
  }
  /**
   * std140 layout specifies how to align data within an UBO structure.
   * See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159
   * for specs.
   * @param size
   */
  _fillAlignment(size) {
    let alignment;
    if (size <= 2) {
      alignment = size;
    } else {
      alignment = 4;
    }
    if (this._uniformLocationPointer % alignment !== 0) {
      const oldPointer = this._uniformLocationPointer;
      this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;
      const diff = this._uniformLocationPointer - oldPointer;
      for (let i = 0; i < diff; i++) {
        this._data.push(0);
      }
    }
  }
  /**
   * Adds an uniform in the buffer.
   * Warning : the subsequents calls of this function must be in the same order as declared in the shader
   * for the layout to be correct ! The addUniform function only handles types like float, vec2, vec3, vec4, mat4,
   * meaning size=1,2,3,4 or 16. It does not handle struct types.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param size Data size, or data directly.
   * @param arraySize The number of elements in the array, 0 if not an array.
   */
  addUniform(name, size, arraySize = 0) {
    if (this._noUBO) {
      return;
    }
    if (this._uniformLocations[name] !== void 0) {
      return;
    }
    let data;
    if (arraySize > 0) {
      if (size instanceof Array) {
        throw "addUniform should not be use with Array in UBO: " + name;
      }
      this._fillAlignment(4);
      this._uniformArraySizes[name] = { strideSize: size, arraySize };
      if (size == 16) {
        size = size * arraySize;
      } else {
        const perElementPadding = 4 - size;
        const totalPadding = perElementPadding * arraySize;
        size = size * arraySize + totalPadding;
      }
      data = [];
      for (let i = 0; i < size; i++) {
        data.push(0);
      }
    } else {
      if (size instanceof Array) {
        data = size;
        size = data.length;
      } else {
        size = size;
        data = [];
        for (let i = 0; i < size; i++) {
          data.push(0);
        }
      }
      this._fillAlignment(size);
    }
    this._uniformSizes[name] = size;
    this._uniformLocations[name] = this._uniformLocationPointer;
    this._uniformLocationPointer += size;
    for (let i = 0; i < size; i++) {
      this._data.push(data[i]);
    }
    this._needSync = true;
  }
  /**
   * Adds a Matrix 4x4 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param mat A 4x4 matrix.
   */
  addMatrix(name, mat) {
    this.addUniform(name, Array.prototype.slice.call(mat.toArray()));
  }
  /**
   * Adds a vec2 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param x Define the x component value of the vec2
   * @param y Define the y component value of the vec2
   */
  addFloat2(name, x, y) {
    const temp = [x, y];
    this.addUniform(name, temp);
  }
  /**
   * Adds a vec3 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param x Define the x component value of the vec3
   * @param y Define the y component value of the vec3
   * @param z Define the z component value of the vec3
   */
  addFloat3(name, x, y, z) {
    const temp = [x, y, z];
    this.addUniform(name, temp);
  }
  /**
   * Adds a vec3 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param color Define the vec3 from a Color
   */
  addColor3(name, color) {
    const temp = [color.r, color.g, color.b];
    this.addUniform(name, temp);
  }
  /**
   * Adds a vec4 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param color Define the rgb components from a Color
   * @param alpha Define the a component of the vec4
   */
  addColor4(name, color, alpha) {
    const temp = [color.r, color.g, color.b, alpha];
    this.addUniform(name, temp);
  }
  /**
   * Adds a vec3 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   * @param vector Define the vec3 components from a Vector
   */
  addVector3(name, vector) {
    const temp = [vector.x, vector.y, vector.z];
    this.addUniform(name, temp);
  }
  /**
   * Adds a Matrix 3x3 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   */
  addMatrix3x3(name) {
    this.addUniform(name, 12);
  }
  /**
   * Adds a Matrix 2x2 to the uniform buffer.
   * @param name Name of the uniform, as used in the uniform block in the shader.
   */
  addMatrix2x2(name) {
    this.addUniform(name, 8);
  }
  /**
   * Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.
   */
  create() {
    if (this._noUBO) {
      return;
    }
    if (this._buffer) {
      return;
    }
    this._fillAlignment(4);
    this._bufferData = new Float32Array(this._data);
    this._rebuild();
    this._needSync = true;
  }
  // The result of this method is used for debugging purpose, as part of the buffer name
  // It is meant to more easily know what this buffer is about when debugging
  // Some buffers can have a lot of uniforms (several dozens), so the method only returns the first 10 of them
  // (should be enough to understand what the buffer is for)
  _getNames() {
    const names = [];
    let i = 0;
    for (const name in this._uniformLocations) {
      names.push(name);
      if (++i === 10) {
        break;
      }
    }
    return names.join(",");
  }
  /** @internal */
  _rebuild() {
    if (this._noUBO || !this._bufferData) {
      return;
    }
    if (this._dynamic) {
      this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData, this._name + "_UniformList:" + this._getNames());
    } else {
      this._buffer = this._engine.createUniformBuffer(this._bufferData, this._name + "_UniformList:" + this._getNames());
    }
    if (this._engine._features.trackUbosInFrame) {
      this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]);
      this._bufferIndex = this._buffers.length - 1;
      this._createBufferOnWrite = false;
    }
  }
  /** @internal */
  _rebuildAfterContextLost() {
    if (this._engine._features.trackUbosInFrame) {
      this._buffers = [];
      this._currentFrameId = 0;
    }
    this._rebuild();
  }
  /** @internal */
  get _numBuffers() {
    return this._buffers.length;
  }
  /** @internal */
  get _indexBuffer() {
    return this._bufferIndex;
  }
  /** Gets the name of this buffer */
  get name() {
    return this._name;
  }
  /** Gets the current effect */
  get currentEffect() {
    return this._currentEffect;
  }
  _buffersEqual(buf1, buf2) {
    for (let i = 0; i < buf1.length; ++i) {
      if (buf1[i] !== buf2[i]) {
        return false;
      }
    }
    return true;
  }
  _copyBuffer(src, dst) {
    for (let i = 0; i < src.length; ++i) {
      dst[i] = src[i];
    }
  }
  /**
   * Updates the WebGL Uniform Buffer on the GPU.
   * If the `dynamic` flag is set to true, no cache comparison is done.
   * Otherwise, the buffer will be updated only if the cache differs.
   */
  update() {
    if (this._noUBO) {
      return;
    }
    this.bindUniformBuffer();
    if (!this._buffer) {
      this.create();
      return;
    }
    if (!this._dynamic && !this._needSync) {
      this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
      return;
    }
    if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {
      if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {
        this._needSync = false;
        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
        return;
      } else {
        this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);
      }
    }
    this._engine.updateUniformBuffer(this._buffer, this._bufferData);
    if (this._engine._features._collectUbosUpdatedInFrame) {
      if (!_UniformBuffer._UpdatedUbosInFrame[this._name]) {
        _UniformBuffer._UpdatedUbosInFrame[this._name] = 0;
      }
      _UniformBuffer._UpdatedUbosInFrame[this._name]++;
    }
    this._needSync = false;
    this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
  }
  _createNewBuffer() {
    if (this._bufferIndex + 1 < this._buffers.length) {
      this._bufferIndex++;
      this._buffer = this._buffers[this._bufferIndex][0];
      this._createBufferOnWrite = false;
      this._needSync = true;
    } else {
      this._rebuild();
    }
  }
  _checkNewFrame() {
    if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {
      this._currentFrameId = this._engine.frameId;
      this._createBufferOnWrite = false;
      if (this._buffers && this._buffers.length > 0) {
        this._needSync = this._bufferIndex !== 0;
        this._bufferIndex = 0;
        this._buffer = this._buffers[this._bufferIndex][0];
      } else {
        this._bufferIndex = -1;
      }
    }
  }
  /**
   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.
   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.
   * @param data Define the flattened data
   * @param size Define the size of the data.
   */
  updateUniform(uniformName, data, size) {
    this._checkNewFrame();
    let location2 = this._uniformLocations[uniformName];
    if (location2 === void 0) {
      if (this._buffer) {
        Logger.Error("Cannot add an uniform after UBO has been created. uniformName=" + uniformName);
        return;
      }
      this.addUniform(uniformName, size);
      location2 = this._uniformLocations[uniformName];
    }
    if (!this._buffer) {
      this.create();
    }
    if (!this._dynamic) {
      let changed = false;
      for (let i = 0; i < size; i++) {
        if (size === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[location2 + i] !== Math.fround(data[i])) {
          changed = true;
          if (this._createBufferOnWrite) {
            this._createNewBuffer();
          }
          this._bufferData[location2 + i] = data[i];
        }
      }
      this._needSync = this._needSync || changed;
    } else {
      for (let i = 0; i < size; i++) {
        this._bufferData[location2 + i] = data[i];
      }
    }
  }
  /**
   * Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.
   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.
   * @param data Define the flattened data
   * @param size Define the size of the data.
   */
  updateUniformArray(uniformName, data, size) {
    this._checkNewFrame();
    const location2 = this._uniformLocations[uniformName];
    if (location2 === void 0) {
      Logger.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.");
      return;
    }
    if (!this._buffer) {
      this.create();
    }
    const arraySizes = this._uniformArraySizes[uniformName];
    if (!this._dynamic) {
      let changed = false;
      let countToFour = 0;
      let baseStride = 0;
      for (let i = 0; i < size; i++) {
        if (this._bufferData[location2 + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {
          changed = true;
          if (this._createBufferOnWrite) {
            this._createNewBuffer();
          }
          this._bufferData[location2 + baseStride * 4 + countToFour] = data[i];
        }
        countToFour++;
        if (countToFour === arraySizes.strideSize) {
          for (; countToFour < 4; countToFour++) {
            this._bufferData[location2 + baseStride * 4 + countToFour] = 0;
          }
          countToFour = 0;
          baseStride++;
        }
      }
      this._needSync = this._needSync || changed;
    } else {
      for (let i = 0; i < size; i++) {
        this._bufferData[location2 + i] = data[i];
      }
    }
  }
  _cacheMatrix(name, matrix) {
    this._checkNewFrame();
    const cache = this._valueCache[name];
    const flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[name] = flag;
    return true;
  }
  // Update methods
  _updateMatrix3x3ForUniform(name, matrix) {
    for (let i = 0; i < 3; i++) {
      _UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];
      _UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];
      _UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];
      _UniformBuffer._TempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name, _UniformBuffer._TempBuffer, 12);
  }
  _updateMatrix3x3ForEffect(name, matrix) {
    this._currentEffect.setMatrix3x3(name, matrix);
  }
  _updateMatrix2x2ForEffect(name, matrix) {
    this._currentEffect.setMatrix2x2(name, matrix);
  }
  _updateMatrix2x2ForUniform(name, matrix) {
    for (let i = 0; i < 2; i++) {
      _UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];
      _UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];
      _UniformBuffer._TempBuffer[i * 4 + 2] = 0;
      _UniformBuffer._TempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name, _UniformBuffer._TempBuffer, 8);
  }
  _updateFloatForEffect(name, x) {
    this._currentEffect.setFloat(name, x);
  }
  _updateFloatForUniform(name, x) {
    _UniformBuffer._TempBuffer[0] = x;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 1);
  }
  _updateFloat2ForEffect(name, x, y, suffix = "") {
    this._currentEffect.setFloat2(name + suffix, x, y);
  }
  _updateFloat2ForUniform(name, x, y) {
    _UniformBuffer._TempBuffer[0] = x;
    _UniformBuffer._TempBuffer[1] = y;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 2);
  }
  _updateFloat3ForEffect(name, x, y, z, suffix = "") {
    this._currentEffect.setFloat3(name + suffix, x, y, z);
  }
  _updateFloat3ForUniform(name, x, y, z) {
    _UniformBuffer._TempBuffer[0] = x;
    _UniformBuffer._TempBuffer[1] = y;
    _UniformBuffer._TempBuffer[2] = z;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 3);
  }
  _updateFloat4ForEffect(name, x, y, z, w, suffix = "") {
    this._currentEffect.setFloat4(name + suffix, x, y, z, w);
  }
  _updateFloat4ForUniform(name, x, y, z, w) {
    _UniformBuffer._TempBuffer[0] = x;
    _UniformBuffer._TempBuffer[1] = y;
    _UniformBuffer._TempBuffer[2] = z;
    _UniformBuffer._TempBuffer[3] = w;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  _updateFloatArrayForEffect(name, array) {
    this._currentEffect.setFloatArray(name, array);
  }
  _updateFloatArrayForUniform(name, array) {
    this.updateUniformArray(name, array, array.length);
  }
  _updateArrayForEffect(name, array) {
    this._currentEffect.setArray(name, array);
  }
  _updateArrayForUniform(name, array) {
    this.updateUniformArray(name, array, array.length);
  }
  _updateIntArrayForEffect(name, array) {
    this._currentEffect.setIntArray(name, array);
  }
  _updateIntArrayForUniform(name, array) {
    _UniformBuffer._TempBufferInt32View.set(array);
    this.updateUniformArray(name, _UniformBuffer._TempBuffer, array.length);
  }
  _updateUIntArrayForEffect(name, array) {
    this._currentEffect.setUIntArray(name, array);
  }
  _updateUIntArrayForUniform(name, array) {
    _UniformBuffer._TempBufferUInt32View.set(array);
    this.updateUniformArray(name, _UniformBuffer._TempBuffer, array.length);
  }
  _updateMatrixForEffect(name, mat) {
    this._currentEffect.setMatrix(name, mat);
  }
  _updateMatrixForUniform(name, mat) {
    if (this._cacheMatrix(name, mat)) {
      this.updateUniform(name, mat.toArray(), 16);
    }
  }
  _updateMatricesForEffect(name, mat) {
    this._currentEffect.setMatrices(name, mat);
  }
  _updateMatricesForUniform(name, mat) {
    this.updateUniform(name, mat, mat.length);
  }
  _updateVector3ForEffect(name, vector) {
    this._currentEffect.setVector3(name, vector);
  }
  _updateVector3ForUniform(name, vector) {
    _UniformBuffer._TempBuffer[0] = vector.x;
    _UniformBuffer._TempBuffer[1] = vector.y;
    _UniformBuffer._TempBuffer[2] = vector.z;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 3);
  }
  _updateVector4ForEffect(name, vector) {
    this._currentEffect.setVector4(name, vector);
  }
  _updateVector4ForUniform(name, vector) {
    _UniformBuffer._TempBuffer[0] = vector.x;
    _UniformBuffer._TempBuffer[1] = vector.y;
    _UniformBuffer._TempBuffer[2] = vector.z;
    _UniformBuffer._TempBuffer[3] = vector.w;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  _updateColor3ForEffect(name, color, suffix = "") {
    this._currentEffect.setColor3(name + suffix, color);
  }
  _updateColor3ForUniform(name, color) {
    _UniformBuffer._TempBuffer[0] = color.r;
    _UniformBuffer._TempBuffer[1] = color.g;
    _UniformBuffer._TempBuffer[2] = color.b;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 3);
  }
  _updateColor4ForEffect(name, color, alpha, suffix = "") {
    this._currentEffect.setColor4(name + suffix, color, alpha);
  }
  _updateDirectColor4ForEffect(name, color, suffix = "") {
    this._currentEffect.setDirectColor4(name + suffix, color);
  }
  _updateColor4ForUniform(name, color, alpha) {
    _UniformBuffer._TempBuffer[0] = color.r;
    _UniformBuffer._TempBuffer[1] = color.g;
    _UniformBuffer._TempBuffer[2] = color.b;
    _UniformBuffer._TempBuffer[3] = alpha;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  _updateDirectColor4ForUniform(name, color) {
    _UniformBuffer._TempBuffer[0] = color.r;
    _UniformBuffer._TempBuffer[1] = color.g;
    _UniformBuffer._TempBuffer[2] = color.b;
    _UniformBuffer._TempBuffer[3] = color.a;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  _updateIntForEffect(name, x, suffix = "") {
    this._currentEffect.setInt(name + suffix, x);
  }
  _updateIntForUniform(name, x) {
    _UniformBuffer._TempBufferInt32View[0] = x;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 1);
  }
  _updateInt2ForEffect(name, x, y, suffix = "") {
    this._currentEffect.setInt2(name + suffix, x, y);
  }
  _updateInt2ForUniform(name, x, y) {
    _UniformBuffer._TempBufferInt32View[0] = x;
    _UniformBuffer._TempBufferInt32View[1] = y;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 2);
  }
  _updateInt3ForEffect(name, x, y, z, suffix = "") {
    this._currentEffect.setInt3(name + suffix, x, y, z);
  }
  _updateInt3ForUniform(name, x, y, z) {
    _UniformBuffer._TempBufferInt32View[0] = x;
    _UniformBuffer._TempBufferInt32View[1] = y;
    _UniformBuffer._TempBufferInt32View[2] = z;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 3);
  }
  _updateInt4ForEffect(name, x, y, z, w, suffix = "") {
    this._currentEffect.setInt4(name + suffix, x, y, z, w);
  }
  _updateInt4ForUniform(name, x, y, z, w) {
    _UniformBuffer._TempBufferInt32View[0] = x;
    _UniformBuffer._TempBufferInt32View[1] = y;
    _UniformBuffer._TempBufferInt32View[2] = z;
    _UniformBuffer._TempBufferInt32View[3] = w;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  _updateUIntForEffect(name, x, suffix = "") {
    this._currentEffect.setUInt(name + suffix, x);
  }
  _updateUIntForUniform(name, x) {
    _UniformBuffer._TempBufferUInt32View[0] = x;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 1);
  }
  _updateUInt2ForEffect(name, x, y, suffix = "") {
    this._currentEffect.setUInt2(name + suffix, x, y);
  }
  _updateUInt2ForUniform(name, x, y) {
    _UniformBuffer._TempBufferUInt32View[0] = x;
    _UniformBuffer._TempBufferUInt32View[1] = y;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 2);
  }
  _updateUInt3ForEffect(name, x, y, z, suffix = "") {
    this._currentEffect.setUInt3(name + suffix, x, y, z);
  }
  _updateUInt3ForUniform(name, x, y, z) {
    _UniformBuffer._TempBufferUInt32View[0] = x;
    _UniformBuffer._TempBufferUInt32View[1] = y;
    _UniformBuffer._TempBufferUInt32View[2] = z;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 3);
  }
  _updateUInt4ForEffect(name, x, y, z, w, suffix = "") {
    this._currentEffect.setUInt4(name + suffix, x, y, z, w);
  }
  _updateUInt4ForUniform(name, x, y, z, w) {
    _UniformBuffer._TempBufferUInt32View[0] = x;
    _UniformBuffer._TempBufferUInt32View[1] = y;
    _UniformBuffer._TempBufferUInt32View[2] = z;
    _UniformBuffer._TempBufferUInt32View[3] = w;
    this.updateUniform(name, _UniformBuffer._TempBuffer, 4);
  }
  /**
   * Sets a sampler uniform on the effect.
   * @param name Define the name of the sampler.
   * @param texture Define the texture to set in the sampler
   */
  setTexture(name, texture) {
    this._currentEffect.setTexture(name, texture);
  }
  /**
   * Sets a sampler uniform on the effect.
   * @param name Define the name of the sampler.
   * @param texture Define the (internal) texture to set in the sampler
   */
  bindTexture(name, texture) {
    this._currentEffect._bindTexture(name, texture);
  }
  /**
   * Directly updates the value of the uniform in the cache AND on the GPU.
   * @param uniformName Define the name of the uniform, as used in the uniform block in the shader.
   * @param data Define the flattened data
   */
  updateUniformDirectly(uniformName, data) {
    this.updateUniform(uniformName, data, data.length);
    this.update();
  }
  /**
   * Associates an effect to this uniform buffer
   * @param effect Define the effect to associate the buffer to
   * @param name Name of the uniform block in the shader.
   */
  bindToEffect(effect, name) {
    this._currentEffect = effect;
    this._currentEffectName = name;
  }
  /**
   * Binds the current (GPU) buffer to the effect
   */
  bindUniformBuffer() {
    if (!this._noUBO && this._buffer && this._currentEffect) {
      this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);
    }
  }
  /**
   * Dissociates the current effect from this uniform buffer
   */
  unbindEffect() {
    this._currentEffect = void 0;
    this._currentEffectName = void 0;
  }
  /**
   * Sets the current state of the class (_bufferIndex, _buffer) to point to the data buffer passed in parameter if this buffer is one of the buffers handled by the class (meaning if it can be found in the _buffers array)
   * This method is meant to be able to update a buffer at any time: just call setDataBuffer to set the class in the right state, call some updateXXX methods and then call udpate() => that will update the GPU buffer on the graphic card
   * @param dataBuffer buffer to look for
   * @returns true if the buffer has been found and the class internal state points to it, else false
   */
  setDataBuffer(dataBuffer) {
    if (!this._buffers) {
      return this._buffer === dataBuffer;
    }
    for (let b = 0; b < this._buffers.length; ++b) {
      const buffer = this._buffers[b];
      if (buffer[0] === dataBuffer) {
        this._bufferIndex = b;
        this._buffer = dataBuffer;
        this._createBufferOnWrite = false;
        this._currentEffect = void 0;
        return true;
      }
    }
    return false;
  }
  /**
   * Disposes the uniform buffer.
   */
  dispose() {
    if (this._noUBO) {
      return;
    }
    const uniformBuffers = this._engine._uniformBuffers;
    const index = uniformBuffers.indexOf(this);
    if (index !== -1) {
      uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];
      uniformBuffers.pop();
    }
    if (this._engine._features.trackUbosInFrame && this._buffers) {
      for (let i = 0; i < this._buffers.length; ++i) {
        const buffer = this._buffers[i][0];
        this._engine._releaseBuffer(buffer);
      }
    } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {
      this._buffer = null;
    }
  }
};
UniformBuffer._UpdatedUbosInFrame = {};
UniformBuffer._MAX_UNIFORM_SIZE = 256;
UniformBuffer._TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);
UniformBuffer._TempBufferInt32View = new Int32Array(UniformBuffer._TempBuffer.buffer);
UniformBuffer._TempBufferUInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);

// node_modules/@babylonjs/core/Maths/math.axis.js
var Space;
(function(Space2) {
  Space2[Space2["LOCAL"] = 0] = "LOCAL";
  Space2[Space2["WORLD"] = 1] = "WORLD";
  Space2[Space2["BONE"] = 2] = "BONE";
})(Space || (Space = {}));
var Axis = class {
};
Axis.X = new Vector3(1, 0, 0);
Axis.Y = new Vector3(0, 1, 0);
Axis.Z = new Vector3(0, 0, 1);
var Coordinate;
(function(Coordinate2) {
  Coordinate2[Coordinate2["X"] = 0] = "X";
  Coordinate2[Coordinate2["Y"] = 1] = "Y";
  Coordinate2[Coordinate2["Z"] = 2] = "Z";
})(Coordinate || (Coordinate = {}));

// node_modules/@babylonjs/core/Lights/lightConstants.js
var LightConstants = class {
  /**
   * Sort function to order lights for rendering.
   * @param a First Light object to compare to second.
   * @param b Second Light object to compare first.
   * @returns -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.
   */
  static CompareLightsPriority(a, b) {
    if (a.shadowEnabled !== b.shadowEnabled) {
      return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);
    }
    return b.renderPriority - a.renderPriority;
  }
};
LightConstants.FALLOFF_DEFAULT = 0;
LightConstants.FALLOFF_PHYSICAL = 1;
LightConstants.FALLOFF_GLTF = 2;
LightConstants.FALLOFF_STANDARD = 3;
LightConstants.LIGHTMAP_DEFAULT = 0;
LightConstants.LIGHTMAP_SPECULAR = 1;
LightConstants.LIGHTMAP_SHADOWSONLY = 2;
LightConstants.INTENSITYMODE_AUTOMATIC = 0;
LightConstants.INTENSITYMODE_LUMINOUSPOWER = 1;
LightConstants.INTENSITYMODE_LUMINOUSINTENSITY = 2;
LightConstants.INTENSITYMODE_ILLUMINANCE = 3;
LightConstants.INTENSITYMODE_LUMINANCE = 4;
LightConstants.LIGHTTYPEID_POINTLIGHT = 0;
LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT = 1;
LightConstants.LIGHTTYPEID_SPOTLIGHT = 2;
LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT = 3;

export {
  __decorate,
  AndOrNotEvaluator,
  Tags,
  Scalar,
  ToGammaSpace,
  ToLinearSpace,
  PHI,
  Epsilon,
  ArrayTools,
  _ObserveArray,
  RegisterClass,
  GetClass,
  PerformanceConfigurator,
  EventState,
  Observer,
  Observable,
  EngineStore,
  Vector2,
  Vector3,
  Vector4,
  Quaternion,
  Matrix,
  TmpVectors,
  _WarnImport,
  Color3,
  Color4,
  TmpColors,
  expandToProperty,
  serialize,
  serializeAsTexture,
  serializeAsColor3,
  serializeAsFresnelParameters,
  serializeAsVector2,
  serializeAsVector3,
  serializeAsMeshReference,
  serializeAsColorCurves,
  serializeAsColor4,
  serializeAsImageProcessingConfiguration,
  serializeAsQuaternion,
  serializeAsMatrix,
  serializeAsCameraReference,
  SerializationHelper,
  nativeOverride,
  Node,
  Logger,
  IsWindowObjectExist,
  IsNavigatorAvailable,
  IsDocumentAvailable,
  GetDOMTextContent,
  DomManagement,
  DeepCopier,
  PrecisionDate,
  WebRequest,
  FilesInputStore,
  RetryStrategy,
  BaseError,
  ErrorCodes,
  RuntimeError,
  EndsWith,
  StartsWith,
  Decode,
  EncodeArrayBufferToBase64,
  DecodeBase64ToString,
  DecodeBase64ToBinary,
  PadNumber,
  StringTools,
  ShaderLanguage,
  ShaderProcessor,
  ShaderStore,
  Effect,
  DepthCullingState,
  StencilState,
  AlphaState,
  TextureSampler,
  InternalTextureSource,
  InternalTexture,
  WebGL2ShaderProcessor,
  DataBuffer,
  WebGLDataBuffer,
  WebGLPipelineContext,
  WebGLHardwareTexture,
  DrawWrapper,
  StencilStateComposer,
  ThinEngine,
  TimingTools,
  LoadFileError,
  RequestFileError,
  ReadFileError,
  FileToolsOptions,
  SetCorsBehavior,
  LoadImage,
  ReadFile,
  LoadFile,
  RequestFile,
  IsFileURL,
  IsBase64DataUrl,
  TestBase64DataUrl,
  DecodeBase64UrlToBinary,
  DecodeBase64UrlToString,
  FileTools,
  _injectLTSFileTools,
  InstantiationTools,
  RandomGUID,
  GUID,
  Tools,
  className,
  AsyncLoop,
  UniformBuffer,
  LightConstants,
  Space,
  Axis,
  Coordinate
};
//# sourceMappingURL=chunk-LLUYCI6X.js.map
